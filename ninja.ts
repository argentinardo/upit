/****
* Assets
****/
LK.init.shape('grassMask', {width:3000, height:3000, color:0x228b22, shape:'box'})
LK.init.shape('roadMask', {width:2048, height:800, color:0x000000, shape:'ellipse'})
LK.init.shape('skyBackground', {width:2048, height:1366, color:0x87ceeb, shape:'box'})
LK.init.image('Archer-ninja', {width:100, height:100, id:'687e2b5a5089f8124e100aa0'})
LK.init.image('Arma-ui', {width:100, height:100, id:'6880b9d8303aec2e4fad813e'})
LK.init.image('Enemy2', {width:250, height:288.29, id:'687d9735bdf42f92241c548b', flipX:1})
LK.init.image('Enemy3', {width:250, height:250, id:'687d9c5dbdf42f92241c54be', flipX:1})
LK.init.image('Ice-horiuken', {width:280, height:200, id:'687e1ca048730eff1e65a3f6', orientation:3})
LK.init.image('Mainscreen', {width:400, height:400, id:'6886dca33409d3f2dc0e0f22'})
LK.init.image('Wood-shoriuken', {width:100, height:100, id:'687e1b0348730eff1e65a39c'})
LK.init.image('airplane', {width:200, height:150, id:'687d9965bdf42f92241c54a8', flipX:1})
LK.init.image('alert', {width:100, height:100, id:'68856d419f9a0a22adc0c1ad'})
LK.init.image('archer-ninja', {width:500, height:500, id:'687e2b5a5089f8124e100a9f', flipX:1})
LK.init.image('archer-ninja-full-body', {width:100, height:100, id:'687e21af97be05183722092e', flipX:1})
LK.init.image('arrow', {width:40, height:17.34, id:'687e246697be05183722093f'})
LK.init.image('backgroundImage', {width:2048, height:2732, id:'687d7eae546d3d568db4f1d9'})
LK.init.image('center-ui-bg', {width:200, height:74.22, id:'6886b03e0363b585632d55ae'})
LK.init.image('cloud', {width:150, height:80, id:'687c37cce5cbe2bee2b1bfd1'})
LK.init.image('cloudType2', {width:200, height:197.66, id:'687d876bbdf42f92241c53ec'})
LK.init.image('cloudType3', {width:100, height:60, id:'687c37cce5cbe2bee2b1bfce'})
LK.init.image('electrocutado', {width:180, height:180, id:'687d5d90546d3d568db4ef77'})
LK.init.image('enemy', {width:300, height:307, id:'687c381ae5cbe2bee2b1bfdb', flipX:1})
LK.init.image('freeze-archer-ninja', {width:100, height:100, id:'687fda0388fabecfe2dd55cc'})
LK.init.image('freeze-enemy', {width:100, height:100, id:'687f88b35ad081944b422bcd'})
LK.init.image('freeze-enemy2', {width:100, height:100, id:'687f7fbeffc990ba21391f96'})
LK.init.image('freeze-enemy3', {width:100, height:100, id:'687f7de9ffc990ba21391f79'})
LK.init.image('frezze-airplane', {width:300, height:300, id:'687f7d395ad081944b422bab', flipX:1})
LK.init.image('greenBackground', {width:60, height:60, id:'687cda9602066f9f2984dce7'})
LK.init.image('icesun', {width:300, height:300, id:'687e5ec363d16be0c7d93b9f'})
LK.init.image('impact', {width:200, height:200, id:'687d5767c4a1a36a58c65588'})
LK.init.image('lightning', {width:33, height:50, id:'687d88e8bdf42f92241c5405', orientation:1})
LK.init.image('meteor', {width:100, height:100, id:'687cfa104caaf4399f3ee147'})
LK.init.image('meteorHit1', {width:100, height:100, id:'687d4065be19cec154f53235'})
LK.init.image('meteorHit2', {width:100, height:100, id:'687d4102be19cec154f53253'})
LK.init.image('montefuji', {width:1000, height:500, id:'687d7eae546d3d568db4f1d9'})
LK.init.image('ninja', {width:400, height:538.95, id:'687d55ebc4a1a36a58c65567'})
LK.init.image('ninja-jump', {width:300, height:300, id:'687d56e7c4a1a36a58c6557d'})
LK.init.image('ninjastar', {width:160, height:160, id:'687abe1613bc828807a1ea61'})
LK.init.image('nube-frezze', {width:200, height:197.66, id:'68856ebd9f9a0a22adc0c1b8'})
LK.init.image('obstacle', {width:300, height:314.75, id:'687e507f63d16be0c7d93ad2'})
LK.init.image('parachute', {width:80, height:80, id:'687da11abdf42f92241c54da'})
LK.init.image('powerup1', {width:60, height:60, id:'68864d1227e10acdc345396b'})
LK.init.image('powerup2', {width:60, height:60, id:'68864de727e10acdc345397a'})
LK.init.image('rockObstacle', {width:300, height:296, id:'687e5d2863d16be0c7d93b80'})
LK.init.image('spikeObstacle', {width:400, height:415, id:'687e583363d16be0c7d93b43'})
LK.init.image('sun', {width:300, height:300, id:'687d3878be19cec154f53150'})
LK.init.image('sunAttack', {width:150, height:150, id:'687cea1702066f9f2984ddca'})
LK.init.image('sunHit', {width:300, height:300, id:'687cea1702066f9f2984ddc8'})
LK.init.image('tori', {width:600, height:571.88, id:'687d14fd4caaf4399f3ee271'})
LK.init.image('tree', {width:400, height:600, id:'687ced1902066f9f2984ddec'})
LK.init.image('treeType2', {width:300, height:450, id:'687ced1902066f9f2984ddeb'})
LK.init.image('treeType3', {width:500, height:466.8, id:'687ced1902066f9f2984ddea'})
LK.init.image('wooden-start', {width:100, height:100, id:'687e1b0348730eff1e65a39c'})
LK.init.image('woodenPlank', {width:400, height:109.38, id:'687f83cc5ad081944b422bbb'})
LK.init.image('woodenPlank4', {width:400, height:235.94, id:'687d6ed8546d3d568db4f020'})
LK.init.sound('Arcer-apears', {volume:1, start:0, end:1, id:'687e2a4c5089f8124e100a91'})
LK.init.sound('Avion', {volume:1, start:0, end:1, id:'687d99e6bdf42f92241c54b4'})
LK.init.sound('Congelado', {volume:1, start:0, end:1, id:'687fdb2488fabecfe2dd55df'})
LK.init.sound('Enemy3', {volume:1, start:0.292, end:0.874, id:'687d9ca7bdf42f92241c54c4'})
LK.init.sound('Hit2', {volume:1, start:0, end:1, id:'687d9676bdf42f92241c5482'})
LK.init.sound('Ninjaarrowgrito', {volume:1, start:0, end:1, id:'687ce7c702066f9f2984dd9d'})
LK.init.sound('aeroplane-fall', {volume:1, start:0.411, end:0.431, id:'6886e3ee828e2fa043a9e80e'})
LK.init.sound('alert-sound')
LK.init.sound('archer-shoot', {volume:1, start:0, end:1, id:'687e298f5089f8124e100a87'})
LK.init.sound('electric-cloud-hit')
LK.init.sound('fallBox')
LK.init.sound('hit', {volume:1, start:0, end:1, id:'687ce7e702066f9f2984dda1'})
LK.init.sound('ice-throw')
LK.init.sound('icesun', {volume:1, start:0, end:1, id:'687e621463d16be0c7d93bbd'})
LK.init.sound('jump', {volume:1, start:0, end:1, id:'687ce4f802066f9f2984dd49'})
LK.init.sound('lightning', {volume:0.8, start:0, end:0.677, id:'687d04424caaf4399f3ee1ec'})
LK.init.music('main-theme', {volume:1, start:0, end:1, id:'687ce4796abc931f9db9a9e1'})
LK.init.music('mainTheme')
LK.init.sound('meteoro-golpe', {volume:1, start:0, end:1, id:'687d52a7c4a1a36a58c6553e'})
LK.init.sound('meteoro-grito', {volume:1, start:0, end:1, id:'687d42a0eec7e75544ba1ac5'})
LK.init.sound('meterito-voltea')
LK.init.sound('mushroom-hit')
LK.init.sound('ninja-ouch', {volume:1, start:0, end:1, id:'687d60a5546d3d568db4ef95'})
LK.init.sound('ninjaJump', {volume:1, start:0, end:1, id:'687cf1f902066f9f2984de22'})
LK.init.sound('pipipipipi', {volume:1, start:0, end:0.714, id:'687e658de214dcb39e5b1d0d'})
LK.init.sound('planefall', {volume:1, start:0, end:1, id:'687e25fe97be051837220948'})
LK.init.sound('sol-grito', {volume:1, start:0, end:1, id:'687d17df4caaf4399f3ee290'})
LK.init.sound('sol-risa', {volume:1, start:0, end:1, id:'687d50c6c4a1a36a58c65538'})
LK.init.sound('throw', {volume:1, start:0, end:1, id:'687ce54002066f9f2984dd53'})

/**** 
* Plugins
****/
var tween = LK.import("@upit/tween.v1");

/**** 
* Classes
****/
var Airplane = Container.expand(function () {
	var self = Container.call(this);
	var airplaneGraphics = self.attachAsset('airplane', {
		anchorX: 0.5,
		anchorY: 0.5,
		scaleX: 2.0,
		scaleY: 2.0
	});
	self.active = true;
	self.speed = 2;
	self.direction = 1; // 1 for right, -1 for left
	self.altitude = 800; // Flying height - much lower
	self.frozen = false; // Track if airplane is frozen
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		// Check if airplane is falling (hit by ice)
		if (self.falling) {
			// Apply gravity for nosedive
			self.fallVelocityY = self.fallVelocityY || 0;
			self.fallVelocityY += 1.2; // Strong gravity for fast fall
			// Move with falling physics
			self.x += self.fallVelocityX;
			self.y += self.fallVelocityY;
			// Rotate airplane to point downward during fall
			var airplaneGraphics = self.children[0];
			if (airplaneGraphics) {
				// Gradually rotate to point downward
				var targetRotation = Math.PI / 2; // 90 degrees down
				if (Math.abs(airplaneGraphics.rotation - targetRotation) > 0.1) {
					airplaneGraphics.rotation += (targetRotation - airplaneGraphics.rotation) * 0.1;
				}
			}
		} else {
			// Normal airplane flight
			self.x += self.speed * self.direction;
		}
		// Remove if off screen
		if (self.x < -200 || self.x > 2248 || self.y > 3332) {
			self.active = false;
		}
	};
	// Method to make airplane fall when hit by ice
	self.startFalling = function () {
		self.falling = true;
		self.frozen = true; // Mark airplane as frozen
		// Change to frozen airplane asset
		var airplaneGraphics = self.children[0];
		// Preserve original scale before destroying
		var originalScaleX = airplaneGraphics.scaleX;
		var originalScaleY = airplaneGraphics.scaleY;
		airplaneGraphics.destroy();
		var frozenGraphics = self.attachAsset('frezze-airplane', {
			anchorX: 0.5,
			anchorY: 0.5,
			scaleX: 1,
			scaleY: 1
		});
		// Apply ice blue tint
		tween(frozenGraphics, {
			tint: 0x87CEEB
		}, {
			duration: 300,
			easing: tween.easeOut
		});
		// Add trembling effect for 1 second
		var trembleCount = 0;
		var maxTrembles = 30; // 30 trembles over 1 second (30 frames)
		var trembleIntensity = 15;
		function createTrembling() {
			if (trembleCount < maxTrembles) {
				trembleCount++;
				var offsetX = (Math.random() - 0.5) * trembleIntensity;
				var offsetY = (Math.random() - 0.5) * trembleIntensity;
				tween(self, {
					x: self.x + offsetX,
					y: self.y + offsetY
				}, {
					duration: 33,
					// About 33ms per trembling
					easing: tween.linear,
					onFinish: function onFinish() {
						createTrembling(); // Continue trembling
					}
				});
			} else {
				// After trembling, start falling
				self.fallVelocityX = self.speed * self.direction * 0.5; // Reduced horizontal speed
				self.fallVelocityY = 1; // Initial downward velocity
				// Play plane fall sound when frozen/congealed
				LK.getSound('planefall').play();
			}
		}
		// Start trembling sequence
		createTrembling();
	};
	return self;
});
var Alert = Container.expand(function () {
	var self = Container.call(this);
	var alertGraphics = self.attachAsset('alert', {
		anchorX: 0.5,
		anchorY: 0.5,
		scaleX: 0.1,
		scaleY: 0.1
	});
	// Set initial scale on the graphics directly
	alertGraphics.scaleX = 0.1;
	alertGraphics.scaleY = 0.1;
	self.active = true;
	self.lifeTimer = 0;
	self.maxLifetime = 180; // 3 seconds - longer duration
	// Animate alert appearance with better visibility - animate the graphics directly
	tween(alertGraphics, {
		scaleX: 2.5,
		scaleY: 2.5
	}, {
		duration: 200,
		easing: tween.easeOut,
		onFinish: function onFinish() {
			// Hold at full size for a moment
			tween(alertGraphics, {
				scaleX: 2.0,
				scaleY: 2.0
			}, {
				duration: 300,
				easing: tween.linear,
				onFinish: function onFinish() {
					// Then fade out
					tween(alertGraphics, {
						scaleX: 0.1,
						scaleY: 0.1,
						alpha: 0
					}, {
						duration: 400,
						easing: tween.easeIn
					});
				}
			});
		}
	});
	self.update = function () {
		if (!self.active) {
			return;
		}
		self.lifeTimer++;
		if (self.lifeTimer >= self.maxLifetime) {
			self.active = false;
		}
	};
	return self;
});
var Arrow = Container.expand(function () {
	var self = Container.call(this);
	var arrowGraphics = self.attachAsset('arrow', {
		anchorX: 0.5,
		anchorY: 0.5
	});
	self.velocityX = 0;
	self.velocityY = 0;
	self.speed = 5;
	self.active = true;
	// Start small and scale up as it approaches
	self.scaleX = 3;
	self.scaleY = 3;
	// Tween to grow as arrow approaches
	tween(self, {
		scaleX: 4,
		scaleY: 4
	}, {
		duration: 1000,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		// Check if arrow is falling (hit state)
		if (self.falling) {
			// Apply gravity for falling
			self.fallVelocityY = self.fallVelocityY || 0;
			self.fallVelocityY += 0.8; // Gravity
			// Move with falling physics
			self.x += self.fallVelocityX;
			self.y += self.fallVelocityY;
			// Continuous spinning rotation
			arrowGraphics.rotation += self.spinSpeed;
		} else {
			// Normal arrow flight
			self.x += self.velocityX;
			self.y += self.velocityY;
			// Arrow maintains direction and grows as it approaches
			var angle = Math.atan2(self.velocityY, self.velocityX);
			arrowGraphics.rotation = angle;
		}
		// Remove if off screen
		if (self.x < -100 || self.x > 2148 || self.y < -100 || self.y > 3332) {
			self.active = false;
		}
	};
	// Method to make arrow fall when hit
	self.startFalling = function () {
		self.falling = true;
		// Set random sideways velocity (left or right)
		var direction = Math.random() < 0.5 ? -1 : 1;
		self.fallVelocityX = direction * (Math.random() * 4 + 2); // 2-6 speed sideways
		self.fallVelocityY = -(Math.random() * 3 + 1); // Small upward initial velocity
		// Set random spin speed
		self.spinSpeed = (Math.random() * 0.3 + 0.2) * direction; // 0.2-0.5 radians per frame
		// Stop scaling animation
		tween.stop(self);
	};
	return self;
});
var Cloud = Container.expand(function () {
	var self = Container.call(this);
	var cloudGraphics = self.attachAsset('cloud', {
		anchorX: 0.5,
		anchorY: 0.5,
		scaleX: 1.5,
		scaleY: 1.5
	});
	self.speed = Math.random() * 2 + 1; // Random speed between 1-3
	self.active = true;
	// Start with smaller scale and transparency
	self.scaleX = 0.3;
	self.scaleY = 0.3;
	cloudGraphics.alpha = 0.2; // Start very transparent
	tween(self, {
		scaleX: 1,
		scaleY: 1
	}, {
		duration: 500,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		// Move toward player from horizon (slower for depth)
		self.z = self.z || 2000; // Start very far away
		self.z -= self.speed;
		// Calculate perspective scaling and position (clouds stay in sky)
		var scale = Math.max(0.05, 1 - self.z / 2000);
		// Update transparency based on distance - closer clouds are more opaque
		var alpha = Math.min(1.0, Math.max(0.2, 1 - self.z / 1500));
		cloudGraphics.alpha = alpha;
		// Keep clouds in upper portion, slight perspective movement
		self.baseY = self.baseY || self.y;
		self.y = self.baseY + (horizonY - self.baseY) * (1 - scale) * 0.3;
		self.scaleX = scale;
		self.scaleY = scale;
		// Add horizontal movement proportional to distance from screen center
		var screenCenter = 1024;
		var distanceFromCenter = self.x - screenCenter;
		var horizontalSpeed = distanceFromCenter * 0.001; // Proportional movement
		self.x += horizontalSpeed;
		// When clouds get close, make them flee upward dramatically
		if (self.z <= 200) {
			// Start fleeing earlier when still some distance away
			var fleeSpeed = Math.max(8, (200 - self.z) * 0.3); // Increase speed as they get closer
			self.y -= fleeSpeed; // Move upward faster
			// Only remove when completely above screen
			if (self.y < -200) {
				self.active = false;
			}
		}
	};
	return self;
});
var CloudType3 = Container.expand(function () {
	var self = Container.call(this);
	var cloudGraphics = self.attachAsset('cloudType3', {
		anchorX: 0.5,
		anchorY: 0.5,
		scaleX: 1.5,
		scaleY: 1.5
	});
	self.speed = Math.random() * 3 + 2; // Faster clouds
	self.active = true;
	// Start with smaller scale and transparency
	self.scaleX = 0.3;
	self.scaleY = 0.3;
	cloudGraphics.alpha = 0.2; // Start very transparent
	tween(self, {
		scaleX: 1,
		scaleY: 1
	}, {
		duration: 500,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.z = self.z || 2000;
		self.z -= self.speed;
		var scale = Math.max(0.05, 1 - self.z / 2000);
		// Update transparency based on distance - closer clouds are more opaque
		var alpha = Math.min(1.0, Math.max(0.2, 1 - self.z / 1500));
		cloudGraphics.alpha = alpha;
		self.baseY = self.baseY || self.y;
		self.y = self.baseY + (horizonY - self.baseY) * (1 - scale) * 0.3;
		self.scaleX = scale;
		self.scaleY = scale;
		// Add horizontal movement proportional to distance from screen center
		var screenCenter = 1024;
		var distanceFromCenter = self.x - screenCenter;
		var horizontalSpeed = distanceFromCenter * 0.001; // Proportional movement
		self.x += horizontalSpeed;
		if (self.z <= 200) {
			// Start fleeing earlier when still some distance away
			var fleeSpeed = Math.max(10, (200 - self.z) * 0.4); // Faster flee speed for this cloud type
			self.y -= fleeSpeed;
			if (self.y < -200) {
				self.active = false;
			}
		}
	};
	return self;
});
var Enemy = Container.expand(function () {
	var self = Container.call(this);
	var enemyGraphics = self.attachAsset('enemy', {
		anchorX: 0.5,
		anchorY: 0.5
	});
	self.active = true;
	self.velocityX = 0;
	self.velocityY = 0;
	self.gravity = 0.15; // Much much slower gravity for very slow falling
	self.isJumping = true; // Start in jumping state
	self.groundY = 2532; // Ground level
	self.frozen = false; // Track if enemy is frozen
	// Initialize scale for distance-based scaling
	self.scaleX = 1; // Start larger when spawned far away
	self.scaleY = 1;
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		// Check if enemy is falling (hit state) - apply stronger gravity for falling
		if (self.falling) {
			self.velocityY += 0.8; // Stronger gravity for falling enemies
		} else {
			// Apply normal gravity and movement
			self.velocityY += self.gravity;
		}
		self.x += self.velocityX;
		self.y += self.velocityY;
		// Scale enemy based on distance to ninja
		if (ninja) {
			var dx = ninja.x - self.x;
			var dy = ninja.y - self.y;
			var distance = Math.sqrt(dx * dx + dy * dy);
			// Calculate scale based on distance - closer enemies are larger
			var maxDistance = 1500; // Maximum expected distance
			var minScale = 1.5; // Minimum scale when far away
			var maxScale = 2; // Maximum scale when very close
			var normalizedDistance = Math.min(distance / maxDistance, 1);
			var targetScale = maxScale - normalizedDistance * (maxScale - minScale);
			// Smooth scaling transition using tween
			if (Math.abs(self.scaleX - targetScale) > 0.05) {
				tween(self, {
					scaleX: targetScale,
					scaleY: targetScale
				}, {
					duration: 100,
					easing: tween.easeOut
				});
			}
		}
		// Check if enemy hits ground (only if not frozen and not falling)
		if (!self.frozen && !self.falling && self.y >= self.groundY) {
			self.y = self.groundY;
			self.velocityY = 0;
			self.isJumping = false;
		}
		// Remove if off screen or fallen enemies that have fallen off screen bottom
		if (self.x < -200 || self.x > 2248 || self.falling && self.y > 2800 || !self.falling && self.y > 3300) {
			self.active = false;
		}
	};
	return self;
});
var Enemy2 = Container.expand(function () {
	var self = Container.call(this);
	var enemyGraphics = self.attachAsset('Enemy2', {
		anchorX: 0.5,
		anchorY: 0.5
	});
	self.active = true;
	self.velocityX = 0;
	self.velocityY = 0;
	self.gravity = 0.15; // Same gravity as Enemy
	self.isJumping = true; // Start in jumping state
	self.groundY = 2532; // Ground level
	self.frozen = false; // Track if enemy is frozen
	// Initialize scale for distance-based scaling
	self.scaleX = 1.0; // Start larger when spawned far away - doubled from 0.5
	self.scaleY = 1.0;
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		// Check if enemy is falling (hit state) - apply stronger gravity for falling
		if (self.falling) {
			self.velocityY += 0.8; // Stronger gravity for falling enemies
		} else {
			// Apply normal gravity and movement
			self.velocityY += self.gravity;
		}
		self.x += self.velocityX;
		self.y += self.velocityY;
		// Scale enemy based on distance to ninja
		if (ninja) {
			var dx = ninja.x - self.x;
			var dy = ninja.y - self.y;
			var distance = Math.sqrt(dx * dx + dy * dy);
			// Calculate scale based on distance - closer enemies are larger
			var maxDistance = 1500; // Maximum expected distance
			var minScale = 1.0; // Minimum scale when far away - doubled from 0.5
			var maxScale = 4.0; // Maximum scale when very close - doubled from 2.0
			var normalizedDistance = Math.min(distance / maxDistance, 1);
			var targetScale = maxScale - normalizedDistance * (maxScale - minScale);
			// Smooth scaling transition using tween
			if (Math.abs(self.scaleX - targetScale) > 0.05) {
				tween(self, {
					scaleX: targetScale,
					scaleY: targetScale
				}, {
					duration: 100,
					easing: tween.easeOut
				});
			}
		}
		// Check if enemy hits ground (only if not frozen and not falling)
		if (!self.frozen && !self.falling && self.y >= self.groundY) {
			self.y = self.groundY;
			self.velocityY = 0;
			self.isJumping = false;
		}
		// Remove if off screen or fallen enemies that have fallen off screen bottom
		if (self.x < -200 || self.x > 2248 || self.falling && self.y > 2800 || !self.falling && self.y > 3300) {
			self.active = false;
		}
	};
	return self;
});
var Enemy3 = Container.expand(function () {
	var self = Container.call(this);
	var enemyGraphics = self.attachAsset('Enemy3', {
		anchorX: 0.5,
		anchorY: 0.5
	});
	self.active = true;
	self.velocityX = 0;
	self.velocityY = 0;
	self.gravity = 0.15; // Same gravity as other enemies
	self.isJumping = true; // Start in jumping state
	self.groundY = 2532; // Ground level
	self.frozen = false; // Track if enemy is frozen
	// Initialize scale for distance-based scaling
	self.scaleX = 1.0; // Start larger when spawned far away
	self.scaleY = 1.0;
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		// Check if enemy is falling (hit state) - apply stronger gravity for falling
		if (self.falling) {
			self.velocityY += 0.8; // Stronger gravity for falling enemies
		} else {
			// Apply normal gravity and movement
			self.velocityY += self.gravity;
		}
		self.x += self.velocityX;
		self.y += self.velocityY;
		// Scale enemy based on distance to ninja
		if (ninja) {
			var dx = ninja.x - self.x;
			var dy = ninja.y - self.y;
			var distance = Math.sqrt(dx * dx + dy * dy);
			// Calculate scale based on distance - closer enemies are larger
			var maxDistance = 1500; // Maximum expected distance
			var minScale = 1.0; // Minimum scale when far away
			var maxScale = 4.0; // Maximum scale when very close
			var normalizedDistance = Math.min(distance / maxDistance, 1);
			var targetScale = maxScale - normalizedDistance * (maxScale - minScale);
			// Smooth scaling transition using tween
			if (Math.abs(self.scaleX - targetScale) > 0.05) {
				tween(self, {
					scaleX: targetScale,
					scaleY: targetScale
				}, {
					duration: 100,
					easing: tween.easeOut
				});
			}
		}
		// Check if enemy hits ground (only if not frozen and not falling)
		if (!self.frozen && !self.falling && self.y >= self.groundY) {
			self.y = self.groundY;
			self.velocityY = 0;
			self.isJumping = false;
		}
		// Remove if off screen or fallen enemies that have fallen off screen bottom
		if (self.x < -200 || self.x > 2248 || self.falling && self.y > 2800 || !self.falling && self.y > 3300) {
			self.active = false;
		}
	};
	return self;
});
var EnemyArcher = Container.expand(function () {
	var self = Container.call(this);
	var archerGraphics = self.attachAsset('archer-ninja', {
		anchorX: 0.5,
		anchorY: 1.0
	});
	self.active = true;
	self.tree = null; // Reference to the tree this archer is on
	self.shootTimer = 0;
	self.detectionRange = 20000; // Even larger range to detect ninja from very far away
	self.lastDistance = null; // Track distance to ninja for approach detection
	self.frozen = false; // Track if archer is frozen
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		// Check if archer is falling (hit state)
		if (self.falling) {
			// Change to full body asset if not already changed
			if (self.children[0] && self.children[0].texture && self.children[0].texture.name !== 'archer-ninja-full-body') {
				// Preserve current scale and position
				var currentScaleX = self.children[0].scaleX;
				var currentScaleY = self.children[0].scaleY;
				var currentTint = self.children[0].tint;
				var currentRotation = self.children[0].rotation;
				// Destroy current graphics
				self.children[0].destroy();
				// Add full body archer graphics
				var fullBodyGraphics = self.attachAsset('archer-ninja-full-body', {
					anchorX: 0.5,
					anchorY: 1.0
				});
				// Restore visual properties
				fullBodyGraphics.scaleX = currentScaleX;
				fullBodyGraphics.scaleY = currentScaleY;
				fullBodyGraphics.tint = currentTint;
				fullBodyGraphics.rotation = currentRotation;
			}
			// Apply gravity for falling
			self.velocityY += 0.8; // Stronger gravity for falling enemies
			self.x += self.velocityX;
			self.y += self.velocityY;
			// Remove archer when it falls off screen - use lower threshold for fallen archers
			if (self.falling && self.y > 2800 || !self.falling && self.y > 3332) {
				self.active = false;
			}
			return; // Skip normal tree positioning when falling
		}
		// Stay positioned on tree crown
		if (self.tree && self.tree.active) {
			self.x = self.tree.x;
			self.y = self.tree.y - self.tree.scaleY * 300; // Position at tree crown
			// Match tree scaling for perspective
			self.scaleX = self.tree.scaleX * 0.4; // Smaller than tree
			self.scaleY = self.tree.scaleY * 0.4;
			// Check if ninja is within range and at ground level for shooting
			if (ninja) {
				var dx = ninja.x - self.x;
				var dy = ninja.y - self.y;
				var distance = Math.sqrt(dx * dx + dy * dy);
				// Check if ninja is at ground level (not jumping) and at similar height
				var heightDifference = Math.abs(dy);
				var isNinjaAtGroundLevel = !ninja.isJumping && ninja.y >= ninja.groundY - 50; // Allow small tolerance for ground detection
				var isSameHeight = heightDifference < 500;
				// Check if ninja is within horizontal shooting range - increased range
				var horizontalDistance = Math.abs(dx);
				var isInRange = horizontalDistance < 2000 && distance < self.detectionRange;
				// Only shoot if ninja is at ground level, at same height, and in range
				if (isNinjaAtGroundLevel && isSameHeight && isInRange) {
					self.shootArrow();
				}
			}
		} else {
			// Tree is gone - remove archer
			self.active = false;
		}
	};
	self.shootArrow = function () {
		if (!ninja) {
			return;
		} // Safety check
		// Check if archer is on cooldown
		if (self.lastShotTime && LK.ticks - self.lastShotTime < 180) {
			return; // Still on cooldown (3 seconds)
		}
		var arrow = new Arrow();
		arrow.x = self.x;
		arrow.y = self.y;
		// Calculate direction toward ninja
		var dx = ninja.x - arrow.x;
		var dy = ninja.y - arrow.y;
		var distance = Math.sqrt(dx * dx + dy * dy);
		// Set arrow velocity toward ninja
		arrow.velocityX = dx / distance * arrow.speed;
		arrow.velocityY = dy / distance * arrow.speed;
		// Ensure arrows array exists before pushing
		if (typeof arrows === 'undefined') {
			arrows = [];
		}
		arrows.push(arrow);
		game.addChild(arrow);
		// Set cooldown timer
		self.lastShotTime = LK.ticks;
		// Play archer shooting sound when arrow appears
		LK.getSound('archer-shoot').play();
		// Change archer state after shooting - tween to show shooting pose
		var archerGraphics = self.children[0];
		tween(archerGraphics, {
			scaleX: archerGraphics.scaleX * 1.2,
			scaleY: archerGraphics.scaleY * 1.2
		}, {
			duration: 200,
			easing: tween.easeOut,
			onFinish: function onFinish() {
				tween(archerGraphics, {
					scaleX: archerGraphics.scaleX / 1.2,
					scaleY: archerGraphics.scaleY / 1.2
				}, {
					duration: 300,
					easing: tween.easeIn
				});
			}
		});
	};
	return self;
});
// Fog class removed - no fog elements needed for clearer gameplay
var IceStar = Container.expand(function () {
	var self = Container.call(this);
	var starGraphics = self.attachAsset('Ice-horiuken', {
		anchorX: 0.5,
		anchorY: 0.5,
		scaleX: 1.5,
		scaleY: 1.5
	});
	self.velocityX = 0;
	self.velocityY = 0;
	self.speed = 12;
	self.active = true;
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.x += self.velocityX;
		self.y += self.velocityY;
		// Calculate distance from ninja and shrink as it travels away
		if (ninja) {
			var dx = ninja.x - self.x;
			var dy = ninja.y - self.y;
			var distance = Math.sqrt(dx * dx + dy * dy);
			// Scale from 1.0 to 0.1 based on distance (farther = smaller)
			var maxDistance = 1500; // Maximum expected distance before removal
			var minScale = 0.1;
			var maxScale = 1.0;
			var normalizedDistance = Math.min(distance / maxDistance, 1);
			var scale = maxScale - normalizedDistance * (maxScale - minScale);
			self.scaleX = scale;
			self.scaleY = scale;
		}
		// Ice stars don't rotate - they maintain their orientation
		// Remove if off screen
		if (self.x < -100 || self.x > 2148 || self.y < -100 || self.y > 3332) {
			self.active = false;
		}
	};
	return self;
});
var Lightning = Container.expand(function () {
	var self = Container.call(this);
	var lightningGraphics = self.attachAsset('lightning', {
		anchorX: 0.5,
		anchorY: 0
	});
	self.active = true;
	self.lifeTimer = 0; // Temporizador de vida del rayo
	self.maxLifetime = 120; // 2 segundos (120 frames)
	self.flickerTimer = 0; // Temporizador para el parpadeo
	self.visible = true; // Visibilidad para el parpadeo
	lightningGraphics.alpha = 0; // Comienza invisible
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.lifeTimer++;
		self.flickerTimer++;
		// Efecto de parpadeo
		if (self.flickerTimer <= 30) {
			if (self.flickerTimer % 3 === 0) {
				self.visible = !self.visible;
				lightningGraphics.alpha = self.visible ? 1 : 0;
			}
		} else if (self.flickerTimer <= 60) {
			if (self.flickerTimer % 6 === 0) {
				self.visible = !self.visible;
				lightningGraphics.alpha = self.visible ? 0.8 : 0;
			}
		} else if (self.flickerTimer <= 90) {
			if (self.flickerTimer % 10 === 0) {
				self.visible = !self.visible;
				lightningGraphics.alpha = self.visible ? 0.5 : 0;
			}
		} else {
			var fadeProgress = (self.flickerTimer - 90) / 30;
			lightningGraphics.alpha = Math.max(0, 0.3 * (1 - fadeProgress));
		}
		// Actualiza el rayo para que vaya del centro inferior de la nube al centro del ninja
		self.stretchTo();
		if (self.lifeTimer >= self.maxLifetime) {
			self.active = false;
		}
	};
	// Estira el rayo desde el centro de la nube al centro del ninja
	self.stretchTo = function () {
		if (!ninja) {
			return;
		}
		var cloud = self.parent;
		// Centro de la nube (asumiendo anchorX=0.5, anchorY=0.5)
		var cloudCenterX = cloud ? cloud.x : self.x;
		var cloudCenterY = cloud ? cloud.y : self.y;
		// Centro del ninja (asumiendo anchorX=0.5, anchorY=0.5 para asset electrocutado)
		var ninjaCenterX = ninja.x;
		var ninjaCenterY = ninja.y;
		// Calcula la diferencia entre centros
		var dx = ninjaCenterX - cloudCenterX;
		var dy = ninjaCenterY - cloudCenterY;
		var distance = Math.sqrt(dx * dx + dy * dy);
		// Ángulo para apuntar del centro de la nube al centro del ninja
		var angle = Math.atan2(dy, dx) - Math.PI / 2; // El asset apunta hacia arriba
		// Escala y rota el rayo para conectar los centros
		lightningGraphics.scaleY = distance / 50;
		lightningGraphics.scaleX = 2;
		lightningGraphics.rotation = angle;
		// Posiciona el rayo en el centro de la nube
		lightningGraphics.x = 0; // El rayo está centrado en X respecto al contenedor
		lightningGraphics.y = 0; // Centro de la nube
	};
	return self;
});
var Meteorite = Container.expand(function () {
	var self = Container.call(this);
	var meteoriteGraphics = self.attachAsset('meteor', {
		anchorX: 0.5,
		anchorY: 0.5
	});
	self.active = true;
	self.speed = 3; // Slow movement toward ninja
	self.velocityX = 0;
	self.velocityY = 0;
	self.hitCount = 0; // Track how many times it's been hit
	// Start with zero scale and grow as it approaches
	self.scaleX = 0.05;
	self.scaleY = 0.05;
	// Method to change face based on hit count
	self.changeFace = function () {
		// Play meterito-voltea sound when meteorite flips
		LK.getSound('meterito-voltea').play();
		// Remove current graphics
		meteoriteGraphics.destroy();
		// Add new graphics based on hit count
		if (self.hitCount === 1) {
			meteoriteGraphics = self.attachAsset('meteorHit1', {
				anchorX: 0.5,
				anchorY: 0.5
			});
		} else if (self.hitCount === 2) {
			meteoriteGraphics = self.attachAsset('meteorHit2', {
				anchorX: 0.5,
				anchorY: 0.5
			});
		}
	};
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.x += self.velocityX;
		self.y += self.velocityY;
		// Grow linearly over time instead of based on distance
		self.lifeTime = self.lifeTime || 0;
		self.lifeTime++;
		// Linear growth from 0.05 to 2.5 over 200 frames (about 3.3 seconds)
		var maxLifeTime = 200;
		var minScale = 0.05;
		var maxScale = 2.5;
		var progress = Math.min(self.lifeTime / maxLifeTime, 1);
		var scale = minScale + progress * (maxScale - minScale);
		self.scaleX = scale;
		self.scaleY = scale;
		// Remove if off screen
		if (self.x < -100 || self.x > 2148 || self.y < -100 || self.y > 3332) {
			self.active = false;
		}
	};
	return self;
});
var Ninja = Container.expand(function () {
	var self = Container.call(this);
	var ninjaGraphics = self.attachAsset('ninja', {
		anchorX: 0.5,
		anchorY: 1.0
	});
	self.groundY = 2673; // Ground at 98% of screen height (2732 * 0.98 = 2677, rounded to 2673)
	self.isJumping = false;
	self.jumpVelocity = 0;
	self.jumpSpeed = -45; // Much higher initial jump velocity
	self.gravity = 0.8; // Reduced gravity for longer hang time
	self.maxJumpHeight = 1800; // Much higher maximum jump height
	self.runningTimer = 0;
	self.flipDirection = 1;
	self.jumpCount = 0; // Track number of jumps (0 = on ground, 1 = first jump, 2 = double jump)
	self.maxJumps = 2; // Allow double jump
	self.jump = function () {
		if (self.jumpCount < self.maxJumps && !ninjaParalyzed) {
			self.jumpCount++;
			self.isJumping = true;
			LK.getSound('jump').play();
			// Change sprite to ninja-jump during jump
			ninjaGraphics.destroy();
			ninjaGraphics = self.attachAsset('ninja-jump', {
				anchorX: 0.5,
				anchorY: 0.5
			});
			// Determine jump height and timing - second jump goes higher than first
			var jumpHeight = self.jumpCount === 1 ? self.maxJumpHeight : self.maxJumpHeight - 300;
			var totalJumpDuration = 800; // Total time for complete jump cycle
			// If this is the second jump (double jump), stop any existing tweens and jump from current position
			if (self.jumpCount === 2) {
				tween.stop(self); // Stop current movement
				tween.stop(ninjaGraphics); // Stop any existing rotation
				jumpHeight = self.y - 500; // Jump 500px higher from current position
			}
			// Add 3 rotations during jump - duration matches total jump time
			tween(ninjaGraphics, {
				rotation: Math.PI * 6
			}, {
				duration: totalJumpDuration,
				easing: tween.linear
			});
			// Use tween for smooth, high, faster jump
			tween(self, {
				y: jumpHeight
			}, {
				duration: 400,
				// 400ms to reach peak (much faster)
				easing: tween.easeOut,
				onFinish: function onFinish() {
					// Tween back down to ground
					tween(self, {
						y: self.groundY
					}, {
						duration: 400,
						// 400ms to fall back down
						easing: tween.easeIn,
						onFinish: function onFinish() {
							self.isJumping = false;
							self.jumpVelocity = 0;
							self.jumpCount = 0; // Reset jump count when landing
							// Stop rotation immediately when landing
							tween.stop(ninjaGraphics);
							// Change back to normal ninja sprite
							ninjaGraphics.destroy();
							ninjaGraphics = self.attachAsset('ninja', {
								anchorX: 0.5,
								anchorY: 1.0
							});
							// Reset rotation
							ninjaGraphics.rotation = 0;
						}
					});
				}
			});
		}
	};
	self.update = function () {
		if (game.paused) {
			return;
		}
		// Running animation - flip sprite every 10 ticks for natural running motion
		self.runningTimer++;
		if (self.runningTimer >= 30) {
			self.flipDirection = -self.flipDirection;
			ninjaGraphics.scaleX = self.flipDirection;
			self.runningTimer = 0;
		}
	};
	return self;
});
var NinjaStar = Container.expand(function () {
	var self = Container.call(this);
	var starGraphics = self.attachAsset('ninjastar', {
		anchorX: 0.5,
		anchorY: 0.5
	});
	self.velocityX = 0;
	self.velocityY = 0;
	self.speed = 12;
	self.active = true;
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.x += self.velocityX;
		self.y += self.velocityY;
		// Calculate distance from ninja and shrink as it travels away
		if (ninja) {
			var dx = ninja.x - self.x;
			var dy = ninja.y - self.y;
			var distance = Math.sqrt(dx * dx + dy * dy);
			// Scale from 1.0 to 0.1 based on distance (farther = smaller)
			var maxDistance = 1500; // Maximum expected distance before removal
			var minScale = 0.3;
			var maxScale = 1.5;
			var normalizedDistance = Math.min(distance / maxDistance, 1);
			var scale = maxScale - normalizedDistance * (maxScale - minScale);
			self.scaleX = scale;
			self.scaleY = scale;
		}
		// Rotate ninja star - one full rotation per second (60 FPS = 60 ticks per second)
		starGraphics.rotation += Math.PI * 2 / 60; // 2π radians per 60 ticks = 1 rotation per second
		// Remove if off screen
		if (self.x < -100 || self.x > 2148 || self.y < -100 || self.y > 3332) {
			self.active = false;
		}
	};
	return self;
});
var Obstacle = Container.expand(function () {
	var self = Container.call(this);
	var obstacleGraphics = self.attachAsset('obstacle', {
		anchorX: 0.5,
		anchorY: 1.0
	});
	self.speed = 3;
	self.active = true;
	self.baseX = 1024; // Start from center of horizon
	self.side = 0; // Keep in center for jumping
	// Start with zero scale and tween to grow
	self.scaleX = 0.1;
	self.scaleY = 0.1;
	tween(self, {
		scaleX: 1,
		scaleY: 1
	}, {
		duration: 600,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		// Move toward player from horizon with acceleration
		self.z = self.z || 1000; // Start far away
		// Calculate acceleration based on distance - closer objects move faster
		var distanceFactor = Math.max(0.1, 1 - self.z / 1000); // 0.1 to 1.0
		var currentSpeed = self.speed * (0.3 + distanceFactor * 2); // Speed ranges from 0.9 to 6.9
		self.z -= currentSpeed;
		// Calculate perspective scaling and position
		var scale = Math.max(0.1, 1 - self.z / 1000);
		var horizonY = 1503; // Horizon line position moved 10% lower
		var groundY = 2532; // Ground position
		var perspectiveY = horizonY + (groundY - horizonY) * scale; // From horizon to ground
		self.y = perspectiveY - 35;
		// Keep obstacles in center for ninja to jump over them
		self.x = self.baseX; // Stay in center for jumping
		self.scaleX = scale * 1.33; // 33% larger trunks
		self.scaleY = scale * 1.33; // 33% larger trunks
		// Remove if too close or below screen
		if (self.z <= -500 || self.y > 3000) {
			self.active = false;
		}
	};
	return self;
});
var PowerUp = Container.expand(function () {
	var self = Container.call(this);
	var powerupGraphics = self.attachAsset('powerup1', {
		anchorX: 0.5,
		anchorY: 0.5,
		y: 100,
		// Position below parachute
		scaleX: 2.5,
		scaleY: 2.5
	});
	var parachuteGraphics = self.attachAsset('parachute', {
		anchorX: 0.5,
		anchorY: 1.0,
		y: 40,
		scaleX: 2.5,
		scaleY: 2.5
	});
	self.active = true;
	self.fallSpeed = 2;
	self.swayAmount = 1;
	self.swayTimer = 0;
	self.powerupType = 1; // Will be set when created
	// Gentle swaying motion
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		// Fall down with parachute effect
		self.y += self.fallSpeed;
		// Sway left and right gently
		self.swayTimer += 0.1;
		var targetX = ninja.x + Math.sin(self.swayTimer) * self.swayAmount * 20;
		// Move toward ninja horizontally with gentle drift
		var dx = targetX - self.x;
		self.x += dx * 0.02; // Gentle drift toward ninja
		// Rotate parachute slightly for realism
		parachuteGraphics.rotation = Math.sin(self.swayTimer) * 0.2;
		// Remove if hits ground or goes off screen
		if (self.y > 3232 || self.x < -100 || self.x > 2148) {
			self.active = false;
		}
	};
	// Method to set power-up type
	self.setPowerUpType = function (type) {
		self.powerupType = type;
		powerupGraphics.destroy();
		if (type === 1) {
			powerupGraphics = self.attachAsset('powerup1', {
				anchorX: 0.5,
				anchorY: 0.5,
				y: 100,
				scaleX: 2.5,
				scaleY: 2.5
			});
		} else if (type === 2) {
			powerupGraphics = self.attachAsset('powerup2', {
				anchorX: 0.5,
				anchorY: 0.5,
				y: 100,
				scaleX: 2.5,
				scaleY: 2.5
			});
		}
		// Ensure parachute stays in front by re-adding it
		var tempParachute = parachuteGraphics;
		self.removeChild(parachuteGraphics);
		self.addChild(tempParachute);
	};
	return self;
});
var RockObstacle = Container.expand(function () {
	var self = Container.call(this);
	var obstacleGraphics = self.attachAsset('rockObstacle', {
		anchorX: 0.5,
		anchorY: 1.0
	});
	self.speed = 3;
	self.active = true;
	self.baseX = 1024;
	self.side = 0; // Keep in center for jumping
	// Start with zero scale and tween to grow
	self.scaleX = 0.1;
	self.scaleY = 0.1;
	tween(self, {
		scaleX: 1,
		scaleY: 1
	}, {
		duration: 600,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.z = self.z || 1000;
		// Calculate acceleration based on distance - closer objects move faster
		var distanceFactor = Math.max(0.1, 1 - self.z / 1000); // 0.1 to 1.0
		var currentSpeed = self.speed * (0.3 + distanceFactor * 2); // Speed ranges from 0.9 to 6.9
		self.z -= currentSpeed;
		var scale = Math.max(0.1, 1 - self.z / 1000);
		var horizonY = 1503;
		var groundY = 2532;
		var perspectiveY = horizonY + (groundY - horizonY) * scale;
		self.y = perspectiveY - 35;
		// Keep obstacles in center for ninja to jump over them
		self.x = self.baseX; // Stay in center for jumping
		self.scaleX = scale * 1.33; // 33% larger rocks
		self.scaleY = scale * 1.33; // 33% larger rocks
		if (self.z <= -500 || self.y > 3000) {
			self.active = false;
		}
	};
	return self;
});
var SpikeObstacle = Container.expand(function () {
	var self = Container.call(this);
	var obstacleGraphics = self.attachAsset('spikeObstacle', {
		anchorX: 0.5,
		anchorY: 1.0
	});
	self.speed = 3;
	self.active = true;
	self.baseX = 1024;
	self.side = 0; // Keep in center for jumping
	// Start with zero scale and tween to grow
	self.scaleX = 0.1;
	self.scaleY = 0.1;
	tween(self, {
		scaleX: 1,
		scaleY: 1
	}, {
		duration: 600,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.z = self.z || 1000;
		// Calculate acceleration based on distance - closer objects move faster
		var distanceFactor = Math.max(0.1, 1 - self.z / 1000); // 0.1 to 1.0
		var currentSpeed = self.speed * (0.3 + distanceFactor * 2); // Speed ranges from 0.9 to 6.9
		self.z -= currentSpeed;
		var scale = Math.max(0.1, 1 - self.z / 1000);
		var horizonY = 1503;
		var groundY = 2532;
		var perspectiveY = horizonY + (groundY - horizonY) * scale;
		self.y = perspectiveY - 35;
		// Keep obstacles in center for ninja to jump over them
		self.x = self.baseX; // Stay in center for jumping
		self.scaleX = scale;
		self.scaleY = scale;
		if (self.z <= -500 || self.y > 3000) {
			self.active = false;
		}
	};
	return self;
});
var Tori = Container.expand(function () {
	var self = Container.call(this);
	var toriGraphics = self.attachAsset('tori', {
		anchorX: 0.5,
		anchorY: 1.0
	});
	self.speed = 3;
	self.active = true;
	self.baseX = 1024;
	// Start with zero scale and tween to grow
	self.scaleX = 0.1;
	self.scaleY = 0.1;
	tween(self, {
		scaleX: 1,
		scaleY: 1
	}, {
		duration: 700,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		// Move toward player from horizon with acceleration
		self.z = self.z || 1000; // Start far away
		// Calculate acceleration based on distance - closer objects move faster
		var distanceFactor = Math.max(0.1, 1 - self.z / 1000); // 0.1 to 1.0
		var currentSpeed = self.speed * (0.3 + distanceFactor * 2); // Speed ranges from 0.9 to 6.9
		self.z -= currentSpeed;
		// Calculate perspective scaling and position
		var scale = Math.max(0.1, 1 - self.z / 1000);
		var horizonY = 1503; // Horizon line position moved 10% lower
		var groundY = 2532; // Ground position
		var perspectiveY = horizonY + (groundY - horizonY) * scale;
		self.y = perspectiveY;
		// Tori stays in center for ninja to pass underneath
		self.x = self.baseX; // Keep in center, no spreading
		// Make tori much larger to create proper archway
		var toriScale = scale * 2.0; // Reduced scaling to make it smaller
		self.scaleX = toriScale;
		self.scaleY = toriScale;
		// Remove if too close or below screen
		if (self.z <= -500 || self.y > 3000) {
			self.active = false;
		}
	};
	return self;
});
var Tree = Container.expand(function () {
	var self = Container.call(this);
	var treeGraphics = self.attachAsset('tree', {
		anchorX: 0.5,
		anchorY: 1.0
	});
	self.speed = 3;
	self.active = true;
	self.baseX = 1024; // Trees start from center of horizon
	self.side = 1; // 1 for right, -1 for left
	// Start with zero scale and transparency
	self.scaleX = 0;
	self.scaleY = 0;
	treeGraphics.alpha = 0; // Start completely transparent
	tween(self, {
		scaleX: 1,
		scaleY: 1
	}, {
		duration: 800,
		easing: tween.easeOut
	});
	tween(treeGraphics, {
		alpha: 1
	}, {
		duration: 800,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		// Move toward player from horizon with acceleration
		self.z = self.z || 1000; // Start far away
		// Calculate acceleration based on distance - closer objects move faster
		var distanceFactor = Math.max(0.1, 1 - self.z / 1000); // 0.1 to 1.0
		var currentSpeed = self.speed * (0.3 + distanceFactor * 2); // Speed ranges from 0.9 to 6.9
		self.z -= currentSpeed;
		// Calculate perspective scaling and position
		var scale = Math.max(0.1, 1 - self.z / 1000);
		var horizonY = 1503; // Horizon line position moved 10% lower
		var groundY = 2532; // Ground position
		var perspectiveY = horizonY + (groundY - horizonY) * scale;
		self.y = perspectiveY;
		// Align trees with wooden plank boundaries but much further away
		var plankWidth = 400 * scale * 2; // Wooden plank scaled width (400 base width * scale * 2 plank scale)
		var plankBoundary = plankWidth / 2; // Half width from center to edge
		var extraSeparation = 300 * scale; // Additional separation from planks
		self.x = self.baseX + (plankBoundary + extraSeparation) * self.side; // Position much further from plank edges
		// Much smaller scaling for smaller trees
		var treeScale = scale * 1.73; // 33% larger trees (1.3 * 1.33 = 1.73)
		self.scaleX = treeScale;
		self.scaleY = treeScale;
		// Remove trees when they get too close or go off screen - extend removal to below screen
		if (self.z <= -500 || self.x < -300 || self.x > 2348 || self.y > 3400) {
			self.active = false;
		}
	};
	return self;
});
var TreeType2 = Container.expand(function () {
	var self = Container.call(this);
	var treeGraphics = self.attachAsset('treeType2', {
		anchorX: 0.5,
		anchorY: 1.0
	});
	self.speed = 3;
	self.active = true;
	self.baseX = 1024;
	self.side = 1;
	// Start with zero scale and transparency
	self.scaleX = 0;
	self.scaleY = 0;
	treeGraphics.alpha = 0; // Start completely transparent
	tween(self, {
		scaleX: 1,
		scaleY: 1
	}, {
		duration: 800,
		easing: tween.easeOut
	});
	tween(treeGraphics, {
		alpha: 1
	}, {
		duration: 800,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.z = self.z || 1000;
		// Calculate acceleration based on distance - closer objects move faster
		var distanceFactor = Math.max(0.1, 1 - self.z / 1000); // 0.1 to 1.0
		var currentSpeed = self.speed * (0.3 + distanceFactor * 2); // Speed ranges from 0.9 to 6.9
		self.z -= currentSpeed;
		var scale = Math.max(0.1, 1 - self.z / 1000);
		var horizonY = 1503;
		var groundY = 2532;
		var perspectiveY = horizonY + (groundY - horizonY) * scale;
		self.y = perspectiveY;
		// Align trees with wooden plank boundaries but much further away
		var plankWidth = 400 * scale * 2; // Wooden plank scaled width
		var plankBoundary = plankWidth / 2; // Half width from center to edge
		var extraSeparation = 300 * scale; // Additional separation from planks
		self.x = self.baseX + (plankBoundary + extraSeparation) * self.side; // Position much further from plank edges
		var treeScale = scale * 1.73; // 33% larger scaling (1.3 * 1.33 = 1.73)
		self.scaleX = treeScale;
		self.scaleY = treeScale;
		if (self.z <= -500 || self.x < -300 || self.x > 2348 || self.y > 3400) {
			self.active = false;
		}
	};
	return self;
});
var TreeType3 = Container.expand(function () {
	var self = Container.call(this);
	var treeGraphics = self.attachAsset('treeType3', {
		anchorX: 0.5,
		anchorY: 1.0
	});
	self.speed = 3;
	self.active = true;
	self.baseX = 1024;
	self.side = 1;
	// Start with zero scale and transparency
	self.scaleX = 0;
	self.scaleY = 0;
	treeGraphics.alpha = 0; // Start completely transparent
	tween(self, {
		scaleX: 1,
		scaleY: 1
	}, {
		duration: 800,
		easing: tween.easeOut
	});
	tween(treeGraphics, {
		alpha: 1
	}, {
		duration: 800,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.z = self.z || 1000;
		// Calculate acceleration based on distance - closer objects move faster
		var distanceFactor = Math.max(0.1, 1 - self.z / 1000); // 0.1 to 1.0
		var currentSpeed = self.speed * (0.3 + distanceFactor * 2); // Speed ranges from 0.9 to 6.9
		self.z -= currentSpeed;
		var scale = Math.max(0.1, 1 - self.z / 1000);
		var horizonY = 1503;
		var groundY = 2532;
		var perspectiveY = horizonY + (groundY - horizonY) * scale;
		self.y = perspectiveY;
		// Align trees with wooden plank boundaries but much further away
		var plankWidth = 400 * scale * 2; // Wooden plank scaled width
		var plankBoundary = plankWidth / 2; // Half width from center to edge
		var extraSeparation = 300 * scale; // Additional separation from planks
		self.x = self.baseX + (plankBoundary + extraSeparation) * self.side; // Position much further from plank edges
		var treeScale = scale * 1.73; // 33% larger scaling (1.3 * 1.33 = 1.73)
		self.scaleX = treeScale;
		self.scaleY = treeScale;
		if (self.z <= -500 || self.x < -300 || self.x > 2348 || self.y > 3400) {
			self.active = false;
		}
	};
	return self;
});
var WoodenPlank = Container.expand(function () {
	var self = Container.call(this);
	var plankGraphics = self.attachAsset('woodenPlank', {
		anchorX: 0.5,
		anchorY: 0.5
	});
	self.speed = 3;
	self.active = true;
	self.baseX = 1024; // Start from center of horizon
	self.side = 0; // Center position
	// Start with zero scale and tween to grow
	self.scaleX = 0.1;
	self.scaleY = 0.1;
	tween(self, {
		scaleX: 1,
		scaleY: 1
	}, {
		duration: 600,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		// Move toward player from horizon with acceleration
		self.z = self.z || 1000; // Start far away
		// Calculate acceleration based on distance - closer objects move faster
		var distanceFactor = Math.max(0.1, 1 - self.z / 1000); // 0.1 to 1.0
		var currentSpeed = self.speed * (0.3 + distanceFactor * 2); // Speed ranges from 0.9 to 6.9
		self.z -= currentSpeed;
		// Calculate perspective scaling and position
		var scale = Math.max(0.1, 1 - self.z / 1000);
		var horizonY = 1503; // Horizon line position moved 10% lower
		var groundY = 2532; // Ground position
		var perspectiveY = horizonY + (groundY - horizonY) * scale;
		self.y = perspectiveY - 20; // Slightly above ground for walkway effect
		// Keep wooden planks centered - no horizontal spreading
		self.x = self.baseX; // Keep planks aligned in center
		// Scale plank appropriately with perspective - narrower and extend below screen
		var plankScale = scale * 2; // Further reduced from 3 to make even narrower
		self.scaleX = plankScale;
		// Make planks much taller to extend from horizon to below screen
		var verticalScale = scale * 1.665; // Reduced height to half of current size (3.33 / 2)
		self.scaleY = verticalScale;
		// Remove planks only when their top edge goes below screen bottom (y > 2732)
		// Calculate the top edge of the plank based on its position and scale
		var plankTopY = self.y - self.scaleY * 20; // Half height of scaled plank (original height 40, so half is 20)
		if (plankTopY > 2732) {
			// Plank's top edge is below screen bottom - now safe to remove
			self.active = false;
		}
	};
	return self;
});
var WoodenStar = Container.expand(function () {
	var self = Container.call(this);
	var starGraphics = self.attachAsset('wooden-start', {
		anchorX: 0.5,
		anchorY: 0.5
	});
	self.velocityX = 0;
	self.velocityY = 0;
	self.speed = 12;
	self.active = true;
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.x += self.velocityX;
		self.y += self.velocityY;
		// Calculate distance from ninja and shrink as it travels away
		if (ninja) {
			var dx = ninja.x - self.x;
			var dy = ninja.y - self.y;
			var distance = Math.sqrt(dx * dx + dy * dy);
			// Scale from 1.0 to 0.1 based on distance (farther = smaller)
			var maxDistance = 1500; // Maximum expected distance before removal
			var minScale = 0.1;
			var maxScale = 1.0;
			var normalizedDistance = Math.min(distance / maxDistance, 1);
			var scale = maxScale - normalizedDistance * (maxScale - minScale);
			self.scaleX = scale;
			self.scaleY = scale;
		}
		// Wooden stars don't rotate - they maintain their orientation
		// Remove if off screen
		if (self.x < -100 || self.x > 2148 || self.y < -100 || self.y > 3332) {
			self.active = false;
		}
	};
	return self;
});
var electroCloud = Container.expand(function () {
	var self = Container.call(this);
	var cloudGraphics = self.attachAsset('cloudType2', {
		anchorX: 0.5,
		anchorY: 0.5,
		scaleX: 0.75,
		scaleY: 0.75
	});
	self.speed = Math.random() * 1.5 + 0.5; // Different speed range
	self.active = true;
	// Start with smaller scale and transparency
	self.scaleX = 0.3;
	self.scaleY = 0.3;
	cloudGraphics.alpha = 0.2; // Start very transparent
	tween(self, {
		scaleX: 1,
		scaleY: 1
	}, {
		duration: 500,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.z = self.z || 2000;
		self.z -= self.speed;
		var scale = Math.max(0.05, 1 - self.z / 2000);
		// Update transparency based on distance - closer clouds are more opaque
		var alpha = Math.min(1.0, Math.max(0.2, 1 - self.z / 1500));
		// Add flickering effect to indicate charged lightning cloud
		self.flickerTimer = self.flickerTimer || 0;
		self.flickerTimer++;
		if (self.flickerTimer % 30 === 0) {
			// Flicker every 0.5 seconds
			// Create a slight pulsing tint effect
			var tintPhase = Math.sin(self.flickerTimer * 0.2) * 0.5 + 0.5; // 0 to 1
			var lightningTint = 0x9999FF; // Light blue tint to indicate electricity
			tween(cloudGraphics, {
				tint: lightningTint
			}, {
				duration: 150,
				easing: tween.easeInOut,
				onFinish: function onFinish() {
					tween(cloudGraphics, {
						tint: 0xFFFFFF
					}, {
						duration: 150,
						easing: tween.easeInOut
					});
				}
			});
		}
		cloudGraphics.alpha = alpha;
		self.baseY = self.baseY || self.y;
		self.y = self.baseY + (horizonY - self.baseY) * (1 - scale) * 0.3;
		self.scaleX = scale;
		self.scaleY = scale;
		// Add horizontal movement proportional to distance from screen center
		var screenCenter = 1024;
		var distanceFromCenter = self.x - screenCenter;
		var horizontalSpeed = distanceFromCenter * 0.001; // Proportional movement
		self.x += horizontalSpeed;
		if (self.z <= 200) {
			// Start fleeing earlier when still some distance away
			var fleeSpeed = Math.max(6, (200 - self.z) * 0.2); // Increase speed as they get closer
			self.y -= fleeSpeed;
			if (self.y < -200) {
				self.active = false;
			}
		}
	};
	return self;
});

/**** 
* Initialize Game
****/
var game = new LK.Game({
	backgroundColor: 0x00BFFF
});

/**** 
* Game Code
****/
// Fog assets removed - no fog elements in game
// Game variables
var ninja;
var ninjaStars = [];
var enemies = [];
var enemies2 = [];
var enemies3 = [];
var obstacles = [];
var electricalNinjas = [];
var enemySpawnTimer = 0;
var enemy2SpawnTimer = 0;
var enemy3SpawnTimer = 0;
var lastEnemySpawnSide = 0; // Track last side that spawned an enemy (-1 left, 1 right, 0 none)
var lastEnemySpawnTime = 0; // Track when last enemy was spawned
var minSpawnDelay = 240; // Minimum delay between enemy spawns (4 seconds at 60fps) - increased for better separation
var obstacleSpawnTimer = 0;
var swipeStartX = 0;
var swipeStartY = 0;
var isSwipeActive = false;
var clouds = [];
var cloudSpawnTimer = 0;
var trees = [];
var treeSpawnTimer = 0;
var ninjaSpawnTimer = 0;
var meteorites = [];
var lightnings = [];
var sunFaceTimer = 0; // Timer for sun face change duration
var sunIsHit = false; // Track if sun is currently in hit state
var ninjaParalyzed = false;
var ninjaParalyzeTimer = 0;
var toris = [];
var toriSpawnTimer = 0;
var woodenPlanks = [];
var lastPlankSpawnY = 0; // Track Y position of last spawned plank
var plankRegularDistance = 50; // Regular distance between planks - reduced to 50px spacing
var airplanes = [];
var airplaneSpawnTimer = 0;
var powerUps = [];
var woodenStars = [];
var hasWoodenStarPower = false;
var woodenStarPowerTimer = 0;
var woodenStarDuration = 1800; // 30 seconds at 60fps
var hasIcePower = false;
var icePowerTimer = 0;
var icePowerDuration = 1800; // 30 seconds at 60fps
var iceStars = [];
var alerts = [];
var sunFrozen = false;
var sunFrozenTimer = 0;
var sunFrozenDuration = 600; // 10 seconds at 60fps
// Progressive difficulty system
var difficultyLevel = 1;
var gameStartTime = 0;
var enemyArchers = [];
var arrows = [];
// Main screen popup variables
var mainScreenActive = true;
var mainScreenTimer = 0;
var mainScreenMinTime = 180; // 3 seconds at 60fps
var mainScreenPopup;
var mainScreenMask;
var swipeStartXPopup = 0;
var swipeStartYPopup = 0;
var isSwipingPopup = false;
// Function to check current difficulty level based on time survived
function getCurrentDifficultyLevel() {
	var timeSurvived = Math.floor((LK.ticks - gameStartTime) / 60); // seconds
	if (timeSurvived < 30) {
		return 1;
	} // Level 1: 0-30 seconds - basic game
	else if (timeSurvived < 60) {
		return 2;
	} // Level 2: 30-60 seconds - add lightning clouds
	else if (timeSurvived < 120) {
		return 3;
	} // Level 3: 1-2 minutes - add more objects
	else if (timeSurvived < 180) {
		return 4;
	} // Level 4: 2-3 minutes - increase spawn rates
	else {
		return 5;
	} // Level 5: 3+ minutes - electrical ninjas
}
// Function to check if feature is unlocked at current difficulty
function isFeatureUnlocked(feature) {
	// All features unlocked from the start - no difficulty restrictions
	return true;
}
// Function to show alert above ninja head when objects spawn
function showAlert() {
	if (!ninja) {
		return;
	}
	var alert = new Alert();
	alert.x = ninja.x;
	alert.y = ninja.y - 900; // Position above ninja head
	alerts.push(alert);
	game.addChild(alert);
	// Play alert sound
	try {
		LK.getSound('alert-sound').play();
	} catch (e) {
		// Fallback sound if alert-sound doesn't work
		LK.getSound('jump').play();
	}
}
// Create tiled green background pattern starting at wooden plank height with perspective
var greenBackgrounds = [];
var backgroundAsset = LK.getAsset('greenBackground', {});
var tileWidth = backgroundAsset.width;
var tileHeight = backgroundAsset.height;
var fieldWidth = 2048;
var horizonY = 1583; // Horizon moved much lower - increased from 1543 to 1583 (40px lower)
var woodenPlankStartY = horizonY; // Start grass at same height as wooden planks
var fieldHeight = 2732 - woodenPlankStartY; // From wooden plank level to bottom of screen
// Calculate perspective tiles with varying scale based on distance from wooden plank level
var perspectiveRows = 15; // Number of perspective rows from wooden plank level to bottom
var tilesX = 20; // Fixed number of horizontal tiles
for (var row = 0; row < perspectiveRows; row++) {
	// Calculate perspective scale - smaller at wooden plank level (distance), larger at bottom (close)
	var rowProgress = row / (perspectiveRows - 1); // 0 at wooden plank level to 1 at bottom
	var perspectiveScale = 2 + rowProgress * 6; // Scale from 2 (small/far) to 8 (big/close)
	// Calculate Y position with perspective spacing - start from wooden plank level
	var rowY = woodenPlankStartY + fieldHeight * rowProgress;
	var _loop = function _loop() {
			greenTile = game.addChild(LK.getAsset('greenBackground', {
				anchorX: 0,
				anchorY: 0,
				x: col * tileWidth * perspectiveScale - tilesX * tileWidth * perspectiveScale / 2 + fieldWidth / 2,
				y: rowY,
				scaleX: perspectiveScale,
				scaleY: perspectiveScale
			})); // Store original properties for enhanced forward motion animation
			greenTile.originalY = rowY;
			greenTile.perspectiveScale = perspectiveScale;
			greenTile.rowIndex = row;
			greenTile.originalX = greenTile.x; // Store original X position for forward motion
			greenBackgrounds.push(greenTile);
			// Store tile reference for background animation with forward motion effects
			// Individual tiles will have coordinated movement for ninja advancement illusion
		},
		greenTile;
	for (var col = 0; col < tilesX; col++) {
		_loop();
	}
}
// Create sky background covering from top to 60% of screen height (1640px) - at the very back
var skyBackground = game.addChildAt(LK.getAsset('skyBackground', {
	anchorX: 0,
	anchorY: 0,
	x: 0,
	y: 0,
	scaleX: 1,
	scaleY: 1.2
}), 0);
// Create solid green background layer beneath grass tiles - covers lower half of screen
var greenLayer = game.addChildAt(LK.getAsset('grassMask', {
	anchorX: 0,
	anchorY: 0,
	x: 0,
	y: 1200,
	// Position higher up (moved from 1366 to 1200)
	scaleX: 1,
	scaleY: 0.61,
	// Increase scale to cover more area (from 0.5 to 0.6)
	tint: 0x90EE90,
	// Light green color
	alpha: 1 // Fully opaque
}), 0);
// Create sun in background (behind everything else but above mask)
var sun = game.addChild(LK.getAsset('sun', {
	anchorX: 0.5,
	anchorY: 0.5,
	x: 1700,
	// Position sun in upper right
	y: 300,
	scaleX: 1.5,
	scaleY: 1.5
}));
// Pre-populate with wooden planks to create running walkway
for (var prePlankIndex = 0; prePlankIndex < 8; prePlankIndex++) {
	var plank = new WoodenPlank();
	plank.x = 1024;
	plank.y = horizonY;
	plank.z = 50 + prePlankIndex * 50; // Start closer and use 50px spacing
	plank.baseX = 1024;
	plank.speed = 3;
	woodenPlanks.push(plank);
	// Insert planks on the ground level, above green background but below other objects
	var plankInsertIndex = greenBackgrounds.length + 1;
	if (plankInsertIndex > game.children.length) {
		plankInsertIndex = game.children.length;
	}
	game.addChildAt(plank, plankInsertIndex);
}
// Initialize last plank spawn Y position after pre-population
lastPlankSpawnY = 50 + 7 * 50; // Last pre-populated plank position with 50px spacing
// Pre-populate with trees at various distances to simulate game already started
for (var preTreeIndex = 0; preTreeIndex < 5; preTreeIndex++) {
	// Create trees at different z distances to fill the field
	var leftTreeType = Math.random();
	var leftTree;
	if (leftTreeType < 0.33) {
		leftTree = new Tree();
	} else if (leftTreeType < 0.66) {
		leftTree = new TreeType2();
	} else {
		leftTree = new TreeType3();
	}
	leftTree.x = 1024;
	leftTree.y = horizonY;
	leftTree.z = 200 + preTreeIndex * 80; // Spread trees from near to far
	leftTree.side = -1;
	trees.push(leftTree);
	// Trees that appear first (smaller z) should have higher z-index (appear behind)
	var insertIndex = greenBackgrounds.length + 2 + (4 - preTreeIndex);
	if (insertIndex > game.children.length) {
		insertIndex = game.children.length;
	}
	game.addChildAt(leftTree, insertIndex);
	// Right side tree
	var rightTreeType = Math.random();
	var rightTree;
	if (rightTreeType < 0.33) {
		rightTree = new Tree();
	} else if (rightTreeType < 0.66) {
		rightTree = new TreeType2();
	} else {
		rightTree = new TreeType3();
	}
	rightTree.x = 1024;
	rightTree.y = horizonY;
	rightTree.z = 250 + preTreeIndex * 80; // Slightly offset from left trees
	rightTree.side = 1;
	trees.push(rightTree);
	var rightInsertIndex = greenBackgrounds.length + 2 + (4 - preTreeIndex);
	if (rightInsertIndex > game.children.length) {
		rightInsertIndex = game.children.length;
	}
	game.addChildAt(rightTree, rightInsertIndex);
}
// Pre-populate with clouds at various distances
for (var preCloudIndex = 0; preCloudIndex < 8; preCloudIndex++) {
	var cloudType = Math.random();
	var cloud;
	if (cloudType < 0.45) {
		cloud = new Cloud();
	} else if (cloudType < 0.55) {
		cloud = new electroCloud();
	} else {
		cloud = new CloudType3();
	}
	cloud.x = Math.random() * 1200 + 400;
	cloud.y = horizonY - 200 + Math.random() * 200 - 100; // Spawn higher in sky with some variation
	cloud.baseY = cloud.y;
	cloud.z = 500 + preCloudIndex * 200; // Spread clouds at different distances
	clouds.push(cloud);
	// Add clouds in front of sun - find sun's position and add cloud after it
	var sunIndex = game.children.indexOf(sun);
	var cloudIndex = Math.min(sunIndex + 1, game.children.length);
	game.addChildAt(cloud, cloudIndex);
}
// Fog system removed - no pre-population needed for clearer gameplay
// Create ninja
ninja = game.addChild(new Ninja());
ninja.x = 1024;
ninja.y = 2673; // Keep ninja at same ground position regardless of horizon change
// Initialize background animation system for grass tiles
var backgroundOffsetY = 0;
var backgroundAnimationSpeed = 2; // Speed of background scrolling
var grassAnimationTimer = 0; // Timer for coordinated grass movements
// Start continuous background animation with enhanced forward motion for ninja advancement illusion
function animateGrassBackground() {
	// Drive background animation primarily based on ninja's Y position for powerful forward motion effect
	if (ninja) {
		// Use ninja's Y position as primary driver - higher Y creates stronger backward flow effect
		// Combine with ninja's movement state and time for dynamic forward advancement sensation
		var ninjaYInfluence = (ninja.y - ninja.groundY) * 0.08; // Stronger Y position influence when jumping/moving
		var ninjaMotionBoost = ninja.isJumping ? 1.5 : 1.0; // Extra boost during jumps
		backgroundOffsetY = ninjaYInfluence * ninjaMotionBoost + LK.ticks * 0.2; // Ninja Y drives background displacement
	} else {
		// Fallback to time-based animation if ninja doesn't exist
		backgroundOffsetY += backgroundAnimationSpeed * 4; // Higher speed for forward motion
	}
	// Increment animation timer for coordinated movements with enhanced speed
	grassAnimationTimer += 0.15; // Increased speed for more dynamic forward movement
	// Apply enhanced forward motion animation to grass tiles driven by ninja Y position
	for (var i = 0; i < greenBackgrounds.length; i++) {
		var tile = greenBackgrounds[i];
		// Create strong forward movement waves that flow toward the ninja from wooden plank level
		var distanceFromNinja = ninja ? Math.abs(tile.originalX - ninja.x) : 1000;
		var forwardMotionIntensity = Math.max(0.4, 1 - distanceFromNinja / 1500); // Higher base intensity, closer tiles move more
		// Create flowing motion pattern driven by ninja's Y position for advancement through field
		var ninjaYPhase = ninja ? (ninja.y - ninja.groundY) * 0.003 : 0; // Y position creates phase shift
		var flowPhase = tile.rowIndex * 0.8 + grassAnimationTimer - backgroundOffsetY * 0.2 + ninjaYPhase;
		var forwardFlow = Math.sin(flowPhase) * forwardMotionIntensity * 6; // Stronger forward flowing motion
		// Enhanced horizontal drift based on perspective and ninja Y - creates stronger 3D motion
		var perspectiveMotion = (tile.originalX - 1024) * 0.003 * forwardMotionIntensity;
		var ninjaYMotion = ninja ? (ninja.y - ninja.groundY) * 0.001 * forwardMotionIntensity : 0;
		// Stronger vertical forward motion driven by ninja Y - simulates ground rushing toward ninja
		var forwardVerticalMotion = Math.sin(flowPhase * 1.1) * forwardMotionIntensity * 5;
		var ninjaYVerticalBoost = ninja ? (ninja.y - ninja.groundY) * 0.002 : 0;
		// Enhanced scaling pulsation that reinforces forward advancement based on ninja Y
		var motionScale = 1 + Math.sin(flowPhase * 0.8) * 0.06 * forwardMotionIntensity;
		// Create wave-like motion that travels from distant tiles toward ninja, enhanced by Y position
		var advancementWave = Math.sin(flowPhase - tile.rowIndex * 0.4) * forwardMotionIntensity * 2.5;
		var ninjaYWave = ninja ? Math.sin(ninjaYPhase + tile.rowIndex * 0.2) * (ninja.y - ninja.groundY) * 0.001 : 0;
		// Calculate target position with enhanced forward motion effects driven by ninja Y
		var targetX = tile.originalX + perspectiveMotion + advancementWave + ninjaYMotion;
		var targetY = tile.originalY + forwardVerticalMotion - forwardFlow + advancementWave * 0.6 + ninjaYVerticalBoost + ninjaYWave;
		// Animate tile to new position with stronger forward motion
		tween(tile, {
			x: targetX,
			y: targetY,
			scaleX: tile.perspectiveScale * motionScale,
			scaleY: tile.perspectiveScale * motionScale
		}, {
			duration: 50,
			// Faster animation for smoother forward advancement sensation
			easing: tween.easeInOut
		});
	}
	// Background animation creates strong visual perception of ninja advancement driven by Y position
	// Continue animation loop
	tween({}, {}, {
		duration: 16,
		// ~60fps update rate
		easing: tween.linear,
		onFinish: function onFinish() {
			animateGrassBackground();
		}
	});
}
// Start the background animation
animateGrassBackground();
// Play main theme music
LK.playMusic('main-theme');
// Create semi-transparent black mask overlay
var mainScreenMask = game.addChild(LK.getAsset('grassMask', {
	anchorX: 0,
	anchorY: 0,
	x: 0,
	y: 0,
	scaleX: 1,
	scaleY: 1.665,
	tint: 0x000000,
	alpha: 0.8
}));
// Add blur effect to the mask for visual enhancement
tween(mainScreenMask, {
	alpha: 0.8
}, {
	duration: 300,
	easing: tween.easeOut
});
// Create main screen popup
mainScreenPopup = game.addChild(LK.getAsset('Mainscreen', {
	anchorX: 0.5,
	anchorY: 0.5,
	x: 1024,
	y: 1366,
	scaleX: 3.0,
	scaleY: 3.0
}));
// Add popup to ensure it's on top
game.removeChild(mainScreenPopup);
game.addChild(mainScreenPopup);
// Animate popup entrance
tween(mainScreenPopup, {
	scaleX: 2.5,
	scaleY: 2.5
}, {
	duration: 300,
	easing: tween.easeOut
});
// Create center UI background in top center using center-ui-bg asset
var centerUIBackground = game.addChild(LK.getAsset('center-ui-bg', {
	anchorX: 0.5,
	anchorY: 0.5,
	x: 1024,
	// Center of screen
	y: 300,
	// Same Y position as weapon indicator
	scaleX: 4.0,
	scaleY: 4.0,
	alpha: 1
}));
// Create weapon indicator in top-left corner using Arma-ui as background with improved styling
var weaponIndicator = game.addChild(LK.getAsset('Arma-ui', {
	anchorX: 0.5,
	anchorY: 0.5,
	x: 300,
	y: 300,
	scaleX: 2.8,
	scaleY: 2.8,
	tint: 0x4A4A4A,
	// Dark gray tint for better contrast
	alpha: 1 // Slight transparency for modern look
}));
// Weapon indicator is now static - no pulsing animation
// Move weapon indicator behind the mask by repositioning it in the children array
var maskIndex = game.children.indexOf(mainScreenMask);
var weaponIndex = game.children.indexOf(weaponIndicator);
var centerUIIndex = game.children.indexOf(centerUIBackground);
if (maskIndex !== -1 && weaponIndex !== -1 && weaponIndex > maskIndex) {
	game.removeChild(weaponIndicator);
	game.addChildAt(weaponIndicator, maskIndex);
}
if (maskIndex !== -1 && centerUIIndex !== -1 && centerUIIndex > maskIndex) {
	game.removeChild(centerUIBackground);
	game.addChildAt(centerUIBackground, maskIndex);
}
// Weapon icon will be created separately on top of Arma-ui
var weaponIcon = null;
// Function to update weapon indicator
function updateWeaponIndicator() {
	// Remove current weapon icon if it exists
	if (weaponIcon) {
		weaponIcon.destroy();
	}
	if (hasIcePower) {
		// Add spinning animation for active power
		var _startIceSpinning = function startIceSpinning() {
			if (!weaponIcon || weaponIcon.destroyed || !hasIcePower) {
				return;
			}
			tween(weaponIcon, {
				rotation: Math.PI * 2
			}, {
				duration: 2000,
				easing: tween.linear,
				onFinish: function onFinish() {
					if (weaponIcon && !weaponIcon.destroyed && hasIcePower) {
						weaponIcon.rotation = 0;
					}
				}
			});
		};
		// Show ice weapon icon - positioned in front of Arma-ui background with enhanced styling
		weaponIcon = game.addChild(LK.getAsset('Ice-horiuken', {
			anchorX: 0.5,
			anchorY: 0.5,
			x: 300,
			y: 300,
			scaleX: 1.1,
			scaleY: 1.1
		}));
		// Enhanced ice blue tint with glow effect
		weaponIcon.tint = 0x00BFFF;
		_startIceSpinning();
	} else if (hasWoodenStarPower) {
		// Add spinning animation for active power
		var _startWoodenStarSpinning = function startWoodenStarSpinning() {
			if (!weaponIcon || weaponIcon.destroyed || !hasWoodenStarPower) {
				return;
			}
			tween(weaponIcon, {
				rotation: Math.PI * 2
			}, {
				duration: 1500,
				easing: tween.linear,
				onFinish: function onFinish() {
					if (weaponIcon && !weaponIcon.destroyed && hasWoodenStarPower) {
						weaponIcon.rotation = 0;
						_startWoodenStarSpinning();
					}
				}
			});
		};
		// Show wooden star icon - positioned in front of Arma-ui background with enhanced styling
		weaponIcon = game.addChild(LK.getAsset('wooden-start', {
			anchorX: 0.5,
			anchorY: 0.5,
			x: 300,
			y: 300,
			scaleX: 1.1,
			scaleY: 1.1
		}));
		// Enhanced brown tint for wooden power
		weaponIcon.tint = 0xDAA520;
		_startWoodenStarSpinning();
	} else {
		// Show normal ninja star icon - positioned in front of Arma-ui background with enhanced styling
		weaponIcon = game.addChild(LK.getAsset('ninjastar', {
			anchorX: 0.5,
			anchorY: 0.5,
			x: 300,
			y: 300,
			scaleX: 1.0,
			scaleY: 1.0
		}));
		// Enhanced silver color for regular ninja star
		weaponIcon.tint = 0xC0C0C0;
	}
	// Ensure weapon icon stays behind the mask if it exists
	if (weaponIcon && mainScreenMask && game.children.indexOf(mainScreenMask) !== -1) {
		var maskIndex = game.children.indexOf(mainScreenMask);
		var iconIndex = game.children.indexOf(weaponIcon);
		if (iconIndex > maskIndex) {
			game.removeChild(weaponIcon);
			game.addChildAt(weaponIcon, maskIndex);
		}
		// Also ensure score and enemies text stay behind mask
		var scoreIndex = game.children.indexOf(scoreTxt);
		var enemiesIndex = game.children.indexOf(enemiesTxt);
		if (scoreIndex > maskIndex) {
			game.removeChild(scoreTxt);
			game.addChildAt(scoreTxt, maskIndex);
		}
		if (enemiesIndex > maskIndex) {
			game.removeChild(enemiesTxt);
			game.addChildAt(enemiesTxt, maskIndex);
		}
	}
}
// Initialize weapon indicator to show default ninja star on game start
updateWeaponIndicator();
// Create score text on the left side of center UI background
var scoreTxt = new Text2('0', {
	size: 76,
	fill: 0xFFD700,
	font: "'Arial Black', 'Impact', 'Helvetica Bold', sans-serif"
});
scoreTxt.anchor.set(1.0, 0.5);
scoreTxt.x = 1024 - 40; // Left side of center UI
scoreTxt.y = 345; // Same Y as center UI background
// Initialize style object if it doesn't exist
if (!scoreTxt.style) {
	scoreTxt.style = {};
}
// Add 3D bold effects with enhanced drop shadow
scoreTxt.style.dropShadow = true;
scoreTxt.style.dropShadowColor = "#000000";
scoreTxt.style.dropShadowDistance = 4;
scoreTxt.style.dropShadowAngle = Math.PI / 4;
// Add bold stroke effect
scoreTxt.style.stroke = "#ffffff";
scoreTxt.style.strokeThickness = 3;
game.addChild(scoreTxt);
// Create enemies text on the right side of center UI background
var enemiesTxt = new Text2('00000', {
	size: 76,
	fill: 0xFFD700,
	font: "'Arial Black', 'Impact', 'Helvetica Bold', sans-serif"
});
enemiesTxt.anchor.set(1.0, 0.5);
enemiesTxt.x = 1024 + 300; // Right side of center UI
enemiesTxt.y = 345; // Same Y as center UI background
// Initialize style object if it doesn't exist
if (!enemiesTxt.style) {
	enemiesTxt.style = {};
}
// Add 3D bold effects with enhanced drop shadow
enemiesTxt.style.dropShadow = true;
enemiesTxt.style.dropShadowColor = "#000000";
enemiesTxt.style.dropShadowDistance = 4;
enemiesTxt.style.dropShadowAngle = Math.PI / 4;
// Add bold stroke effect
enemiesTxt.style.stroke = "#000000";
enemiesTxt.style.strokeThickness = 3;
game.addChild(enemiesTxt);
// Track enemies killed and time survived
var enemiesKilled = 0;
var timeStarted = LK.ticks;
gameStartTime = LK.ticks; // Set game start time for difficulty system
// Update score display
function updateScore() {
	scoreTxt.setText(LK.getScore().toString());
	enemiesTxt.setText(enemiesKilled.toString());
}
// Depth sorting function - objects closer to player should have higher z-index
function sortObjectsByDepth() {
	// Collect all depth-based objects with their z values
	var depthObjects = [];
	// Fog system removed - no fog depth sorting needed
	// Add clouds next (they should be behind trees but in front of fog)
	for (var i = 0; i < clouds.length; i++) {
		if (clouds[i].active && clouds[i].z !== undefined) {
			depthObjects.push({
				obj: clouds[i],
				z: clouds[i].z + 10000,
				// Add large offset to ensure clouds are behind trees but in front of fog
				type: 'cloud'
			});
		}
	}
	// Add trees
	for (var i = 0; i < trees.length; i++) {
		if (trees[i].active && trees[i].z !== undefined) {
			depthObjects.push({
				obj: trees[i],
				z: trees[i].z,
				type: 'tree'
			});
		}
	}
	// Add obstacles
	for (var i = 0; i < obstacles.length; i++) {
		if (obstacles[i].active && obstacles[i].z !== undefined) {
			depthObjects.push({
				obj: obstacles[i],
				z: obstacles[i].z,
				type: 'obstacle'
			});
		}
	}
	// Add toris
	for (var i = 0; i < toris.length; i++) {
		if (toris[i].active && toris[i].z !== undefined) {
			depthObjects.push({
				obj: toris[i],
				z: toris[i].z,
				type: 'tori'
			});
		}
	}
	// Add wooden planks
	for (var i = 0; i < woodenPlanks.length; i++) {
		if (woodenPlanks[i].active && woodenPlanks[i].z !== undefined) {
			depthObjects.push({
				obj: woodenPlanks[i],
				z: woodenPlanks[i].z,
				type: 'plank'
			});
		}
	}
	// Sort by z value - higher z (farther) should be behind (lower index)
	depthObjects.sort(function (a, b) {
		return b.z - a.z;
	});
	// Reorder objects in game children - farther objects go behind
	var baseIndex = greenBackgrounds.length + 2; // After background and sun
	for (var i = 0; i < depthObjects.length; i++) {
		var obj = depthObjects[i].obj;
		var currentIndex = game.children.indexOf(obj);
		var targetIndex = baseIndex + i;
		if (currentIndex !== -1 && currentIndex !== targetIndex && targetIndex < game.children.length) {
			game.removeChild(obj);
			game.addChildAt(obj, Math.min(targetIndex, game.children.length));
		}
	}
}
// Spawn enemy from tree crown
function spawnEnemy() {
	// Check if enough time has passed since last enemy spawn
	if (LK.ticks - lastEnemySpawnTime < minSpawnDelay) {
		return; // Not enough time passed, skip spawning
	}
	// Check for obstacle conflicts - don't spawn if obstacles are nearby
	for (var o = 0; o < obstacles.length; o++) {
		var obstacle = obstacles[o];
		if (obstacle.active && obstacle.z && obstacle.z > 600 && obstacle.z < 1200) {
			return; // There's an obstacle in the spawn zone - don't spawn enemy
		}
	}
	// Find trees that are suitable for enemy spawning
	var suitableTrees = [];
	for (var i = 0; i < trees.length; i++) {
		var tree = trees[i];
		if (tree.active && tree.z < 600 && tree.z > 200) {
			suitableTrees.push(tree);
		}
	}
	if (suitableTrees.length > 0) {
		// Filter out trees from the same side as last spawn
		var availableTrees = [];
		for (var i = 0; i < suitableTrees.length; i++) {
			if (suitableTrees[i].side !== lastEnemySpawnSide) {
				availableTrees.push(suitableTrees[i]);
			}
		}
		// If no trees available from different side, use any available tree
		if (availableTrees.length === 0) {
			availableTrees = suitableTrees;
		}
		// Pick random tree from available trees
		var tree = availableTrees[Math.floor(Math.random() * availableTrees.length)];
		var enemy = new Enemy();
		// Position at tree crown (top of tree)
		enemy.x = tree.x;
		enemy.y = tree.y - tree.scaleY * 500; // Position at tree top based on tree scale
		// Calculate trajectory to land exactly on ninja position
		var jumpStrength = -8; // Much weaker upward jump for slower arc
		var timeToFall = Math.abs(jumpStrength * 2 / 0.15); // Calculate fall time based on gravity
		var horizontalDistance = ninja.x - enemy.x;
		var horizontalSpeed = horizontalDistance / timeToFall; // Speed needed to reach ninja
		enemy.velocityY = jumpStrength;
		enemy.velocityX = horizontalSpeed;
		// Play ninjaJump sound when enemy spawns
		LK.getSound('ninjaJump').play();
		// Mirror enemies coming from left side so sword points toward center
		if (tree.side < 0) {
			// Left side tree - flip the existing graphics
			var enemyGraphics = enemy.children[0];
			enemyGraphics.scaleX = -1; // Flip horizontally
		}
		enemies.push(enemy);
		game.addChild(enemy);
		// Update tracking variables
		lastEnemySpawnSide = tree.side;
		lastEnemySpawnTime = LK.ticks;
	}
}
// Spawn NMI2 enemy from tree crown
function spawnEnemy2() {
	// Check if enough time has passed since last enemy spawn
	if (LK.ticks - lastEnemySpawnTime < minSpawnDelay) {
		return; // Not enough time passed, skip spawning
	}
	// Check for obstacle conflicts - don't spawn if obstacles are nearby
	for (var o = 0; o < obstacles.length; o++) {
		var obstacle = obstacles[o];
		if (obstacle.active && obstacle.z && obstacle.z > 600 && obstacle.z < 1200) {
			return; // There's an obstacle in the spawn zone - don't spawn enemy
		}
	}
	// Find trees that are suitable for enemy spawning
	var suitableTrees = [];
	for (var i = 0; i < trees.length; i++) {
		var tree = trees[i];
		if (tree.active && tree.z < 600 && tree.z > 200) {
			suitableTrees.push(tree);
		}
	}
	if (suitableTrees.length > 0) {
		// Filter out trees from the same side as last spawn
		var availableTrees = [];
		for (var i = 0; i < suitableTrees.length; i++) {
			if (suitableTrees[i].side !== lastEnemySpawnSide) {
				availableTrees.push(suitableTrees[i]);
			}
		}
		// If no trees available from different side, use any available tree
		if (availableTrees.length === 0) {
			availableTrees = suitableTrees;
		}
		// Pick random tree from available trees
		var tree = availableTrees[Math.floor(Math.random() * availableTrees.length)];
		var enemy2 = new Enemy2();
		// Position at tree crown (top of tree)
		enemy2.x = tree.x;
		enemy2.y = tree.y - tree.scaleY * 500; // Position at tree top based on tree scale
		// Calculate trajectory to land exactly on ninja position
		var jumpStrength = -8; // Much weaker upward jump for slower arc
		var timeToFall = Math.abs(jumpStrength * 2 / 0.15); // Calculate fall time based on gravity
		var horizontalDistance = ninja.x - enemy2.x;
		var horizontalSpeed = horizontalDistance / timeToFall; // Speed needed to reach ninja
		enemy2.velocityY = jumpStrength;
		enemy2.velocityX = horizontalSpeed;
		// Play ninjaJump sound when enemy spawns
		LK.getSound('ninjaJump').play();
		// Mirror enemies coming from left side so sword points toward center
		if (tree.side < 0) {
			// Left side tree - flip the existing graphics
			var enemyGraphics = enemy2.children[0];
			enemyGraphics.scaleX = -1; // Flip horizontally
		}
		enemies2.push(enemy2);
		game.addChild(enemy2);
		// Update tracking variables
		lastEnemySpawnSide = tree.side;
		lastEnemySpawnTime = LK.ticks;
	}
}
// Spawn enemy archer on tree crown
function spawnEnemyArcher() {
	// Find trees that are suitable for archer spawning (spawn much earlier when far away)
	var suitableTrees = [];
	for (var i = 0; i < trees.length; i++) {
		var tree = trees[i];
		if (tree.active && tree.z < 1200 && tree.z > 400) {
			// Check if tree doesn't already have an archer
			var hasArcher = false;
			for (var a = 0; a < enemyArchers.length; a++) {
				if (enemyArchers[a].active && enemyArchers[a].tree === tree) {
					hasArcher = true;
					break;
				}
			}
			if (!hasArcher) {
				suitableTrees.push(tree);
			}
		}
	}
	if (suitableTrees.length > 0) {
		// Pick random tree from suitable trees
		var tree = suitableTrees[Math.floor(Math.random() * suitableTrees.length)];
		var archer = new EnemyArcher();
		archer.tree = tree; // Assign tree reference
		archer.x = tree.x;
		archer.y = tree.y - tree.scaleY * 300;
		// Flip archer graphics based on tree side
		if (tree.side < 0) {
			// Left side tree - flip archer
			var archerGraphics = archer.children[0];
			archerGraphics.scaleX = -1;
		}
		enemyArchers.push(archer);
		game.addChild(archer);
		// Play spawn sound for ninja archer
		LK.getSound('Arcer-apears').play();
	}
}
// Spawn Enemy3 from tree crown
function spawnEnemy3() {
	// Check if enough time has passed since last enemy spawn
	if (LK.ticks - lastEnemySpawnTime < minSpawnDelay) {
		return; // Not enough time passed, skip spawning
	}
	// Check for obstacle conflicts - don't spawn if obstacles are nearby
	for (var o = 0; o < obstacles.length; o++) {
		var obstacle = obstacles[o];
		if (obstacle.active && obstacle.z && obstacle.z > 600 && obstacle.z < 1200) {
			return; // There's an obstacle in the spawn zone - don't spawn enemy
		}
	}
	// Find trees that are suitable for enemy spawning
	var suitableTrees = [];
	for (var i = 0; i < trees.length; i++) {
		var tree = trees[i];
		if (tree.active && tree.z < 600 && tree.z > 200) {
			suitableTrees.push(tree);
		}
	}
	if (suitableTrees.length > 0) {
		// Filter out trees from the same side as last spawn
		var availableTrees = [];
		for (var i = 0; i < suitableTrees.length; i++) {
			if (suitableTrees[i].side !== lastEnemySpawnSide) {
				availableTrees.push(suitableTrees[i]);
			}
		}
		// If no trees available from different side, use any available tree
		if (availableTrees.length === 0) {
			availableTrees = suitableTrees;
		}
		// Pick random tree from available trees
		var tree = availableTrees[Math.floor(Math.random() * availableTrees.length)];
		var enemy3 = new Enemy3();
		// Position at tree crown (top of tree)
		enemy3.x = tree.x;
		enemy3.y = tree.y - tree.scaleY * 500; // Position at tree top based on tree scale
		// Calculate trajectory to land exactly on ninja position
		var jumpStrength = -8; // Much weaker upward jump for slower arc
		var timeToFall = Math.abs(jumpStrength * 2 / 0.15); // Calculate fall time based on gravity
		var horizontalDistance = ninja.x - enemy3.x;
		var horizontalSpeed = horizontalDistance / timeToFall; // Speed needed to reach ninja
		enemy3.velocityY = jumpStrength;
		enemy3.velocityX = horizontalSpeed;
		// Play ninjaJump sound when enemy spawns
		LK.getSound('ninjaJump').play();
		// Mirror enemies coming from left side so sword points toward center
		if (tree.side < 0) {
			// Left side tree - flip the existing graphics
			var enemyGraphics = enemy3.children[0];
			enemyGraphics.scaleX = -1; // Flip horizontally
		}
		enemies3.push(enemy3);
		game.addChild(enemy3);
		// Update tracking variables
		lastEnemySpawnSide = tree.side;
		lastEnemySpawnTime = LK.ticks;
	}
}
// Spawn obstacle
function spawnObstacle() {
	// Check if there are any toris that would conflict with obstacle spawning
	var canSpawnObstacle = true;
	var minSeparationDistance = 300; // Minimum distance between obstacles and toris
	for (var t = 0; t < toris.length; t++) {
		var tori = toris[t];
		if (tori.active && tori.z && tori.z > 600 && tori.z < 1400) {
			// There's a tori in the spawn zone - don't spawn obstacle
			canSpawnObstacle = false;
			break;
		}
	}
	// Also check existing obstacles to ensure proper spacing
	for (var o = 0; o < obstacles.length; o++) {
		var existingObstacle = obstacles[o];
		if (existingObstacle.active && existingObstacle.z && Math.abs(existingObstacle.z - 1000) < minSeparationDistance) {
			// There's another obstacle too close - don't spawn
			canSpawnObstacle = false;
			break;
		}
	}
	if (!canSpawnObstacle) {
		return; // Skip obstacle spawning to avoid collision with tori or other obstacles
	}
	var obstacleType = Math.random();
	var obstacle;
	if (obstacleType < 0.25) {
		obstacle = new Obstacle();
	} else if (obstacleType < 0.5) {
		obstacle = new RockObstacle();
	} else if (obstacleType < 0.75) {
		obstacle = new SpikeObstacle();
	} else {
		obstacle = new RockObstacle();
	}
	obstacle.x = 1024; // Start from center of horizon for perspective
	obstacle.y = horizonY; // Start at horizon
	obstacle.z = 1000; // Start far away
	obstacle.baseX = 1024; // Center starting position
	obstacle.side = 0; // Keep in center for jumping
	obstacles.push(obstacle);
	game.addChild(obstacle);
	// Show alert above ninja head for jump-required obstacle
	showAlert();
}
// Fog spawn function removed - no fog elements in game
// Spawn cloud in sky
function spawnCloud() {
	var cloudType = Math.random();
	var cloud;
	// Adjust cloud type probabilities based on difficulty
	if (!isFeatureUnlocked('lightningClouds')) {
		// Early game: only regular clouds
		if (cloudType < 0.7) {
			cloud = new Cloud();
		} else {
			cloud = new CloudType3();
		}
	} else {
		// Normal distribution with lightning clouds enabled
		if (cloudType < 0.25) {
			cloud = new Cloud();
		} else if (cloudType < 0.75) {
			cloud = new electroCloud();
		} else {
			cloud = new CloudType3();
		}
	}
	cloud.x = Math.random() * 1200 + 400; // Random x position
	cloud.y = horizonY - 400; // Start much higher in the sky
	cloud.baseY = cloud.y; // Store original y for perspective calculation
	cloud.z = 2000; // Start very far away
	clouds.push(cloud);
	// Add clouds in front of sun - find sun's position and add cloud after it
	var sunIndex = game.children.indexOf(sun);
	var cloudIndex = Math.min(sunIndex + 1, game.children.length);
	game.addChildAt(cloud, cloudIndex);
}
// Spawn tori
function spawnTori() {
	// Check if there are any obstacles that would conflict with tori spawning
	var canSpawnTori = true;
	var minSeparationDistance = 300; // Minimum distance between toris and obstacles
	for (var o = 0; o < obstacles.length; o++) {
		var obstacle = obstacles[o];
		if (obstacle.active && obstacle.z && obstacle.z > 600 && obstacle.z < 1400) {
			// There's an obstacle in the spawn zone - don't spawn tori
			canSpawnTori = false;
			break;
		}
	}
	// Also check existing toris to ensure proper spacing
	for (var t = 0; t < toris.length; t++) {
		var existingTori = toris[t];
		if (existingTori.active && existingTori.z && Math.abs(existingTori.z - 1000) < minSeparationDistance) {
			// There's another tori too close - don't spawn
			canSpawnTori = false;
			break;
		}
	}
	if (!canSpawnTori) {
		return; // Skip tori spawning to avoid collision with obstacle or other toris
	}
	var tori = new Tori();
	tori.x = 1024; // Start from center of horizon for perspective
	tori.y = horizonY; // Start at horizon
	tori.z = 1000; // Start far away
	tori.baseX = 1024; // Center starting position
	// No side spreading - tori stays in center
	toris.push(tori);
	game.addChild(tori);
}
// Spawn trees on both sides of the path
function spawnTrees() {
	// Remove tree limit to allow unlimited trees
	// Left side tree - starts from center horizon
	var leftTreeType = Math.random();
	var leftTree;
	if (leftTreeType < 0.33) {
		leftTree = new Tree();
	} else if (leftTreeType < 0.66) {
		leftTree = new TreeType2();
	} else {
		leftTree = new TreeType3();
	}
	leftTree.x = 1024; // Start from center of horizon
	leftTree.y = horizonY; // Start at horizon
	leftTree.z = 1000; // Start far away
	leftTree.side = -1; // Will spread to the left
	leftTree.speed = 3; // Match speed with obstacles and other objects
	trees.push(leftTree);
	// New trees (higher z distance) should have lower z-index (appear behind farther trees)
	var insertIndex = greenBackgrounds.length + 2;
	if (insertIndex > game.children.length) {
		insertIndex = game.children.length;
	}
	game.addChildAt(leftTree, insertIndex);
	// No limit check - spawn right tree always
	// Right side tree - starts from center horizon
	var rightTreeType = Math.random();
	var rightTree;
	if (rightTreeType < 0.33) {
		rightTree = new Tree();
	} else if (rightTreeType < 0.66) {
		rightTree = new TreeType2();
	} else {
		rightTree = new TreeType3();
	}
	rightTree.x = 1024; // Start from center of horizon
	rightTree.y = horizonY; // Start at horizon
	rightTree.z = 1000; // Start far away
	rightTree.side = 1; // Will spread to the right
	rightTree.speed = 3; // Match speed with obstacles and other objects
	trees.push(rightTree);
	// New trees (higher z distance) should have lower z-index (appear behind farther trees)
	var rightInsertIndex = greenBackgrounds.length + 2;
	if (rightInsertIndex > game.children.length) {
		rightInsertIndex = game.children.length;
	}
	game.addChildAt(rightTree, rightInsertIndex);
	// Spawn additional trees for density - spawn 2 more pairs
	for (var extraPair = 0; extraPair < 2; extraPair++) {
		// Extra left tree with slight offset
		var extraLeftTreeType = Math.random();
		var extraLeftTree;
		if (extraLeftTreeType < 0.33) {
			extraLeftTree = new Tree();
		} else if (extraLeftTreeType < 0.66) {
			extraLeftTree = new TreeType2();
		} else {
			extraLeftTree = new TreeType3();
		}
		extraLeftTree.x = 1024;
		extraLeftTree.y = horizonY;
		extraLeftTree.z = 1100 + extraPair * 200; // Spawn at different distances
		extraLeftTree.side = -1;
		extraLeftTree.speed = 3;
		trees.push(extraLeftTree);
		var extraLeftInsertIndex = greenBackgrounds.length + 2;
		if (extraLeftInsertIndex > game.children.length) {
			extraLeftInsertIndex = game.children.length;
		}
		game.addChildAt(extraLeftTree, extraLeftInsertIndex);
		// Extra right tree with slight offset
		var extraRightTreeType = Math.random();
		var extraRightTree;
		if (extraRightTreeType < 0.33) {
			extraRightTree = new Tree();
		} else if (extraRightTreeType < 0.66) {
			extraRightTree = new TreeType2();
		} else {
			extraRightTree = new TreeType3();
		}
		extraRightTree.x = 1024;
		extraRightTree.y = horizonY;
		extraRightTree.z = 1150 + extraPair * 200; // Spawn at different distances
		extraRightTree.side = 1;
		extraRightTree.speed = 3;
		trees.push(extraRightTree);
		var extraRightInsertIndex = greenBackgrounds.length + 2;
		if (extraRightInsertIndex > game.children.length) {
			extraRightInsertIndex = game.children.length;
		}
		game.addChildAt(extraRightTree, extraRightInsertIndex);
	}
}
// Spawn airplane
function spawnAirplane() {
	var airplane = new Airplane();
	// Only spawn from left to right
	airplane.x = -200; // Start from left
	airplane.direction = 1; // Move right
	airplane.y = airplane.altitude;
	// Play airplane sound when spawning
	LK.getSound('Avion').play();
	airplanes.push(airplane);
	game.addChild(airplane);
}
// Drop power-up from airplane
function dropPowerUp(airplane) {
	var powerUp = new PowerUp();
	powerUp.x = airplane.x;
	powerUp.y = airplane.y + 50; // Drop slightly below airplane
	// Random power-up type (1-2)
	var powerUpType = Math.floor(Math.random() * 2) + 1;
	powerUp.setPowerUpType(powerUpType);
	powerUps.push(powerUp);
	game.addChild(powerUp);
}
// Spawn wooden planks for walkway effect
function spawnWoodenPlanks() {
	// Create multiple planks in a row to simulate wooden walkway
	for (var plankIndex = -4; plankIndex <= 4; plankIndex++) {
		var plank = new WoodenPlank();
		plank.x = 1024; // Start from center of horizon
		plank.y = 1503; // Start at horizon
		// Maintain regular distance between planks
		var currentPlankY = lastPlankSpawnY + plankRegularDistance + plankIndex * plankRegularDistance;
		plank.z = 1000 + plankIndex * plankRegularDistance; // Regular depth spacing instead of random
		plank.baseX = 1024;
		// No horizontal offset needed - planks stay centered
		plank.speed = 3; // Match speed with other objects
		woodenPlanks.push(plank);
		// Insert planks on the ground level, above green background but below other objects
		var plankInsertIndex = greenBackgrounds.length + 1;
		if (plankInsertIndex > game.children.length) {
			plankInsertIndex = game.children.length;
		}
		game.addChildAt(plank, plankInsertIndex);
	}
	// Update last spawn Y position for next batch
	lastPlankSpawnY = lastPlankSpawnY + 9 * 50; // 9 planks spawned in total (-4 to +4) with 50px spacing
}
// Enemy spawning is now handled by spawnEnemy function directly from tree crowns
// Throw ninja star
function throwNinjaStar(targetX, targetY) {
	// Check if ice power is active
	if (hasIcePower) {
		// Throw ice star
		var iceStar = new IceStar();
		iceStar.x = ninja.x;
		iceStar.y = ninja.y - 250; // Position above ninja head
		// Calculate direction
		var dx = targetX - iceStar.x;
		var dy = targetY - iceStar.y;
		var distance = Math.sqrt(dx * dx + dy * dy);
		// Normalize and set velocity
		iceStar.velocityX = dx / distance * iceStar.speed;
		iceStar.velocityY = dy / distance * iceStar.speed;
		iceStars.push(iceStar);
		// Add ice star after ninja in display list so it appears in front
		var ninjaIndex = game.children.indexOf(ninja);
		if (ninjaIndex !== -1) {
			game.addChildAt(iceStar, ninjaIndex + 1);
		} else {
			game.addChild(iceStar);
		}
		LK.getSound('ice-throw').play();
	} else if (hasWoodenStarPower) {
		// Throw three wooden stars in a spread pattern
		for (var starIndex = 0; starIndex < 3; starIndex++) {
			var woodenStar = new WoodenStar();
			woodenStar.x = ninja.x;
			woodenStar.y = ninja.y - 250; // Position above ninja head
			// Calculate base direction
			var dx = targetX - woodenStar.x;
			var dy = targetY - woodenStar.y;
			var distance = Math.sqrt(dx * dx + dy * dy);
			// Limit target Y to horizon level (no higher than horizonY)
			var limitedTargetY = Math.max(targetY, horizonY);
			var limitedDy = limitedTargetY - woodenStar.y;
			// Add spread angle: -15, 0, +15 degrees
			var spreadAngle = (starIndex - 1) * (Math.PI / 12); // 15 degrees in radians
			var baseAngle = Math.atan2(limitedDy, dx);
			var finalAngle = baseAngle + spreadAngle;
			// Set velocity with spread
			woodenStar.velocityX = Math.cos(finalAngle) * woodenStar.speed;
			woodenStar.velocityY = Math.sin(finalAngle) * woodenStar.speed;
			woodenStars.push(woodenStar);
			// Add wooden star after ninja in display list so it appears in front
			var ninjaIndex = game.children.indexOf(ninja);
			if (ninjaIndex !== -1) {
				game.addChildAt(woodenStar, ninjaIndex + 1);
			} else {
				game.addChild(woodenStar);
			}
		}
		LK.getSound('throw').play();
	} else {
		// Normal ninja star throwing
		var star = new NinjaStar();
		star.x = ninja.x;
		star.y = ninja.y - 250; // Position above ninja head instead of below
		// Calculate direction
		var dx = targetX - star.x;
		var dy = targetY - star.y;
		var distance = Math.sqrt(dx * dx + dy * dy);
		// Normalize and set velocity
		star.velocityX = dx / distance * star.speed;
		star.velocityY = dy / distance * star.speed;
		ninjaStars.push(star);
		// Add ninja star after ninja in display list so it appears in front
		var ninjaIndex = game.children.indexOf(ninja);
		if (ninjaIndex !== -1) {
			game.addChildAt(star, ninjaIndex + 1);
		} else {
			game.addChild(star);
		}
		LK.getSound('throw').play();
	}
}
// Handle input
game.down = function (x, y, obj) {
	// Check if main screen is active and minimum time has passed
	if (mainScreenActive && mainScreenTimer >= mainScreenMinTime) {
		// Start swipe detection
		swipeStartXPopup = x;
		swipeStartYPopup = y;
		isSwipingPopup = true;
		game.lastDownTick = LK.ticks; // Track timing for swipe speed
		return; // Don't dismiss popup yet, wait for swipe completion
	}
	// Skip normal input if main screen is still active
	if (mainScreenActive) {
		return;
	}
	swipeStartX = x;
	swipeStartY = y;
	isSwipeActive = true;
};
game.up = function (x, y, obj) {
	// Handle swipe on main screen popup
	if (mainScreenActive && isSwipingPopup && mainScreenTimer >= mainScreenMinTime) {
		var swipeDistance = Math.sqrt(Math.pow(x - swipeStartXPopup, 2) + Math.pow(y - swipeStartYPopup, 2));
		var swipeSpeed = swipeDistance / Math.max(1, LK.ticks - (game.lastDownTick || LK.ticks));
		// Check if swipe is long and fast enough (minimum 150px distance and sufficient speed)
		if (swipeDistance > 150 && swipeSpeed > 2) {
			// Calculate swipe angle and cut line
			var swipeAngle = Math.atan2(y - swipeStartYPopup, x - swipeStartXPopup);
			// Create cut effect - split popup into two pieces
			var cutY = swipeStartYPopup + (y - swipeStartYPopup) * 0.5; // Cut line at middle of swipe
			// Create top piece (above cut line)
			var topPiece = game.addChild(LK.getAsset('Mainscreen', {
				anchorX: 0.5,
				anchorY: 0.5,
				x: mainScreenPopup.x,
				y: mainScreenPopup.y - 100,
				// Offset up from cut line
				scaleX: mainScreenPopup.scaleX,
				scaleY: mainScreenPopup.scaleY * 0.5 // Half height
			}));
			// Create bottom piece (below cut line)
			var bottomPiece = game.addChild(LK.getAsset('Mainscreen', {
				anchorX: 0.5,
				anchorY: 0.5,
				x: mainScreenPopup.x,
				y: mainScreenPopup.y + 100,
				// Offset down from cut line
				scaleX: mainScreenPopup.scaleX,
				scaleY: mainScreenPopup.scaleY * 0.5 // Half height
			}));
			// Hide original popup
			mainScreenPopup.alpha = 0;
			// Calculate separation velocities based on swipe direction
			var separationSpeed = 8;
			var perpAngle = swipeAngle + Math.PI / 2; // Perpendicular to swipe direction
			// Animate top piece flying away
			tween(topPiece, {
				x: topPiece.x + Math.cos(perpAngle) * 300,
				y: topPiece.y + Math.sin(perpAngle) * 300,
				rotation: Math.random() * Math.PI - Math.PI / 2,
				// Random rotation
				scaleX: 0,
				scaleY: 0,
				alpha: 0
			}, {
				duration: 800,
				easing: tween.easeOut,
				onFinish: function onFinish() {
					topPiece.destroy();
				}
			});
			// Animate bottom piece flying away (opposite direction)
			tween(bottomPiece, {
				x: bottomPiece.x - Math.cos(perpAngle) * 300,
				y: bottomPiece.y - Math.sin(perpAngle) * 300,
				rotation: Math.random() * Math.PI - Math.PI / 2,
				// Random rotation
				scaleX: 0,
				scaleY: 0,
				alpha: 0
			}, {
				duration: 800,
				easing: tween.easeOut,
				onFinish: function onFinish() {
					bottomPiece.destroy();
				}
			});
			// Play slash sound effect
			LK.getSound('throw').play();
			// Animate mask exit
			tween(mainScreenMask, {
				alpha: 0
			}, {
				duration: 500,
				easing: tween.easeIn,
				onFinish: function onFinish() {
					mainScreenMask.destroy();
				}
			});
			// Clean up original popup after animation starts
			LK.setTimeout(function () {
				if (mainScreenPopup) {
					mainScreenPopup.destroy();
				}
			}, 100);
			// Dismiss main screen
			mainScreenActive = false;
			isSwipingPopup = false;
			return;
		} else {
			// Swipe not strong enough - do simple dismiss
			mainScreenActive = false;
			// Animate mask exit
			tween(mainScreenMask, {
				alpha: 0
			}, {
				duration: 300,
				easing: tween.easeIn,
				onFinish: function onFinish() {
					mainScreenMask.destroy();
				}
			});
			// Animate popup exit
			tween(mainScreenPopup, {
				scaleX: 0,
				scaleY: 0,
				alpha: 0
			}, {
				duration: 300,
				easing: tween.easeIn,
				onFinish: function onFinish() {
					mainScreenPopup.destroy();
				}
			});
		}
		isSwipingPopup = false;
		return;
	}
	if (isSwipeActive && !ninjaParalyzed) {
		var swipeDistance = Math.sqrt(Math.pow(x - swipeStartX, 2) + Math.pow(y - swipeStartY, 2));
		if (swipeDistance > 100) {
			// Swipe - throw ninja star
			throwNinjaStar(x, y);
		} else {
			// Tap - jump
			ninja.jump();
		}
		isSwipeActive = false;
	}
};
// Main game loop
game.update = function () {
	// If game is paused (ninja hit), only play audio and wait
	if (game.paused) {
		return;
	}
	// Handle main screen timing
	if (mainScreenActive) {
		mainScreenTimer++;
		// Update ninja but skip other game elements
		ninja.update();
		// Update score display to show that game is preparing
		updateScore();
		// Continue updating background elements during main screen
		// Update trees
		for (var i = trees.length - 1; i >= 0; i--) {
			var tree = trees[i];
			tree.update();
			if (!tree.active) {
				tree.destroy();
				trees.splice(i, 1);
			}
		}
		// Update wooden planks
		for (var i = woodenPlanks.length - 1; i >= 0; i--) {
			var plank = woodenPlanks[i];
			plank.update();
			if (!plank.active) {
				plank.destroy();
				woodenPlanks.splice(i, 1);
			}
		}
		// Fog system removed - no fog updates needed during main screen
		// Spawn trees during main screen to keep background active
		treeSpawnTimer++;
		if (treeSpawnTimer > 90) {
			// Spawn trees much more frequently - 1.5 seconds interval for many more trees
			spawnTrees();
			treeSpawnTimer = 0;
		}
		// Spawn wooden planks during main screen with more spacing for walkway effect
		if (LK.ticks % 25 === 0) {
			// Spawn wooden planks every 25 frames (0.42 seconds) for spaced walkway effect
			spawnWoodenPlanks();
		}
		// Fog spawning removed - cleaner atmosphere without fog
		// Sort objects by depth during main screen for proper layering
		if (LK.ticks % 10 === 0) {
			sortObjectsByDepth();
		}
		// Skip all other updates while main screen is active
		return;
	}
	// Update ninja
	ninja.update();
	// Update wooden star power timer
	if (hasWoodenStarPower && woodenStarPowerTimer > 0) {
		woodenStarPowerTimer--;
		if (woodenStarPowerTimer <= 0) {
			hasWoodenStarPower = false;
			updateWeaponIndicator(); // Update weapon indicator when power ends
		}
	}
	// Update ice power timer
	if (hasIcePower && icePowerTimer > 0) {
		icePowerTimer--;
		if (icePowerTimer <= 0) {
			hasIcePower = false;
			updateWeaponIndicator(); // Update weapon indicator when power ends
		}
	}
	// Update ice stars
	var _loop3 = function _loop3() {
			iceStar = iceStars[i];
			iceStar.update();
			if (!iceStar.active) {
				iceStar.destroy();
				iceStars.splice(i, 1);
				return 0; // continue
			}
			// Ice stars have similar collision detection as wooden stars but with freezing effect
			// Check collision with meteorites
			for (m = meteorites.length - 1; m >= 0; m--) {
				meteorite = meteorites[m];
				if (meteorite.active && iceStar.intersects(meteorite)) {
					meteorite.hitCount++;
					LK.getSound('meteoro-golpe').play();
					if (meteorite.hitCount < 3) {
						meteorite.changeFace();
					}
					iceStar.active = false;
					iceStar.destroy();
					iceStars.splice(i, 1);
					if (meteorite.hitCount >= 3) {
						meteorite.active = false;
						meteorite.destroy();
						meteorites.splice(m, 1);
						LK.getSound('meteoro-grito').play(); // Play cat scream sound when meteorite is destroyed
						LK.setScore(LK.getScore() + 50);
						updateScore();
					}
					break;
				}
			}
			// Check collision with all enemy types
			for (j = enemies.length - 1; j >= 0; j--) {
				enemy = enemies[j];
				if (enemy.active && iceStar.intersects(enemy)) {
					enemiesKilled++;
					LK.setScore(LK.getScore() + 10);
					updateScore();
					LK.getSound('Congelado').play();
					// Mark enemy as hit and start falling upside down
					enemy.falling = true;
					enemy.frozen = true; // Mark enemy as frozen
					var enemyGraphics = enemy.children[0];
					// Preserve current scale and position
					var currentScaleX = enemyGraphics.scaleX;
					var currentScaleY = enemyGraphics.scaleY;
					var currentRotation = enemyGraphics.rotation;
					// Destroy current graphics
					enemyGraphics.destroy();
					// Add frozen enemy graphics
					var frozenGraphics = enemy.attachAsset('freeze-enemy', {
						anchorX: 0.5,
						anchorY: 0.5
					});
					// Restore visual properties and rotate upside down
					frozenGraphics.scaleX = currentScaleX;
					frozenGraphics.scaleY = currentScaleY;
					// Rotate enemy upside down and make them fall
					tween(frozenGraphics, {
						rotation: Math.PI,
						tint: 0x87CEEB
					}, {
						duration: 300,
						easing: tween.easeOut
					});
					// Set falling velocity
					enemy.velocityY = -2; // Small upward velocity initially
					enemy.velocityX = enemy.velocityX * 0.3; // Reduce horizontal speed
					iceStar.active = false;
					iceStar.destroy();
					iceStars.splice(i, 1);
					break;
				}
			}
			for (j = enemies2.length - 1; j >= 0; j--) {
				enemy2 = enemies2[j];
				if (enemy2.active && iceStar.intersects(enemy2)) {
					enemiesKilled++;
					LK.setScore(LK.getScore() + 15);
					updateScore();
					LK.getSound('Congelado').play();
					// Mark enemy2 as hit and start falling upside down
					enemy2.falling = true;
					enemy2.frozen = true; // Mark enemy2 as frozen
					var enemy2Graphics = enemy2.children[0];
					// Preserve current scale and position
					var currentScaleX = enemy2Graphics.scaleX;
					var currentScaleY = enemy2Graphics.scaleY;
					var currentRotation = enemy2Graphics.rotation;
					// Destroy current graphics
					enemy2Graphics.destroy();
					// Add frozen enemy2 graphics
					var frozenGraphics = enemy2.attachAsset('freeze-enemy2', {
						anchorX: 0.5,
						anchorY: 0.5
					});
					// Restore visual properties and rotate upside down
					frozenGraphics.scaleX = currentScaleX;
					frozenGraphics.scaleY = currentScaleY;
					// Rotate enemy upside down and make them fall
					tween(frozenGraphics, {
						rotation: Math.PI,
						tint: 0x87CEEB
					}, {
						duration: 300,
						easing: tween.easeOut
					});
					// Set falling velocity
					enemy2.velocityY = -2; // Small upward velocity initially
					enemy2.velocityX = enemy2.velocityX * 0.3; // Reduce horizontal speed
					iceStar.active = false;
					iceStar.destroy();
					iceStars.splice(i, 1);
					break;
				}
			}
			for (j = enemies3.length - 1; j >= 0; j--) {
				enemy3 = enemies3[j];
				if (enemy3.active && iceStar.intersects(enemy3)) {
					enemiesKilled++;
					LK.setScore(LK.getScore() + 20);
					updateScore();
					LK.getSound('Congelado').play();
					// Mark enemy3 as hit and start falling upside down
					enemy3.falling = true;
					enemy3.frozen = true; // Mark enemy3 as frozen
					var enemy3Graphics = enemy3.children[0];
					// Preserve current scale and position
					var currentScaleX = enemy3Graphics.scaleX;
					var currentScaleY = enemy3Graphics.scaleY;
					var currentRotation = enemy3Graphics.rotation;
					// Destroy current graphics
					enemy3Graphics.destroy();
					// Add frozen enemy3 graphics
					var frozenGraphics = enemy3.attachAsset('freeze-enemy3', {
						anchorX: 0.5,
						anchorY: 0.5
					});
					// Restore visual properties and rotate upside down
					frozenGraphics.scaleX = currentScaleX;
					frozenGraphics.scaleY = currentScaleY;
					// Rotate enemy upside down and make them fall
					tween(frozenGraphics, {
						rotation: Math.PI,
						tint: 0x87CEEB
					}, {
						duration: 300,
						easing: tween.easeOut
					});
					// Set falling velocity
					enemy3.velocityY = -2; // Small upward velocity initially
					enemy3.velocityX = enemy3.velocityX * 0.3; // Reduce horizontal speed
					iceStar.active = false;
					iceStar.destroy();
					iceStars.splice(i, 1);
					break;
				}
			}
			for (j = enemyArchers.length - 1; j >= 0; j--) {
				archer = enemyArchers[j];
				if (archer.active && iceStar.intersects(archer)) {
					enemiesKilled++;
					LK.setScore(LK.getScore() + 25);
					updateScore();
					LK.getSound('Congelado').play();
					// Mark archer as hit and start falling upside down
					archer.falling = true;
					archer.frozen = true; // Mark archer as frozen
					var archerGraphics = archer.children[0];
					// Preserve current scale and position
					var currentScaleX = archerGraphics.scaleX;
					var currentScaleY = archerGraphics.scaleY;
					var currentRotation = archerGraphics.rotation;
					// Destroy current graphics
					archerGraphics.destroy();
					// Add frozen archer graphics
					var frozenGraphics = archer.attachAsset('freeze-archer-ninja', {
						anchorX: 0.5,
						anchorY: 1.0
					});
					// Restore visual properties and rotate upside down
					frozenGraphics.scaleX = currentScaleX;
					frozenGraphics.scaleY = currentScaleY;
					// Rotate archer upside down and make them fall
					tween(frozenGraphics, {
						rotation: Math.PI,
						tint: 0x87CEEB
					}, {
						duration: 300,
						easing: tween.easeOut
					});
					// Set falling velocity
					archer.velocityY = -2; // Small upward velocity initially
					archer.velocityX = 0; // Stop horizontal movement for archers
					iceStar.active = false;
					iceStar.destroy();
					iceStars.splice(i, 1);
					break;
				}
			}
			for (a = arrows.length - 1; a >= 0; a--) {
				arrow = arrows[a];
				if (arrow.active && !arrow.falling && iceStar.intersects(arrow)) {
					arrow.startFalling();
					iceStar.active = false;
					iceStar.destroy();
					iceStars.splice(i, 1);
					break;
				}
			}
			// Check collision with airplanes
			for (var ap = airplanes.length - 1; ap >= 0; ap--) {
				var airplane = airplanes[ap];
				if (airplane.active && iceStar.intersects(airplane)) {
					LK.setScore(LK.getScore() + 30);
					updateScore();
					// Make airplane fall in nosedive and play crash sound
					airplane.startFalling();
					iceStar.active = false;
					iceStar.destroy();
					iceStars.splice(i, 1);
					break;
				}
			}
			// Check collision with obstacles
			for (var o = obstacles.length - 1; o >= 0; o--) {
				var obstacle = obstacles[o];
				if (obstacle.active && iceStar.intersects(obstacle)) {
					// Remove ice star
					iceStar.active = false;
					iceStar.destroy();
					iceStars.splice(i, 1);
					break;
				}
			}
			// Check collision with CloudType2 (electric clouds) to disable them
			for (var cl = clouds.length - 1; cl >= 0; cl--) {
				var cloud = clouds[cl];
				if (cloud.active && cloud.constructor === electroCloud && iceStar.intersects(cloud)) {
					// Play electric cloud hit sound
					LK.getSound('electric-cloud-hit').play();
					// Change cloud to freeze cloud asset (disable electric properties)
					var cloudGraphics = cloud.children[0];
					var originalScale = {
						x: cloudGraphics.scaleX,
						y: cloudGraphics.scaleY
					};
					var originalAlpha = cloudGraphics.alpha;
					// Destroy electric cloud graphics
					cloudGraphics.destroy();
					// Replace with freeze cloud graphics
					var newCloudGraphics = cloud.attachAsset('nube-frezze', {
						anchorX: 0.5,
						anchorY: 0.5,
						scaleX: originalScale.x,
						scaleY: originalScale.y
					});
					// Maintain visual properties
					newCloudGraphics.alpha = originalAlpha;
					// Stop any flickering effects by removing the constructor reference
					// This prevents the cloud from creating lightning
					cloud.constructor = Cloud;
					// Remove ice star
					iceStar.active = false;
					iceStar.destroy();
					iceStars.splice(i, 1);
					break;
				}
			}
			// Check collision with sun to freeze it
			if (iceStar.intersects(sun)) {
				// Add strong initial trembling effect
				var createStrongTrembling = function createStrongTrembling() {
					var trembleIntensity = 20; // Strong initial shake
					var trembleDuration = 150; // Quick shakes
					// Create strong X trembling
					tween(sun, {
						x: sun.x + trembleIntensity
					}, {
						duration: trembleDuration,
						easing: tween.easeInOut,
						onFinish: function onFinish() {
							tween(sun, {
								x: sun.x - trembleIntensity * 2
							}, {
								duration: trembleDuration,
								easing: tween.easeInOut,
								onFinish: function onFinish() {
									tween(sun, {
										x: 1700 // Return to center
									}, {
										duration: trembleDuration,
										easing: tween.easeInOut,
										onFinish: function onFinish() {
											// After strong trembling, start gentle continuous trembling
											_createGentleTrembling();
										}
									});
								}
							});
						}
					});
				}; // Add gentle continuous trembling effect
				var _createGentleTrembling = function createGentleTrembling() {
					if (!sunFrozen) {
						return;
					} // Stop if sun is no longer frozen
					var gentleIntensity = 3; // Much smaller shake
					var gentleDuration = 200; // Slower rhythm
					// Random direction for natural movement
					var offsetX = (Math.random() - 0.5) * gentleIntensity * 2;
					var offsetY = (Math.random() - 0.5) * gentleIntensity * 2;
					tween(sun, {
						x: 1700 + offsetX,
						y: 300 + offsetY
					}, {
						duration: gentleDuration,
						easing: tween.easeInOut,
						onFinish: function onFinish() {
							// Continue gentle trembling
							_createGentleTrembling();
						}
					});
				}; // Start the trembling sequence
				// Freeze the sun
				sunFrozen = true;
				sunFrozenTimer = sunFrozenDuration; // 10 seconds frozen
				// Play icesun sound when sun is frozen
				LK.getSound('icesun').play();
				// Change sun to frozen appearance using icesun asset
				var sunIndex = game.children.indexOf(sun);
				sun.destroy();
				sun = game.addChildAt(LK.getAsset('icesun', {
					anchorX: 0.5,
					anchorY: 0.5,
					x: 1700,
					y: 300,
					scaleX: 1.5,
					scaleY: 1.5
				}), Math.max(greenBackgrounds.length + 1, Math.min(sunIndex, game.children.length)));
				createStrongTrembling();
				// Remove ice star
				iceStar.active = false;
				iceStar.destroy();
				iceStars.splice(i, 1);
				return 0; // continue
			}
		},
		iceStar,
		m,
		meteorite,
		j,
		enemy,
		j,
		enemy2,
		j,
		enemy3,
		j,
		j,
		archer,
		a,
		arrow,
		_ret;
	for (var i = iceStars.length - 1; i >= 0; i--) {
		_ret = _loop3();
		if (_ret === 0) {
			continue;
		}
	}
	// Update wooden stars
	for (var i = woodenStars.length - 1; i >= 0; i--) {
		var woodenStar = woodenStars[i];
		woodenStar.update();
		if (!woodenStar.active) {
			woodenStar.destroy();
			woodenStars.splice(i, 1);
			continue;
		}
		// Wooden stars pass through lightning clouds without effect - no collision detection with CloudType2
		// Check collision with meteorites
		for (var m = meteorites.length - 1; m >= 0; m--) {
			var meteorite = meteorites[m];
			if (meteorite.active && woodenStar.intersects(meteorite)) {
				meteorite.hitCount++;
				// Play hit sound when meteorite is hit
				LK.getSound('meteoro-golpe').play();
				// Change meteorite face when hit
				if (meteorite.hitCount < 3) {
					meteorite.changeFace();
				}
				// Remove wooden star
				woodenStar.active = false;
				woodenStar.destroy();
				woodenStars.splice(i, 1);
				// Destroy meteorite after 3 hits
				if (meteorite.hitCount >= 3) {
					meteorite.active = false;
					meteorite.destroy();
					meteorites.splice(m, 1);
					LK.getSound('meteoro-grito').play(); // Play cat scream sound when meteorite is destroyed
					LK.setScore(LK.getScore() + 50);
					updateScore();
				}
				break;
			}
		}
		// Check collision with enemies
		for (var j = enemies.length - 1; j >= 0; j--) {
			var enemy = enemies[j];
			if (enemy.active && woodenStar.intersects(enemy)) {
				// Hit enemy
				enemiesKilled++;
				LK.setScore(LK.getScore() + 10);
				updateScore();
				LK.getSound('hit').play();
				// Mark enemy as hit and start falling upside down
				enemy.falling = true;
				var enemyGraphics = enemy.children[0];
				// Rotate enemy upside down and make them fall
				tween(enemyGraphics, {
					rotation: Math.PI
				}, {
					duration: 300,
					easing: tween.easeOut
				});
				// Set falling velocity
				enemy.velocityY = -2; // Small upward velocity initially
				enemy.velocityX = enemy.velocityX * 0.3; // Reduce horizontal speed
				// Remove wooden star
				woodenStar.active = false;
				woodenStar.destroy();
				woodenStars.splice(i, 1);
				break;
			}
		}
		// Check collision with enemies2
		for (var j = enemies2.length - 1; j >= 0; j--) {
			var enemy2 = enemies2[j];
			if (enemy2.active && woodenStar.intersects(enemy2)) {
				// Hit enemy2
				enemiesKilled++;
				LK.setScore(LK.getScore() + 15);
				updateScore();
				LK.getSound('Hit2').play();
				// Mark enemy2 as hit and start falling upside down
				enemy2.falling = true;
				var enemy2Graphics = enemy2.children[0];
				// Rotate enemy upside down and make them fall
				tween(enemy2Graphics, {
					rotation: Math.PI
				}, {
					duration: 300,
					easing: tween.easeOut
				});
				// Set falling velocity
				enemy2.velocityY = -2; // Small upward velocity initially
				enemy2.velocityX = enemy2.velocityX * 0.3; // Reduce horizontal speed
				// Remove wooden star
				woodenStar.active = false;
				woodenStar.destroy();
				woodenStars.splice(i, 1);
				break;
			}
		}
		// Check collision with enemies3
		for (var j = enemies3.length - 1; j >= 0; j--) {
			var enemy3 = enemies3[j];
			if (enemy3.active && woodenStar.intersects(enemy3)) {
				// Hit enemy3
				enemiesKilled++;
				LK.setScore(LK.getScore() + 20);
				updateScore();
				LK.getSound('Enemy3').play();
				// Mark enemy3 as hit and start falling upside down
				enemy3.falling = true;
				var enemy3Graphics = enemy3.children[0];
				// Rotate enemy upside down and make them fall
				tween(enemy3Graphics, {
					rotation: Math.PI
				}, {
					duration: 300,
					easing: tween.easeOut
				});
				// Set falling velocity
				enemy3.velocityY = -2; // Small upward velocity initially
				enemy3.velocityX = enemy3.velocityX * 0.3; // Reduce horizontal speed
				// Remove wooden star
				woodenStar.active = false;
				woodenStar.destroy();
				woodenStars.splice(i, 1);
				break;
			}
		}
		// Check collision with enemy archers
		for (var j = enemyArchers.length - 1; j >= 0; j--) {
			var archer = enemyArchers[j];
			if (archer.active && woodenStar.intersects(archer)) {
				// Hit archer
				enemiesKilled++;
				LK.setScore(LK.getScore() + 25);
				updateScore();
				LK.getSound('Ninjaarrowgrito').play();
				// Mark archer as hit and start falling upside down
				archer.falling = true;
				var archerGraphics = archer.children[0];
				// Rotate archer upside down and make them fall
				tween(archerGraphics, {
					rotation: Math.PI
				}, {
					duration: 300,
					easing: tween.easeOut
				});
				// Set falling velocity
				archer.velocityY = -2; // Small upward velocity initially
				archer.velocityX = 0; // Stop horizontal movement for archers
				// Remove wooden star
				woodenStar.active = false;
				woodenStar.destroy();
				woodenStars.splice(i, 1);
				break;
			}
		}
		// Check collision with arrows (make them fall when hit)
		for (var a = arrows.length - 1; a >= 0; a--) {
			var arrow = arrows[a];
			if (arrow.active && !arrow.falling && woodenStar.intersects(arrow)) {
				// Arrow hit by wooden star - make it fall
				arrow.startFalling();
				// Remove wooden star
				woodenStar.active = false;
				woodenStar.destroy();
				woodenStars.splice(i, 1);
				break;
			}
		}
	}
	// Update ninja stars
	for (var i = ninjaStars.length - 1; i >= 0; i--) {
		var star = ninjaStars[i];
		star.update();
		if (!star.active) {
			star.destroy();
			ninjaStars.splice(i, 1);
			continue;
		}
		// Check collision with sun
		if (star.intersects(sun)) {
			// Hit sun - change sun image for 2 seconds
			if (!sunIsHit) {
				LK.getSound('sol-grito').play();
				sun.destroy();
				sun = game.addChildAt(LK.getAsset('sunHit', {
					anchorX: 0.5,
					anchorY: 0.5,
					x: 1700,
					y: 300,
					scaleX: 1.5,
					scaleY: 1.5
				}), greenBackgrounds.length + 2); // Insert after background tiles and grass mask
				sunIsHit = true;
				sunFaceTimer = 120; // 2 seconds at 60fps
			}
			// Remove star
			star.active = false;
			star.destroy();
			ninjaStars.splice(i, 1);
			continue;
		}
		// Check collision with CloudType2 to spawn lightning (only when clouds are near the end of the screen)
		var _loop2 = function _loop2() {
				cloud = clouds[c];
				if (cloud.active && star.intersects(cloud) && cloud.constructor === electroCloud) {
					// Only shoot lightning when cloud is close to the end of the screen (z <= 300)
					if (cloud.z <= 300) {
						// 3 complete black-white cycles
						var _lightningFlicker = function lightningFlicker() {
							flickerCount++;
							if (flickerCount <= maxFlickers) {
								var isBlack = flickerCount % 2 === 1; // Odd numbers = black, even = white
								tween(game, {
									tint: isBlack ? 0x000000 : 0xFFFFFF
								}, {
									duration: 80,
									easing: tween.linear,
									onFinish: function onFinish() {
										if (flickerCount < maxFlickers) {
											_lightningFlicker(); // Continue flickering
										} else {
											// Reset to normal color after flickering
											tween(game, {
												tint: 0xFFFFFF
											}, {
												duration: 50,
												easing: tween.linear
											});
										}
									}
								});
							}
						};
						// Spawn lightning that stretches from cloud center to ninja center
						lightning = new Lightning();
						lightning.x = cloud.x;
						lightning.y = cloud.y; // Position at cloud center
						// Stretch lightning from cloud center to ninja center
						lightning.stretchTo();
						lightnings.push(lightning);
						// Insert lightning at proper depth - below clouds and ninja
						var ninjaIndex = game.children.indexOf(ninja);
						var cloudIndex = game.children.indexOf(cloud);
						var insertIndex = Math.min(ninjaIndex, cloudIndex);
						if (insertIndex > 0) {
							game.addChildAt(lightning, insertIndex);
						} else {
							game.addChild(lightning);
						}
						// Play lightning sound
						LK.getSound('lightning').play();
						// Create black and white flickering effect when lightning strikes
						flickerCount = 0;
						maxFlickers = 6;
						_lightningFlicker(); // Start the flickering sequence
						// Stop any ongoing jump tweens to freeze ninja in current position
						tween.stop(ninja);
						// Stop rotation tween on ninja graphics if jumping
						if (ninja.children[0]) {
							tween.stop(ninja.children[0]);
						}
						// Change ninja image to electrocutado for visual effect only
						ninjaGraphics = ninja.children[0];
						ninjaGraphics.destroy();
						ninjaRayGraphics = ninja.attachAsset('electrocutado', {
							anchorX: 0.5,
							anchorY: 1.0,
							scaleX: 3.0,
							scaleY: 3.0
						});
						// Create electrocution effect with saturation changes only
						var effectCount = 0;
						var maxEffects = 8; // Number of saturation changes during electrocution
						var _createElectrocutionEffect = function createElectrocutionEffect() {
							if (effectCount < maxEffects) {
								effectCount++;
								// Apply saturation changes only (no flip)
								tween(ninjaRayGraphics, {
									tint: effectCount % 2 === 1 ? 0x0080FF : 0xFFFFFF // Blue tint for saturation effect
								}, {
									duration: 150,
									// Quick effect duration
									easing: tween.linear,
									onFinish: function onFinish() {
										_createElectrocutionEffect(); // Continue effects
									}
								});
							} else {
								// Final state - return to normal color but keep electrocuted appearance
								tween(ninjaRayGraphics, {
									tint: 0xFFFFFF // Return to normal color
								}, {
									duration: 100,
									easing: tween.easeOut
								});
							}
						};
						// Start the electrocution effect
						_createElectrocutionEffect();
						// Paralyze ninja for 2 seconds (lightning paralysis, not damage)
						ninjaParalyzed = true;
						ninjaParalyzeTimer = 120; // 2 seconds at 60fps
					}
					// Star passes through lightning - don't destroy it, just continue
					return 1; // break
				}
			},
			cloud,
			lightning,
			flickerCount,
			maxFlickers,
			ninjaGraphics,
			ninjaRayGraphics;
		for (var c = clouds.length - 1; c >= 0; c--) {
			if (_loop2()) {
				break;
			}
		}
		// Check collision with meteorites
		for (var m = meteorites.length - 1; m >= 0; m--) {
			var meteorite = meteorites[m];
			if (meteorite.active && star.intersects(meteorite)) {
				meteorite.hitCount++;
				// Play hit sound when meteorite is hit
				LK.getSound('meteoro-golpe').play();
				// Change meteorite face when hit
				if (meteorite.hitCount < 3) {
					meteorite.changeFace();
				}
				// Remove star
				star.active = false;
				star.destroy();
				ninjaStars.splice(i, 1);
				// Destroy meteorite after 3 hits
				if (meteorite.hitCount >= 3) {
					meteorite.active = false;
					meteorite.destroy();
					meteorites.splice(m, 1);
					LK.getSound('meteoro-grito').play(); // Play cat scream sound when meteorite is destroyed
					LK.setScore(LK.getScore() + 50);
					updateScore();
				}
				break;
			}
		}
		// Check collision with airplanes
		for (var a = airplanes.length - 1; a >= 0; a--) {
			var airplane = airplanes[a];
			if (airplane.active && star.intersects(airplane)) {
				// Hit airplane - drop power-up
				dropPowerUp(airplane);
				// Play special airplane hit sound
				LK.getSound('Avion').play();
				// Remove star
				star.active = false;
				star.destroy();
				ninjaStars.splice(i, 1);
				break;
			}
		}
		// Check collision with enemies
		for (var j = enemies.length - 1; j >= 0; j--) {
			var enemy = enemies[j];
			if (enemy.active && star.intersects(enemy)) {
				// Hit enemy
				enemiesKilled++;
				LK.setScore(LK.getScore() + 10);
				updateScore();
				LK.getSound('hit').play();
				// Mark enemy as hit and start falling upside down
				enemy.falling = true;
				var enemyGraphics = enemy.children[0];
				// Rotate enemy upside down and make them fall
				tween(enemyGraphics, {
					rotation: Math.PI
				}, {
					duration: 300,
					easing: tween.easeOut
				});
				// Set falling velocity
				enemy.velocityY = -2; // Small upward velocity initially
				enemy.velocityX = enemy.velocityX * 0.3; // Reduce horizontal speed
				// Remove star
				star.active = false;
				star.destroy();
				ninjaStars.splice(i, 1);
				break;
			}
		}
		// Check collision with enemies2 (NMI2)
		for (var j = enemies2.length - 1; j >= 0; j--) {
			var enemy2 = enemies2[j];
			if (enemy2.active && star.intersects(enemy2)) {
				// Hit enemy2
				enemiesKilled++;
				LK.setScore(LK.getScore() + 15); // More points for NMI2
				updateScore();
				LK.getSound('Hit2').play(); // Different sound for NMI2
				// Mark enemy2 as hit and start falling upside down
				enemy2.falling = true;
				var enemy2Graphics = enemy2.children[0];
				// Rotate enemy upside down and make them fall
				tween(enemy2Graphics, {
					rotation: Math.PI
				}, {
					duration: 300,
					easing: tween.easeOut
				});
				// Set falling velocity
				enemy2.velocityY = -2; // Small upward velocity initially
				enemy2.velocityX = enemy2.velocityX * 0.3; // Reduce horizontal speed
				// Remove star
				star.active = false;
				star.destroy();
				ninjaStars.splice(i, 1);
				break;
			}
		}
		// Check collision with enemies3 (Enemy3)
		for (var j = enemies3.length - 1; j >= 0; j--) {
			var enemy3 = enemies3[j];
			if (enemy3.active && star.intersects(enemy3)) {
				// Hit enemy3
				enemiesKilled++;
				LK.setScore(LK.getScore() + 20); // More points for Enemy3
				updateScore();
				LK.getSound('Enemy3').play(); // Enemy3 sound for hit
				// Mark enemy3 as hit and start falling upside down
				enemy3.falling = true;
				var enemy3Graphics = enemy3.children[0];
				// Rotate enemy upside down and make them fall
				tween(enemy3Graphics, {
					rotation: Math.PI
				}, {
					duration: 300,
					easing: tween.easeOut
				});
				// Set falling velocity
				enemy3.velocityY = -2; // Small upward velocity initially
				enemy3.velocityX = enemy3.velocityX * 0.3; // Reduce horizontal speed
				// Remove star
				star.active = false;
				star.destroy();
				ninjaStars.splice(i, 1);
				break;
			}
		}
		// Check collision with enemy archers
		for (var j = enemyArchers.length - 1; j >= 0; j--) {
			var archer = enemyArchers[j];
			if (archer.active && star.intersects(archer)) {
				// Hit archer
				enemiesKilled++;
				LK.setScore(LK.getScore() + 25);
				updateScore();
				LK.getSound('Ninjaarrowgrito').play();
				// Mark archer as hit and start falling upside down
				archer.falling = true;
				var archerGraphics = archer.children[0];
				// Rotate archer upside down and make them fall
				tween(archerGraphics, {
					rotation: Math.PI
				}, {
					duration: 300,
					easing: tween.easeOut
				});
				// Set falling velocity
				archer.velocityY = -2; // Small upward velocity initially
				archer.velocityX = 0; // Stop horizontal movement for archers
				// Remove star
				star.active = false;
				star.destroy();
				ninjaStars.splice(i, 1);
				break;
			}
		}
		// Check collision with arrows (make them fall when hit)
		for (var a = arrows.length - 1; a >= 0; a--) {
			var arrow = arrows[a];
			if (arrow.active && !arrow.falling && star.intersects(arrow)) {
				// Arrow hit by ninja star - make it fall
				arrow.startFalling();
				// Remove star
				star.active = false;
				star.destroy();
				ninjaStars.splice(i, 1);
				break;
			}
		}
	}
	// Update enemies
	for (var i = enemies.length - 1; i >= 0; i--) {
		var enemy = enemies[i];
		enemy.update();
		if (!enemy.active) {
			enemy.destroy();
			enemies.splice(i, 1);
			continue;
		}
		// Check collision with ninja (only in lower part of game when enemy is close, not frozen, and not falling)
		if (enemy.y > 2200 && !enemy.frozen && !enemy.falling && ninja.intersects(enemy)) {
			LK.getSound('ninja-ouch').play();
			// Turn screen red and stop ninja walking
			tween(game, {
				tint: 0xff0000
			}, {
				duration: 100,
				easing: tween.linear
			});
			ninjaParalyzed = true;
			var impactImage = game.addChild(LK.getAsset('impact', {
				anchorX: 0.5,
				anchorY: 0.5,
				x: ninja.x,
				y: ninja.y - 250,
				scaleX: 2.0,
				scaleY: 2.0
			}));
			LK.effects.flashScreen(0xff0000, 1000);
			game.paused = true;
			LK.setTimeout(function () {
				LK.showGameOver();
			}, 2000);
			return;
		}
	}
	// Update enemies2 (NMI2)
	for (var i = enemies2.length - 1; i >= 0; i--) {
		var enemy2 = enemies2[i];
		enemy2.update();
		if (!enemy2.active) {
			enemy2.destroy();
			enemies2.splice(i, 1);
			continue;
		}
		// Check collision with ninja (only in lower part of game when enemy is close, not frozen, and not falling)
		if (enemy2.y > 2200 && !enemy2.frozen && !enemy2.falling && ninja.intersects(enemy2)) {
			LK.getSound('ninja-ouch').play();
			// Turn screen red and stop ninja walking
			tween(game, {
				tint: 0xff0000
			}, {
				duration: 100,
				easing: tween.linear
			});
			ninjaParalyzed = true;
			var impactImage = game.addChild(LK.getAsset('impact', {
				anchorX: 0.5,
				anchorY: 0.5,
				x: ninja.x,
				y: ninja.y - 250,
				scaleX: 2.0,
				scaleY: 2.0
			}));
			LK.effects.flashScreen(0xff0000, 1000);
			game.paused = true;
			LK.setTimeout(function () {
				LK.showGameOver();
			}, 2000);
			return;
		}
	}
	// Update enemies3 (Enemy3)
	for (var i = enemies3.length - 1; i >= 0; i--) {
		var enemy3 = enemies3[i];
		enemy3.update();
		if (!enemy3.active) {
			enemy3.destroy();
			enemies3.splice(i, 1);
			continue;
		}
		// Check collision with ninja (only in lower part of game when enemy is close, not frozen, and not falling)
		if (enemy3.y > 2200 && !enemy3.frozen && !enemy3.falling && ninja.intersects(enemy3)) {
			LK.getSound('ninja-ouch').play();
			// Turn screen red and stop ninja walking
			tween(game, {
				tint: 0xff0000
			}, {
				duration: 100,
				easing: tween.linear
			});
			ninjaParalyzed = true;
			var impactImage = game.addChild(LK.getAsset('impact', {
				anchorX: 0.5,
				anchorY: 0.5,
				x: ninja.x,
				y: ninja.y - 250,
				scaleX: 2.0,
				scaleY: 2.0
			}));
			LK.effects.flashScreen(0xff0000, 1000);
			game.paused = true;
			LK.setTimeout(function () {
				LK.showGameOver();
			}, 2000);
			return;
		}
	}
	// Update enemy archers
	for (var i = enemyArchers.length - 1; i >= 0; i--) {
		var archer = enemyArchers[i];
		archer.update();
		if (!archer.active) {
			archer.destroy();
			enemyArchers.splice(i, 1);
		}
	}
	// Update arrows
	for (var i = arrows.length - 1; i >= 0; i--) {
		var arrow = arrows[i];
		arrow.update();
		if (!arrow.active) {
			arrow.destroy();
			arrows.splice(i, 1);
			continue;
		}
		// Check collision with ninja
		if (ninja.intersects(arrow)) {
			LK.getSound('ninja-ouch').play();
			// Turn screen red and stop ninja walking
			tween(game, {
				tint: 0xff0000
			}, {
				duration: 100,
				easing: tween.linear
			});
			ninjaParalyzed = true;
			var impactImage = game.addChild(LK.getAsset('impact', {
				anchorX: 0.5,
				anchorY: 0.5,
				x: ninja.x,
				y: ninja.y - 250,
				scaleX: 2.0,
				scaleY: 2.0
			}));
			LK.effects.flashScreen(0xff0000, 1000);
			game.paused = true;
			LK.setTimeout(function () {
				LK.showGameOver();
			}, 2000);
			return;
		}
	}
	// Update lightnings
	for (var i = lightnings.length - 1; i >= 0; i--) {
		var lightning = lightnings[i];
		lightning.update();
		if (!lightning.active) {
			lightning.destroy();
			lightnings.splice(i, 1);
			continue;
		}
	}
	// Update meteorites
	for (var i = meteorites.length - 1; i >= 0; i--) {
		var meteorite = meteorites[i];
		meteorite.update();
		if (!meteorite.active) {
			meteorite.destroy();
			meteorites.splice(i, 1);
			continue;
		}
		// Check collision with ninja
		if (ninja.intersects(meteorite)) {
			LK.getSound('ninja-ouch').play();
			// Turn screen red and stop ninja walking
			tween(game, {
				tint: 0xff0000
			}, {
				duration: 100,
				easing: tween.linear
			});
			ninjaParalyzed = true;
			var impactImage = game.addChild(LK.getAsset('impact', {
				anchorX: 0.5,
				anchorY: 0.5,
				x: ninja.x,
				y: ninja.y - 250,
				scaleX: 2.0,
				scaleY: 2.0
			}));
			LK.effects.flashScreen(0xff0000, 1000);
			game.paused = true;
			LK.setTimeout(function () {
				LK.showGameOver();
			}, 2000);
			return;
		}
	}
	// Check collision with obstacles
	for (var i = obstacles.length - 1; i >= 0; i--) {
		var obstacle = obstacles[i];
		obstacle.update();
		if (!obstacle.active) {
			obstacle.destroy();
			obstacles.splice(i, 1);
			continue;
		}
		// Check collision with ninja stars hitting obstacles
		for (var s = ninjaStars.length - 1; s >= 0; s--) {
			var star = ninjaStars[s];
			if (star.active && obstacle.active && star.intersects(obstacle)) {
				// Remove star
				star.active = false;
				star.destroy();
				ninjaStars.splice(s, 1);
				break;
			}
		}
		// Check collision with wooden stars hitting obstacles
		for (var ws = woodenStars.length - 1; ws >= 0; ws--) {
			var woodenStar = woodenStars[ws];
			if (woodenStar.active && obstacle.active && woodenStar.intersects(obstacle)) {
				// Remove wooden star
				woodenStar.active = false;
				woodenStar.destroy();
				woodenStars.splice(ws, 1);
				break;
			}
		}
		// Check collision with ninja (only if not jumping and when obstacle reaches ninja's feet at ground level)
		if (!ninja.isJumping && obstacle.y > 2600 && ninja.intersects(obstacle)) {
			// Ninja collides with obstacle - play mushroom hit sound
			LK.getSound('mushroom-hit').play();
			LK.getSound('pipipipipi').play();
			LK.getSound('ninja-ouch').play();
			// Turn screen red and stop ninja walking
			tween(game, {
				tint: 0xff0000
			}, {
				duration: 100,
				easing: tween.linear
			});
			ninjaParalyzed = true;
			var impactImage = game.addChild(LK.getAsset('impact', {
				anchorX: 0.5,
				anchorY: 0.5,
				x: ninja.x,
				y: ninja.y - 250,
				scaleX: 2.0,
				scaleY: 2.0
			}));
			LK.effects.flashScreen(0xff0000, 1000);
			game.paused = true;
			LK.setTimeout(function () {
				LK.showGameOver();
			}, 2000);
			return;
		}
	}
	// Update toris
	for (var i = toris.length - 1; i >= 0; i--) {
		var tori = toris[i];
		tori.update();
		if (!tori.active) {
			tori.destroy();
			toris.splice(i, 1);
			continue;
		}
		// Check if ninja is jumping and near the tori
		if (ninja.isJumping && tori.y > 2200 && ninja.intersects(tori)) {
			LK.getSound('ninja-ouch').play();
			// Turn screen red and stop ninja walking
			tween(game, {
				tint: 0xff0000
			}, {
				duration: 100,
				easing: tween.linear
			});
			ninjaParalyzed = true;
			var impactImage = game.addChild(LK.getAsset('impact', {
				anchorX: 0.5,
				anchorY: 0.5,
				x: ninja.x,
				y: ninja.y - 250,
				scaleX: 2.0,
				scaleY: 2.0
			}));
			LK.getSound('hit').play();
			LK.effects.flashScreen(0xff0000, 1000);
			game.paused = true;
			LK.setTimeout(function () {
				LK.showGameOver();
			}, 2000);
			return;
		}
	}
	// Spawn enemies - only after main screen is dismissed
	if (!mainScreenActive) {
		enemySpawnTimer++;
		if (enemySpawnTimer > 600) {
			spawnEnemy();
			enemySpawnTimer = 0;
		}
		// Spawn enemies2 (NMI2) - only if unlocked
		enemy2SpawnTimer++;
		if (enemy2SpawnTimer > 900 && isFeatureUnlocked('enemy2')) {
			// Spawn less frequently than regular enemies
			spawnEnemy2();
			enemy2SpawnTimer = 0;
		}
		// Spawn enemies3 (Enemy3) - only if unlocked
		enemy3SpawnTimer++;
		if (enemy3SpawnTimer > 1200 && isFeatureUnlocked('enemy3')) {
			// Spawn less frequently than other enemies
			spawnEnemy3();
			enemy3SpawnTimer = 0;
		}
		// Spawn enemy archers on trees - only at medium-advanced level (Level 4+)
		if (LK.ticks % 900 === 0 && getCurrentDifficultyLevel() >= 4) {
			// Every 15 seconds, only at Level 4+
			spawnEnemyArcher();
		}
	}
	// Spawn obstacles - much less frequently and with conflict detection
	obstacleSpawnTimer++;
	if (obstacleSpawnTimer > 1200) {
		// Doubled from 600 to 1200 for fewer obstacles
		// Check if there's been a recent enemy spawn to avoid conflicts
		if (LK.ticks - lastEnemySpawnTime > 180) {
			// 3 seconds buffer after enemy spawn
			spawnObstacle();
			obstacleSpawnTimer = 0;
		} else {
			// Reset timer partially to retry sooner
			obstacleSpawnTimer = 800; // Retry in 400 ticks instead of full 1200
		}
	}
	// Spawn toris
	toriSpawnTimer++;
	if (toriSpawnTimer > 480) {
		// Spawn every 8 seconds
		spawnTori();
		toriSpawnTimer = 0;
	}
	// Update clouds
	for (var i = clouds.length - 1; i >= 0; i--) {
		var cloud = clouds[i];
		cloud.update();
		if (!cloud.active) {
			cloud.destroy();
			clouds.splice(i, 1);
		}
	}
	// Fog system removed - no fog updates needed
	// Update trees
	for (var i = trees.length - 1; i >= 0; i--) {
		var tree = trees[i];
		tree.update();
		if (!tree.active) {
			tree.destroy();
			trees.splice(i, 1);
		}
	}
	// Update wooden planks
	for (var i = woodenPlanks.length - 1; i >= 0; i--) {
		var plank = woodenPlanks[i];
		plank.update();
		if (!plank.active) {
			plank.destroy();
			woodenPlanks.splice(i, 1);
		}
	}
	// Update airplanes
	for (var i = airplanes.length - 1; i >= 0; i--) {
		var airplane = airplanes[i];
		airplane.update();
		if (!airplane.active) {
			airplane.destroy();
			airplanes.splice(i, 1);
		}
	}
	// Update power-ups
	for (var i = powerUps.length - 1; i >= 0; i--) {
		var powerUp = powerUps[i];
		powerUp.update();
		if (!powerUp.active) {
			powerUp.destroy();
			powerUps.splice(i, 1);
			continue;
		}
		// Check collision with ninja for power-up collection
		if (ninja.intersects(powerUp)) {
			// Collect power-up
			LK.setScore(LK.getScore() + 25);
			updateScore();
			LK.getSound('jump').play(); // Use jump sound for power-up collection
			// Check if this is the wooden star power-up (type 1)
			if (powerUp.powerupType === 1) {
				hasWoodenStarPower = true;
				woodenStarPowerTimer = woodenStarDuration; // 30 seconds
				updateWeaponIndicator(); // Update weapon indicator when power is activated
			}
			// Check if this is the ice power-up (type 2)
			if (powerUp.powerupType === 2) {
				hasIcePower = true;
				icePowerTimer = icePowerDuration; // 30 seconds
				updateWeaponIndicator(); // Update weapon indicator when power is activated
			}
			powerUp.active = false;
			powerUp.destroy();
			powerUps.splice(i, 1);
		}
	}
	// Spawn clouds
	cloudSpawnTimer++;
	if (cloudSpawnTimer > 120) {
		// Spawn clouds less frequently for easier gameplay
		spawnCloud();
		cloudSpawnTimer = 0;
	}
	// Fog spawning removed - no fog elements needed
	// Spawn trees on both sides
	treeSpawnTimer++;
	if (treeSpawnTimer > 90) {
		// Spawn trees much more frequently - 1.5 seconds interval for many more trees
		spawnTrees();
		treeSpawnTimer = 0;
	}
	// Spawn wooden planks with more spacing for walkway effect
	if (LK.ticks % 25 === 0) {
		// Spawn wooden planks every 25 frames (0.42 seconds) for spaced walkway effect
		spawnWoodenPlanks();
	}
	// Spawn airplanes periodically - only if unlocked
	airplaneSpawnTimer++;
	if (airplaneSpawnTimer > 600 && isFeatureUnlocked('airplanes')) {
		// Every 10 seconds
		spawnAirplane();
		airplaneSpawnTimer = 0;
	}
	// Enemy spawning handled by spawnEnemy function with tree physics
	// Handle sun frozen timer
	if (sunFrozen && sunFrozenTimer > 0) {
		sunFrozenTimer--;
		if (sunFrozenTimer <= 0) {
			// Stop any ongoing trembling tweens before unfreezing
			tween.stop(sun);
			// Unfreeze sun - change back to normal
			sunFrozen = false;
			var sunIndex = game.children.indexOf(sun);
			sun.destroy();
			sun = game.addChildAt(LK.getAsset('sun', {
				anchorX: 0.5,
				anchorY: 0.5,
				x: 1700,
				y: 300,
				scaleX: 1.5,
				scaleY: 1.5
			}), Math.max(greenBackgrounds.length + 1, Math.min(sunIndex, game.children.length)));
		}
	}
	// Handle sun face timer (only if not frozen)
	if (!sunFrozen && sunIsHit && sunFaceTimer > 0) {
		sunFaceTimer--;
		if (sunFaceTimer <= 0) {
			// Only spawn meteorite if sun is not frozen
			if (!sunFrozen) {
				// Change sun to laughing/attack face and spawn meteorite
				sun.destroy();
				sun = game.addChildAt(LK.getAsset('sunAttack', {
					anchorX: 0.5,
					anchorY: 0.5,
					x: 1700,
					y: 300,
					scaleX: 3.0,
					scaleY: 3.0
				}), greenBackgrounds.length + 2);
				LK.getSound('sol-risa').play();
				sunIsHit = false;
				// Spawn meteorite toward ninja
				var meteorite = new Meteorite();
				meteorite.x = sun.x;
				meteorite.y = sun.y;
				// Calculate direction toward ninja
				var dx = ninja.x - meteorite.x;
				var dy = ninja.y - meteorite.y;
				var distance = Math.sqrt(dx * dx + dy * dy);
				// Set velocity toward ninja
				meteorite.velocityX = dx / distance * meteorite.speed;
				meteorite.velocityY = dy / distance * meteorite.speed;
				meteorites.push(meteorite);
				game.addChild(meteorite);
				// Set timer to change sun back to normal after meteorite is sent
				sunFaceTimer = 60; // 1 second to show laughing face
			}
		}
	} else if (!sunFrozen && !sunIsHit && sunFaceTimer > 0) {
		// Handle sun laughing face timer (when not hit but showing attack face and not frozen)
		sunFaceTimer--;
		if (sunFaceTimer <= 0) {
			// Change sun back to normal after laughing
			sun.destroy();
			sun = game.addChildAt(LK.getAsset('sun', {
				anchorX: 0.5,
				anchorY: 0.5,
				x: 1700,
				y: 300,
				scaleX: 1.5,
				scaleY: 1.5
			}), greenBackgrounds.length + 2);
		}
	}
	// Handle ninja paralysis timer
	if (ninjaParalyzed && ninjaParalyzeTimer > 0) {
		ninjaParalyzeTimer--;
		if (ninjaParalyzeTimer <= 0) {
			// Recover from paralysis
			ninjaParalyzed = false;
			// Stop all ongoing tweens on ninja and ninja graphics to prevent conflicts
			tween.stop(ninja);
			if (ninja.children[0]) {
				tween.stop(ninja.children[0]);
			}
			// Completely reset ninja state - force to ground position
			ninja.y = ninja.groundY;
			ninja.isJumping = false;
			ninja.jumpVelocity = 0;
			ninja.jumpCount = 0; // Reset jump count to allow jumping again
			// Remove ALL existing graphics completely and safely
			while (ninja.children.length > 0) {
				var child = ninja.children[0];
				child.destroy();
			}
			// Add fresh normal ninja graphics for ground walking state
			var normalNinjaGraphics = ninja.attachAsset('ninja', {
				anchorX: 0.5,
				anchorY: 1.0
			});
			// Properly restore walking animation state from scratch
			ninja.flipDirection = 1; // Reset to default direction
			ninja.runningTimer = 29; // Set to 29 so next update triggers flip immediately (30 is the flip threshold)
			normalNinjaGraphics.scaleX = ninja.flipDirection;
			// Ensure completely clean rotation state
			normalNinjaGraphics.rotation = 0;
			// Ensure the ninja graphics reference is properly updated for the flip animation
			var ninjaGraphics = normalNinjaGraphics;
			// Force the ninja update to run immediately to restart walking animation loop
			ninja.update();
		}
	}
	// Continuous scoring for time survived (1 point per second) and update display
	if (LK.ticks % 60 === 0) {
		LK.setScore(LK.getScore() + 1);
		updateScore();
	}
	// Update alerts
	for (var i = alerts.length - 1; i >= 0; i--) {
		var alert = alerts[i];
		alert.update();
		if (!alert.active) {
			alert.destroy();
			alerts.splice(i, 1);
		}
	}
	// Sort objects by depth every few frames for proper layering
	if (LK.ticks % 10 === 0) {
		sortObjectsByDepth();
	}
};