/****
* Assets
****/
LK.init.shape('grassMask', {width:3000, height:3000, color:0x228b22, shape:'box'})
LK.init.shape('grassSolid', {width:2048, height:2000, color:0x078134, shape:'box'})
LK.init.image('Archer-ninja', {width:100, height:100, id:'687e2b5a5089f8124e100aa0'})
LK.init.image('Arma-ui', {width:100, height:100, id:'6880b9d8303aec2e4fad813e'})
LK.init.image('Enemy2', {width:250, height:288.29, id:'687d9735bdf42f92241c548b', flipX:1})
LK.init.image('Enemy3', {width:250, height:250, id:'687d9c5dbdf42f92241c54be', flipX:1})
LK.init.image('Ice-horiuken', {width:280, height:200, id:'687e1ca048730eff1e65a3f6', orientation:3})
LK.init.image('Mainscreen', {width:400, height:400, id:'6886dca33409d3f2dc0e0f22'})
LK.init.image('Wood-shoriuken', {width:100, height:100, id:'687e1b0348730eff1e65a39c'})
LK.init.image('airplane', {width:200, height:150, id:'687d9965bdf42f92241c54a8', flipX:1})
LK.init.image('alert', {width:100, height:100, id:'68856d419f9a0a22adc0c1ad'})
LK.init.image('archer-ninja', {width:500, height:500, id:'687e2b5a5089f8124e100a9f', flipX:1})
LK.init.image('archer-ninja-full-body', {width:100, height:100, id:'687e21af97be05183722092e', flipX:1})
LK.init.image('arrow', {width:40, height:17.34, id:'687e246697be05183722093f'})
LK.init.image('backgroundImage', {width:2048, height:2732, id:'687d7eae546d3d568db4f1d9'})
LK.init.image('casaNinja', {width:600, height:600, id:'6893ba9c6c5d0982f48f476e'})
LK.init.image('casaNinjaCerrada', {width:600, height:600, id:'6893e82b5896eda87911e33f'})
LK.init.image('center-ui-bg', {width:200, height:74.22, id:'6886b03e0363b585632d55ae'})
LK.init.image('cloud', {width:50, height:26.8, id:'687c37cce5cbe2bee2b1bfd1'})
LK.init.image('cloudInactive', {width:100, height:100, id:'6893ff94eba6f1f305376726'})
LK.init.image('cloudType2', {width:200, height:197.66, id:'687d876bbdf42f92241c53ec'})
LK.init.image('cloudType3', {width:100, height:60, id:'687c37cce5cbe2bee2b1bfce'})
LK.init.image('electrocutado', {width:600, height:180, id:'68940cf06c5d0982f48f4818'})
LK.init.image('enemy', {width:300, height:307, id:'687c381ae5cbe2bee2b1bfdb', flipX:1})
LK.init.image('freeze-archer-ninja', {width:400, height:400, id:'687fda0388fabecfe2dd55cc'})
LK.init.image('freeze-enemy', {width:300, height:300, id:'687f88b35ad081944b422bcd'})
LK.init.image('freeze-enemy2', {width:300, height:300, id:'687f7fbeffc990ba21391f96'})
LK.init.image('freeze-enemy3', {width:300, height:300, id:'687f7de9ffc990ba21391f79'})
LK.init.image('frezze-airplane', {width:300, height:300, id:'687f7d395ad081944b422bab', flipX:1})
LK.init.image('greenBackground', {width:137, height:100, id:'687cda9602066f9f2984dce7'})
LK.init.image('icesun', {width:300, height:300, id:'687e5ec363d16be0c7d93b9f'})
LK.init.image('impact', {width:200, height:200, id:'687d5767c4a1a36a58c65588'})
LK.init.image('indicaciones', {width:130, height:50, id:'6894cce7eba6f1f30537677a'})
LK.init.image('instrucciones', {width:100, height:100, id:'6894c4a8eba6f1f30537676c'})
LK.init.image('lightning', {width:33, height:50, id:'687d88e8bdf42f92241c5405', orientation:1})
LK.init.image('meteor', {width:100, height:100, id:'687cfa104caaf4399f3ee147'})
LK.init.image('meteorHit1', {width:100, height:100, id:'687d4065be19cec154f53235'})
LK.init.image('meteorHit2', {width:100, height:100, id:'687d4102be19cec154f53253'})
LK.init.image('montefuji', {width:1000, height:500, id:'687d7eae546d3d568db4f1d9'})
LK.init.image('ninja', {width:400, height:538.95, id:'687d55ebc4a1a36a58c65567'})
LK.init.image('ninja-jump', {width:300, height:300, id:'687d56e7c4a1a36a58c6557d'})
LK.init.image('ninjastar', {width:160, height:160, id:'687abe1613bc828807a1ea61'})
LK.init.image('nube-frezze', {width:200, height:197.66, id:'68856ebd9f9a0a22adc0c1b8'})
LK.init.image('obstacle', {width:300, height:314.75, id:'687e507f63d16be0c7d93ad2'})
LK.init.image('parachute', {width:80, height:80, id:'687da11abdf42f92241c54da'})
LK.init.image('powerup1', {width:60, height:60, id:'68864d1227e10acdc345396b'})
LK.init.image('powerup2', {width:60, height:60, id:'68864de727e10acdc345397a'})
LK.init.image('rockObstacle', {width:300, height:296, id:'687e5d2863d16be0c7d93b80'})
LK.init.image('shoriuken3', {width:100, height:100, id:'6891fd90eba6f1f305376673'})
LK.init.image('spikeObstacle', {width:400, height:415, id:'687e583363d16be0c7d93b43'})
LK.init.image('sun', {width:300, height:300, id:'687d3878be19cec154f53150'})
LK.init.image('sunAttack', {width:150, height:150, id:'687cea1702066f9f2984ddca'})
LK.init.image('sunHit', {width:300, height:300, id:'687cea1702066f9f2984ddc8'})
LK.init.image('tori', {width:600, height:571.88, id:'687d14fd4caaf4399f3ee271'})
LK.init.image('tree', {width:400, height:600, id:'687ced1902066f9f2984ddec'})
LK.init.image('treeType2', {width:300, height:450, id:'687ced1902066f9f2984ddeb'})
LK.init.image('treeType3', {width:500, height:466.8, id:'687ced1902066f9f2984ddea'})
LK.init.image('wooden-start', {width:100, height:100, id:'687e1b0348730eff1e65a39c'})
LK.init.image('woodenPlank', {width:400, height:109.38, id:'687f83cc5ad081944b422bbb'})
LK.init.image('woodenPlank4', {width:400, height:235.94, id:'687d6ed8546d3d568db4f020'})
LK.init.sound('Arcer-apears', {volume:1, start:0.43, end:0.929, id:'689133a65896eda87911e25b'})
LK.init.sound('Avion', {volume:1, start:0.194, end:1, id:'6891373a5896eda87911e273'})
LK.init.sound('Congelado', {volume:1, start:0, end:1, id:'687fdb2488fabecfe2dd55e1'})
LK.init.sound('Enemy3', {volume:1, start:0.292, end:0.874, id:'687d9ca7bdf42f92241c54c4'})
LK.init.sound('Hit2', {volume:1, start:0.15, end:1, id:'687d9676bdf42f92241c5482'})
LK.init.sound('Ninjaarrowgrito', {volume:1, start:0.361, end:1, id:'687ce7c702066f9f2984dd9d'})
LK.init.sound('aeroplane-fall', {volume:1, start:0, end:1, id:'6886e3ee828e2fa043a9e80e'})
LK.init.sound('alert-sound', {volume:1, start:0.141, end:0.417, id:'689115a8eba6f1f305376639'})
LK.init.sound('alivio', {volume:1, start:0.492, end:0.672, id:'6893d7de5896eda87911e334'})
LK.init.sound('archer-shoot', {volume:1.5, start:0, end:1, id:'687e298f5089f8124e100a87'})
LK.init.sound('bloop', {volume:2, start:0.309, end:0.471, id:'6893e87ceba6f1f30537671f'})
LK.init.sound('bodyFall', {volume:1.85, start:0, end:0.512, id:'6891f718eba6f1f30537666b'})
LK.init.sound('brbrbrbrbr', {volume:1, start:0.385, end:0.763, id:'689134375896eda87911e261'})
LK.init.sound('breakIce', {volume:0.5, start:0.453, end:0.669, id:'688f817ce0d9f2c7c65f34cd'})
LK.init.sound('electric-cloud-hit', {volume:1, start:0.375, end:1, id:'68940308eba6f1f305376728'})
LK.init.sound('fallBox', {volume:1, start:0.223, end:0.63, id:'689134375896eda87911e267'})
LK.init.sound('hit', {volume:1, start:0, end:1, id:'687ce7e702066f9f2984dda1'})
LK.init.sound('ice-throw')
LK.init.sound('icesun', {volume:1, start:0, end:1, id:'687e621463d16be0c7d93bbd'})
LK.init.sound('jump', {volume:1, start:0, end:1, id:'687ce4f802066f9f2984dd49'})
LK.init.sound('lightning', {volume:0.8, start:0, end:1, id:'687d04424caaf4399f3ee1ec'})
LK.init.music('main-theme', {volume:0.5, start:0, end:1, id:'687ce4796abc931f9db9a9e1'})
LK.init.music('mainTheme')
LK.init.sound('meo', {volume:1.5, start:0.686, end:0.941, id:'6893d7df5896eda87911e337'})
LK.init.sound('meteoro-golpe', {volume:2, start:0.495, end:0.692, id:'689134375896eda87911e264'})
LK.init.sound('meteoro-grito', {volume:2, start:0.51, end:0.68, id:'689134375896eda87911e263'})
LK.init.sound('meterito-voltea')
LK.init.sound('mushroom-hit', {volume:1, start:0.281, end:0.779, id:'689133d65896eda87911e25e'})
LK.init.sound('ninja-ouch', {volume:1, start:0, end:0.783, id:'687d60a5546d3d568db4ef95'})
LK.init.sound('ninjaJump', {volume:1, start:0, end:1, id:'687cf1f902066f9f2984de22'})
LK.init.sound('pedoLargo', {volume:1.5, start:0.295, end:0.612, id:'6893e87ceba6f1f30537671e'})
LK.init.sound('pedos', {volume:2, start:0.565, end:0.668, id:'6893e87ceba6f1f30537671c'})
LK.init.sound('pipipipipi', {volume:1, start:0, end:0.714, id:'687e658de214dcb39e5b1d0d'})
LK.init.sound('planeHit', {volume:1, start:0.291, end:0.453, id:'68940f58eba6f1f30537672d'})
LK.init.sound('planefall', {volume:0.5, start:0, end:1, id:'687e25fe97be051837220948'})
LK.init.sound('portazo', {volume:1, start:0.421, end:0.582, id:'6893d7de5896eda87911e333'})
LK.init.sound('powerUp', {volume:1, start:0.501, end:0.77, id:'689133d6eba6f1f305376642'})
LK.init.sound('puerta-abre', {volume:1, start:0.433, end:0.724, id:'6893d7de5896eda87911e335'})
LK.init.sound('sol-grito', {volume:1, start:0, end:1, id:'687d17df4caaf4399f3ee290'})
LK.init.sound('sol-risa', {volume:1, start:0.103, end:0.953, id:'687d50c6c4a1a36a58c65538'})
LK.init.sound('throw', {volume:1, start:0, end:1, id:'687ce54002066f9f2984dd53'})
LK.init.sound('wc', {volume:1.5, start:0.127, end:0.736, id:'6893d7df5896eda87911e336'})

/**** 
* Plugins
****/
var tween = LK.import("@upit/tween.v1");

/**** 
* Classes
****/
var Airplane = Container.expand(function () {
	var self = Container.call(this);
	var airplaneGraphics = self.attachAsset('airplane', {
		anchorX: 0.5,
		anchorY: 0.5,
		scaleX: 2.0,
		scaleY: 2.0
	});
	self.active = true;
	self.speed = 2;
	self.direction = 1;
	self.altitude = 800;
	self.frozen = false;
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		if (self.falling) {
			self.fallVelocityY = self.fallVelocityY || 0;
			self.fallVelocityY += 1.2;
			self.x += self.fallVelocityX;
			self.y += self.fallVelocityY;
			var airplaneGraphics = self.children[0];
			if (airplaneGraphics) {
				airplaneGraphics.rotation = 0;
			}
		} else {
			self.x += self.speed * self.direction;
		}
		if (self.x < -200 || self.x > 2248 || self.y > 4000) {
			if (self.frozen) {
				LK.getSound('breakIce').play();
			}
			self.active = false;
		}
	};
	self.startFalling = function () {
		self.falling = true;
		self.frozen = true;
		var airplaneGraphics = self.children[0];
		var originalScaleX = airplaneGraphics.scaleX;
		var originalScaleY = airplaneGraphics.scaleY;
		airplaneGraphics.destroy();
		var frozenGraphics = self.attachAsset('frezze-airplane', {
			anchorX: 0.5,
			anchorY: 0.5,
			scaleX: 1,
			scaleY: 1
		});
		tween(frozenGraphics, {
			tint: 0x87CEEB
		}, {
			duration: 300,
			easing: tween.easeOut
		});
		var trembleCount = 0;
		var maxTrembles = 30;
		var trembleIntensity = 15;
		function createTrembling() {
			if (trembleCount < maxTrembles) {
				trembleCount++;
				var offsetX = (Math.random() - 0.5) * trembleIntensity;
				var offsetY = (Math.random() - 0.5) * trembleIntensity;
				tween(self, {
					x: self.x + offsetX,
					y: self.y + offsetY
				}, {
					duration: 33,
					easing: tween.linear,
					onFinish: function onFinish() {
						createTrembling();
					}
				});
			} else {
				self.fallVelocityX = self.speed * self.direction * 0.5;
				self.fallVelocityY = 1;
				LK.getSound('planefall').play();
			}
		}
		createTrembling();
	};
	// Caída sin congelar (para estrellas normales)
	self.startFallingNoFreeze = function () {
		self.falling = true;
		self.frozen = false;
		self.fallVelocityX = self.speed * self.direction * 0.5;
		self.fallVelocityY = 1;
	};
	return self;
});
var Alert = Container.expand(function () {
	var self = Container.call(this);
	var alertGraphics = self.attachAsset('alert', {
		anchorX: 0.5,
		anchorY: 0.5,
		scaleX: 0.1,
		scaleY: 0.1
	});
	alertGraphics.scaleX = 0.1;
	alertGraphics.scaleY = 0.1;
	self.active = true;
	self.lifeTimer = 0;
	self.maxLifetime = 180;
	tween(alertGraphics, {
		scaleX: 4,
		scaleY: 4
	}, {
		duration: 200,
		easing: tween.easeOut,
		onFinish: function onFinish() {
			tween(alertGraphics, {
				scaleX: 3.0,
				scaleY: 3.0
			}, {
				duration: 300,
				easing: tween.linear,
				onFinish: function onFinish() {
					tween(alertGraphics, {
						scaleX: 0.1,
						scaleY: 0.1,
						alpha: 0
					}, {
						duration: 400,
						easing: tween.easeIn
					});
				}
			});
		}
	});
	self.update = function () {
		if (!self.active) {
			return;
		}
		self.lifeTimer++;
		if (self.lifeTimer >= self.maxLifetime) {
			self.active = false;
		}
	};
	return self;
});
var Arrow = Container.expand(function () {
	var self = Container.call(this);
	var arrowGraphics = self.attachAsset('arrow', {
		anchorX: 0.5,
		anchorY: 0.5
	});
	self.velocityX = 0;
	self.velocityY = 0;
	self.speed = 5;
	self.active = true;
	self.scaleX = 3;
	self.scaleY = 3;
	tween(self, {
		scaleX: 4,
		scaleY: 4
	}, {
		duration: 1000,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		if (self.falling) {
			self.fallVelocityY = self.fallVelocityY || 0;
			self.fallVelocityY += 0.8;
			self.x += self.fallVelocityX;
			self.y += self.fallVelocityY;
			arrowGraphics.rotation += self.spinSpeed;
		} else {
			self.x += self.velocityX;
			self.y += self.velocityY;
			var angle = Math.atan2(self.velocityY, self.velocityX);
			arrowGraphics.rotation = angle;
		}
		if (self.x < -100 || self.x > 2148 || self.y < WORLD_MIN_Y || self.y > SCREEN_HEIGHT + 600) {
			self.active = false;
		}
	};
	self.startFalling = function () {
		self.falling = true;
		var direction = Math.random() < 0.5 ? -1 : 1;
		self.fallVelocityX = direction * (Math.random() * 4 + 2);
		self.fallVelocityY = -(Math.random() * 3 + 1);
		self.spinSpeed = (Math.random() * 0.3 + 0.2) * direction;
		tween.stop(self);
	};
	return self;
});
var CasaNinja = Container.expand(function () {
	var self = Container.call(this);
	var casaGraphics = self.attachAsset('casaNinja', {
		anchorX: 0.5,
		anchorY: 1.0
	});
	self.speed = 3;
	self.active = true;
	self.baseX = 1024;
	self.isOpen = true;
	self.scaleX = 0.1;
	self.scaleY = 0.1;
	tween(self, {
		scaleX: 1,
		scaleY: 1
	}, {
		duration: 700,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		var p = computePerspective(self.z, self.speed);
		self.z = p.newZ;
		var scale = p.scale;
		var perspectiveY = p.perspectiveY;
		self.y = perspectiveY;
		self.x = self.baseX;
		var casaScale = scale * 2.0;
		self.scaleX = casaScale;
		self.scaleY = casaScale;
		if (self.z <= -500 || self.y > 3000) {
			self.active = false;
		}
	};
	self.changeState = function (isOpen) {
		self.isOpen = isOpen;
		if (isOpen) {
			casaGraphics.destroy();
			casaGraphics = self.attachAsset('casaNinja', {
				anchorX: 0.5,
				anchorY: 1.0
			});
		} else {
			casaGraphics.destroy();
			casaGraphics = self.attachAsset('casaNinjaCerrada', {
				anchorX: 0.5,
				anchorY: 1.0
			});
		}
	};
	return self;
});
var Cloud = Container.expand(function () {
	var self = Container.call(this);
	var cloudGraphics = self.attachAsset('cloud', {
		anchorX: 0.5,
		anchorY: 0.5,
		scaleX: 1.5,
		scaleY: 1.5
	});
	self.speed = 2;
	self.active = true;
	self.scaleX = 0.05;
	self.scaleY = 0.05;
	cloudGraphics.alpha = 0.1;
	tween(self, {
		scaleX: 0.3,
		scaleY: 0.3
	}, {
		duration: 800,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.z = self.z || 2000;
		self.z -= self.speed;
		var distanceProgress = (2000 - self.z) / 2000;
		var scale = 0.02 + distanceProgress * 1.8;
		var alpha = Math.min(1.0, 0.3 + distanceProgress * 0.7);
		cloudGraphics.alpha = alpha;
		self.baseY = self.baseY || self.y;
		var horizonCloudY = self.baseY;
		var escapeFactor = distanceProgress * distanceProgress;
		var maxEscapeHeight = 950;
		self.y = horizonCloudY - escapeFactor * maxEscapeHeight;
		self.scaleX = scale;
		self.scaleY = scale;
		var screenCenter = SCREEN_CENTER_X;
		self.baseX = self.baseX || self.x;
		var distanceFromCenter = self.baseX - screenCenter;
		var spreadFactor = distanceProgress * distanceProgress * 2;
		var horizontalOffset = distanceFromCenter * spreadFactor;
		self.x = self.baseX + horizontalOffset;
		var shouldDestroy = false;
		if (self.z <= -100) {
			shouldDestroy = true;
		}
		if (self.y < WORLD_MIN_Y) {
			shouldDestroy = true;
		}
		if (self.x < WORLD_MIN_X || self.x > WORLD_MAX_X) {
			shouldDestroy = true;
		}
		if (shouldDestroy) {
			self.active = false;
		}
	};
	return self;
});
var CloudType3 = Container.expand(function () {
	var self = Container.call(this);
	var cloudGraphics = self.attachAsset('cloudType3', {
		anchorX: 0.5,
		anchorY: 0.5,
		scaleX: 1.5,
		scaleY: 1.5
	});
	self.speed = 2;
	self.active = true;
	self.scaleX = 0.05;
	self.scaleY = 0.05;
	cloudGraphics.alpha = 0.1;
	tween(self, {
		scaleX: 0.3,
		scaleY: 0.3
	}, {
		duration: 800,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.z = self.z || 2000;
		self.z -= self.speed;
		var distanceProgress = (2000 - self.z) / 2000;
		var scale = 0.02 + distanceProgress * 2.1;
		var alpha = Math.min(1.0, 0.3 + distanceProgress * 0.7);
		cloudGraphics.alpha = alpha;
		self.baseY = self.baseY || self.y;
		var horizonCloudY = self.baseY;
		var escapeFactor = distanceProgress * distanceProgress;
		var maxEscapeHeight = 1100;
		self.y = horizonCloudY - escapeFactor * maxEscapeHeight;
		self.scaleX = scale;
		self.scaleY = scale;
		var screenCenter = SCREEN_CENTER_X;
		self.baseX = self.baseX || self.x;
		var distanceFromCenter = self.baseX - screenCenter;
		var spreadFactor = distanceProgress * distanceProgress * 2.2;
		var horizontalOffset = distanceFromCenter * spreadFactor;
		self.x = self.baseX + horizontalOffset;
		var shouldDestroy = false;
		if (self.z <= -100) {
			shouldDestroy = true;
		}
		if (self.y < -100) {
			shouldDestroy = true;
		}
		if (self.x < -500 || self.x > 2548) {
			shouldDestroy = true;
		}
		if (shouldDestroy) {
			self.active = false;
		}
	};
	return self;
});
var EnemyArcher = Container.expand(function () {
	var self = Container.call(this);
	var archerGraphics = self.attachAsset('archer-ninja', {
		anchorX: 0.5,
		anchorY: 1.0
	});
	self.active = true;
	self.tree = null;
	self.shootTimer = 0;
	self.detectionRange = 20000;
	self.lastDistance = null;
	self.frozen = false;
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		if (self.falling) {
			if (self.children[0] && self.children[0].texture && self.children[0].texture.name !== 'archer-ninja-full-body') {
				var currentScaleX = self.children[0].scaleX;
				var currentScaleY = self.children[0].scaleY;
				var currentTint = self.children[0].tint;
				var currentRotation = self.children[0].rotation;
				self.children[0].destroy();
				var fullBodyGraphics = self.attachAsset('archer-ninja-full-body', {
					anchorX: 0.5,
					anchorY: 1.0
				});
				fullBodyGraphics.scaleX = currentScaleX;
				fullBodyGraphics.scaleY = currentScaleY;
				fullBodyGraphics.tint = currentTint;
				fullBodyGraphics.rotation = currentRotation;
			}
			self.velocityY += 0.8;
			self.x += self.velocityX;
			self.y += self.velocityY;
			if (self.falling && self.y > 2800 || !self.falling && self.y > 4000) {
				if (self.frozen) {
					LK.getSound('breakIce').play();
				}
				self.active = false;
			}
			return;
		}
		if (self.tree && self.tree.active) {
			self.x = self.tree.x;
			self.y = self.tree.y - self.tree.scaleY * 300;
			self.scaleX = self.tree.scaleX * 0.4;
			self.scaleY = self.tree.scaleY * 0.4;
			if (ninja) {
				var dx = ninja.x - self.x;
				var dy = ninja.y - self.y;
				var distance = Math.sqrt(dx * dx + dy * dy);
				var heightDifference = Math.abs(dy);
				var isNinjaAtGroundLevel = !ninja.isJumping && ninja.y >= ninja.groundY - 50;
				var isSameHeight = heightDifference < 500;
				var horizontalDistance = Math.abs(dx);
				var isInRange = horizontalDistance < 2000 && distance < self.detectionRange;
				if (isNinjaAtGroundLevel && isSameHeight && isInRange) {
					self.shootArrow();
				}
			}
		} else {
			self.active = false;
		}
	};
	self.shootArrow = function () {
		if (!ninja) {
			return;
		}
		if (self.lastShotTime && LK.ticks - self.lastShotTime < 180) {
			return;
		}
		var arrow = new Arrow();
		arrow.x = self.x;
		arrow.y = self.y;
		var dx = ninja.x - arrow.x;
		var dy = ninja.y - arrow.y;
		var distance = Math.sqrt(dx * dx + dy * dy);
		arrow.velocityX = dx / distance * arrow.speed;
		arrow.velocityY = dy / distance * arrow.speed;
		if (typeof arrows === 'undefined') {
			arrows = [];
		}
		arrows.push(arrow);
		game.addChild(arrow);
		self.lastShotTime = LK.ticks;
		LK.getSound('archer-shoot').play();
		var archerGraphics = self.children[0];
		tween(archerGraphics, {
			scaleX: archerGraphics.scaleX * 1.2,
			scaleY: archerGraphics.scaleY * 1.2
		}, {
			duration: 200,
			easing: tween.easeOut,
			onFinish: function onFinish() {
				tween(archerGraphics, {
					scaleX: archerGraphics.scaleX / 1.2,
					scaleY: archerGraphics.scaleY / 1.2
				}, {
					duration: 300,
					easing: tween.easeIn
				});
			}
		});
	};
	return self;
});
// Segmentos de carril verde a los lados del camino central
var GreenLaneSegment = Container.expand(function () {
	var self = Container.call(this);
	var gfx = self.attachAsset('greenBackground', {
		anchorX: 0.5,
		anchorY: 0.5
	});
	self.speed = 3;
	self.active = true;
	self.baseX = 1024;
	self.side = 1; // 1 derecha, -1 izquierda
	self.colIndex = 0; // columna desde el borde del camino
	self.laneInsetBase = 220; // separación base respecto al borde del camino (alejado del centro)
	self.laneScaleX = 3.0; // estirado horizontal para cubrir más ancho
	self.laneScaleY = 2.2; // estirado vertical para mayor presencia
	self.z = 1000;
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		var p = computePerspective(self.z, self.speed);
		self.z = p.newZ;
		var scale = p.scale;
		var perspectiveY = p.perspectiveY;
		self.y = perspectiveY - 20;
		// Usar el ancho lógico de las tablas para alinear carril y cubrir toda la pantalla con columnas
		var plankWidth = 400 * scale * 2;
		var plankBoundary = plankWidth / 2;
		var laneInset = self.laneInsetBase * scale; // separación adicional respecto al borde del camino
		// Ancho del tile verde en mundo (aprox usando tileWidth global y escala X aplicada)
		var tileWorldWidth = (typeof tileWidth === 'number' ? tileWidth : 137) * scale * self.laneScaleX;
		var colStep = tileWorldWidth * 0.85; // solape mayor para evitar huecos
		var offsetFromRoadEdge = plankBoundary + laneInset + self.colIndex * colStep;
		self.x = self.baseX + offsetFromRoadEdge * self.side;
		self.scaleX = scale * self.laneScaleX;
		self.scaleY = scale * self.laneScaleY;
		if (self.y > SCREEN_HEIGHT + 400) {
			self.active = false;
		}
	};
	return self;
});
var IceStar = Container.expand(function () {
	var self = Container.call(this);
	var starGraphics = self.attachAsset('Ice-horiuken', {
		anchorX: 0.5,
		anchorY: 0.5,
		scaleX: 1.5,
		scaleY: 1.5
	});
	self.velocityX = 0;
	self.velocityY = 0;
	self.speed = 12;
	self.active = true;
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.x += self.velocityX;
		self.y += self.velocityY;
		if (ninja) {
			var dx = ninja.x - self.x;
			var dy = ninja.y - self.y;
			var distance = Math.sqrt(dx * dx + dy * dy);
			var maxDistance = 1500;
			var minScale = 0.1;
			var maxScale = 1.0;
			var normalizedDistance = Math.min(distance / maxDistance, 1);
			var scale = maxScale - normalizedDistance * (maxScale - minScale);
			self.scaleX = scale;
			self.scaleY = scale;
		}
		if (self.x < -100 || self.x > 2148 || self.y < WORLD_MIN_Y || self.y > SCREEN_HEIGHT + 600) {
			self.active = false;
		}
	};
	return self;
});
var Lightning = Container.expand(function () {
	var self = Container.call(this);
	var lightningGraphics = self.attachAsset('lightning', {
		anchorX: 0.5,
		anchorY: 0
	});
	self.active = true;
	self.lifeTimer = 0;
	self.maxLifetime = 120;
	self.flickerTimer = 0;
	self.visible = true;
	lightningGraphics.alpha = 0;
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.lifeTimer++;
		self.flickerTimer++;
		if (self.flickerTimer <= 30) {
			if (self.flickerTimer % 3 === 0) {
				self.visible = !self.visible;
				lightningGraphics.alpha = self.visible ? 1 : 0;
			}
		} else if (self.flickerTimer <= 60) {
			if (self.flickerTimer % 6 === 0) {
				self.visible = !self.visible;
				lightningGraphics.alpha = self.visible ? 0.8 : 0;
			}
		} else if (self.flickerTimer <= 90) {
			if (self.flickerTimer % 10 === 0) {
				self.visible = !self.visible;
				lightningGraphics.alpha = self.visible ? 0.5 : 0;
			}
		} else {
			var fadeProgress = (self.flickerTimer - 90) / 30;
			lightningGraphics.alpha = Math.max(0, 0.3 * (1 - fadeProgress));
		}
		self.stretchTo();
		if (self.lifeTimer >= self.maxLifetime) {
			self.active = false;
		}
	};
	self.stretchTo = function () {
		if (!ninja || !self.sourceCloud) {
			return;
		}
		var cloud = self.sourceCloud;
		var cloudBottomX = cloud.x;
		var cloudBottomY = cloud.y + 98.83;
		var ninjaTopX = ninja.x;
		var ninjaTopY = ninja.y - 538.95;
		var dx = ninjaTopX - cloudBottomX;
		var dy = ninjaTopY - cloudBottomY;
		var distance = Math.sqrt(dx * dx + dy * dy);
		var angle = Math.atan2(dy, dx) - Math.PI / 2;
		self.x = cloudBottomX;
		self.y = cloudBottomY;
		lightningGraphics.scaleY = distance / 50;
		lightningGraphics.rotation = angle;
		lightningGraphics.scaleX = 2;
	};
	return self;
});
var Meteorite = Container.expand(function () {
	var self = Container.call(this);
	var meteoriteGraphics = self.attachAsset('meteor', {
		anchorX: 0.5,
		anchorY: 0.5
	});
	self.active = true;
	self.speed = 3;
	self.velocityX = 0;
	self.velocityY = 0;
	self.hitCount = 0;
	self.scaleX = 0.05;
	self.scaleY = 0.05;
	self.changeFace = function () {
		LK.getSound('meterito-voltea').play();
		meteoriteGraphics.destroy();
		if (self.hitCount === 1) {
			meteoriteGraphics = self.attachAsset('meteorHit1', {
				anchorX: 0.5,
				anchorY: 0.5
			});
		} else if (self.hitCount === 2) {
			meteoriteGraphics = self.attachAsset('meteorHit2', {
				anchorX: 0.5,
				anchorY: 0.5
			});
		}
	};
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.x += self.velocityX;
		self.y += self.velocityY;
		self.lifeTime = self.lifeTime || 0;
		self.lifeTime++;
		var maxLifeTime = 200;
		var minScale = 0.05;
		var maxScale = 2.5;
		var progress = Math.min(self.lifeTime / maxLifeTime, 1);
		var scale = minScale + progress * (maxScale - minScale);
		self.scaleX = scale;
		self.scaleY = scale;
		if (self.x < -100 || self.x > 2148 || self.y < WORLD_MIN_Y || self.y > SCREEN_HEIGHT + 600) {
			self.active = false;
		}
	};
	return self;
});
var Ninja = Container.expand(function () {
	var self = Container.call(this);
	var ninjaGraphics = self.attachAsset('ninja', {
		anchorX: 0.5,
		anchorY: 1.0
	});
	self.groundY = 2673;
	self.isJumping = false;
	self.jumpVelocity = 0;
	self.jumpSpeed = -45;
	self.gravity = 0.8;
	self.maxJumpHeight = 1800;
	self.runningTimer = 0;
	self.flipDirection = 1;
	self.jumpCount = 0;
	self.maxJumps = 2;
	self.jump = function () {
		if (self.jumpCount < self.maxJumps && !ninjaParalyzed) {
			self.jumpCount++;
			self.isJumping = true;
			LK.getSound('jump').play();
			self.checkObstacleJump();
			if (self.jumpCount === 2) {
				if (self.children[0]) {
					tween.stop(self.children[0]);
					self.children[0].destroy();
					var jumpGraphics = self.attachAsset('ninja-jump', {
						anchorX: 0.5,
						anchorY: 0.5
					});
				}
				var jumpHeight = self.y - 500;
				var totalJumpDuration = 800;
				if (self.children[0]) {
					tween(self.children[0], {
						rotation: self.children[0].rotation + Math.PI * 6
					}, {
						duration: totalJumpDuration,
						easing: tween.linear
					});
				}
			} else {
				if (self.children[0]) {
					self.children[0].destroy();
				}
				var jumpGraphics = self.attachAsset('ninja-jump', {
					anchorX: 0.5,
					anchorY: 0.5
				});
				var jumpHeight = self.maxJumpHeight;
				var totalJumpDuration = 800;
				if (self.children[0]) {
					tween(self.children[0], {
						rotation: Math.PI * 6
					}, {
						duration: totalJumpDuration,
						easing: tween.linear
					});
				}
			}
			tween(self, {
				y: jumpHeight
			}, {
				duration: 400,
				easing: tween.easeOut,
				onFinish: function onFinish() {
					tween(self, {
						y: self.groundY
					}, {
						duration: 400,
						easing: tween.easeIn,
						onFinish: function onFinish() {
							self.isJumping = false;
							self.jumpVelocity = 0;
							self.jumpCount = 0;
							if (self.children[0]) {
								tween.stop(self.children[0]);
								self.children[0].destroy();
							}
							var normalGraphics = self.attachAsset('ninja', {
								anchorX: 0.5,
								anchorY: 1.0
							});
							normalGraphics.rotation = 0;
						}
					});
				}
			});
		}
	};
	self.update = function () {
		if (game.paused) {
			return;
		}
		self.runningTimer++;
		if (self.runningTimer >= 30) {
			self.flipDirection = -self.flipDirection;
			if (self.children[0]) {
				self.children[0].scaleX = self.flipDirection;
			}
			self.runningTimer = 0;
		}
	};
	self.checkObstacleJump = function () {
		for (var i = 0; i < obstacles.length; i++) {
			var obstacle = obstacles[i];
			if (obstacle.active) {
				if (obstacle.y > 2500 && obstacle.y < 2700) {
					var distanceX = Math.abs(obstacle.x - self.x);
					if (distanceX < 200) {
						LK.setScore(LK.getScore() + 50);
						updateScore();
						LK.getSound('jump').play();
						return;
					}
				}
			}
		}
	};
	return self;
});
var NinjaStar = Container.expand(function () {
	var self = Container.call(this);
	var starGraphics = self.attachAsset('ninjastar', {
		anchorX: 0.5,
		anchorY: 0.5
	});
	self.velocityX = 0;
	self.velocityY = 0;
	self.speed = 12;
	self.active = true;
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.x += self.velocityX;
		self.y += self.velocityY;
		if (ninja) {
			var dx = ninja.x - self.x;
			var dy = ninja.y - self.y;
			var distance = Math.sqrt(dx * dx + dy * dy);
			var maxDistance = 1500;
			var minScale = 0.2;
			var maxScale = 1.5;
			var normalizedDistance = Math.min(distance / maxDistance, 1);
			var scale = maxScale - normalizedDistance * (maxScale - minScale);
			self.scaleX = scale;
			self.scaleY = scale;
		}
		starGraphics.rotation += Math.PI * 2 / 45;
		if (self.x < -100 || self.x > 2148 || self.y < -100 || self.y > 3332) {
			self.active = false;
		}
	};
	return self;
});
var PowerUp = Container.expand(function () {
	var self = Container.call(this);
	var powerupGraphics = self.attachAsset('powerup1', {
		anchorX: 0.5,
		anchorY: 0.5,
		y: 100,
		scaleX: 2.5,
		scaleY: 2.5
	});
	var parachuteGraphics = self.attachAsset('parachute', {
		anchorX: 0.5,
		anchorY: 1.0,
		y: 40,
		scaleX: 2.5,
		scaleY: 2.5
	});
	self.active = true;
	self.fallSpeed = 2;
	self.swayAmount = 1;
	self.swayTimer = 0;
	self.powerupType = 1;
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.y += self.fallSpeed;
		self.swayTimer += 0.1;
		var targetX = ninja.x + Math.sin(self.swayTimer) * self.swayAmount * 20;
		var dx = targetX - self.x;
		self.x += dx * 0.02;
		parachuteGraphics.rotation = Math.sin(self.swayTimer) * 0.2;
		if (self.y > 3232 || self.x < -100 || self.x > 2148) {
			self.active = false;
		}
	};
	self.setPowerUpType = function (type) {
		self.powerupType = type;
		powerupGraphics.destroy();
		if (type === 1) {
			powerupGraphics = self.attachAsset('powerup1', {
				anchorX: 0.5,
				anchorY: 0.5,
				y: 100,
				scaleX: 2.5,
				scaleY: 2.5
			});
		} else if (type === 2) {
			powerupGraphics = self.attachAsset('powerup2', {
				anchorX: 0.5,
				anchorY: 0.5,
				y: 100,
				scaleX: 2.5,
				scaleY: 2.5
			});
		}
		var tempParachute = parachuteGraphics;
		self.removeChild(parachuteGraphics);
		self.addChild(tempParachute);
	};
	return self;
});
var Tori = Container.expand(function () {
	var self = Container.call(this);
	var toriGraphics = self.attachAsset('tori', {
		anchorX: 0.5,
		anchorY: 1.0
	});
	self.speed = 3;
	self.active = true;
	self.baseX = 1024;
	self.scaleX = 0.1;
	self.scaleY = 0.1;
	tween(self, {
		scaleX: 1,
		scaleY: 1
	}, {
		duration: 700,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		var p = computePerspective(self.z, self.speed);
		self.z = p.newZ;
		var scale = p.scale;
		var perspectiveY = p.perspectiveY;
		self.y = perspectiveY;
		self.x = self.baseX;
		var toriScale = scale * 2.0;
		self.scaleX = toriScale;
		self.scaleY = toriScale;
		if (self.z <= -500 || self.y > 3000) {
			self.active = false;
		}
	};
	return self;
});
var WoodenPlank = Container.expand(function () {
	var self = Container.call(this);
	var plankGraphics = self.attachAsset('woodenPlank', {
		anchorX: 0.5,
		anchorY: 0.5
	});
	self.speed = 3;
	self.active = true;
	self.baseX = 1024;
	self.side = 0;
	// Inicial sin tween de aparición para mantener regularidad
	self.scaleX = 1;
	self.scaleY = 1;
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		var p = computePerspective(self.z, self.speed);
		self.z = p.newZ;
		var scale = p.scale;
		var perspectiveY = p.perspectiveY;
		self.y = perspectiveY - 20;
		self.x = self.baseX;
		self.scaleX = scale * 2;
		self.scaleY = scale * 1.665;
		var plankTopY = self.y - self.scaleY * 20;
		if (plankTopY > 2732) {
			self.active = false;
		}
	};
	return self;
});
var WoodenStar = Container.expand(function () {
	var self = Container.call(this);
	var starGraphics = self.attachAsset('wooden-start', {
		anchorX: 0.5,
		anchorY: 0.5
	});
	self.velocityX = 0;
	self.velocityY = 0;
	self.speed = 12;
	self.active = true;
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.x += self.velocityX;
		self.y += self.velocityY;
		if (ninja) {
			var dx = ninja.x - self.x;
			var dy = ninja.y - self.y;
			var distance = Math.sqrt(dx * dx + dy * dy);
			var maxDistance = 1500;
			var minScale = 0.1;
			var maxScale = 1.0;
			var normalizedDistance = Math.min(distance / maxDistance, 1);
			var scale = maxScale - normalizedDistance * (maxScale - minScale);
			self.scaleX = scale;
			self.scaleY = scale;
		}
		var screenMiddle = SCREEN_HALFY;
		if (self.x < -100 || self.x > 2148 || self.y < screenMiddle || self.y > 3332) {
			self.active = false;
		}
	};
	return self;
});
var electroCloud = Container.expand(function () {
	var self = Container.call(this);
	var cloudGraphics = self.attachAsset('cloudType2', {
		anchorX: 0.5,
		anchorY: 0.5,
		scaleX: 0.75,
		scaleY: 0.75,
		alpha: 0
	});
	var inactiveCloudGraphics = self.attachAsset('cloudInactive', {
		anchorX: 0.5,
		anchorY: 0.5,
		scaleX: 1,
		scaleY: 1,
		alpha: 1
	});
	self.speed = 2;
	self.active = true;
	self.isCharged = false;
	self.chargeTimer = 0;
	self.interactionRange = 150;
	self.scaleX = 0.05;
	self.scaleY = 0.05;
	cloudGraphics.alpha = 0;
	inactiveCloudGraphics.alpha = 1;
	tween(self, {
		scaleX: 0.3,
		scaleY: 0.3
	}, {
		duration: 800,
		easing: tween.easeOut
	});
	self.update = function () {
		if (!self.active || game.paused) {
			return;
		}
		self.z = self.z || 2000;
		self.z -= self.speed;
		var distanceProgress = (2000 - self.z) / 2000;
		var isInInteractionRange = distanceProgress > 0.3 && distanceProgress < 0.7;
		if (isInInteractionRange && !self.isCharged) {
			self.isCharged = true;
			self.chargeTimer = 0;
			cloudGraphics.alpha = 1;
			inactiveCloudGraphics.alpha = 0;
			LK.getSound('electric-cloud-hit').play();
		}
		if (self.isCharged) {
			self.chargeTimer++;
			if (self.chargeTimer % 15 === 0) {
				var lightningTint = 0x00FFFF;
				tween(cloudGraphics, {
					tint: lightningTint
				}, {
					duration: 100,
					easing: tween.easeInOut,
					onFinish: function onFinish() {
						tween(cloudGraphics, {
							tint: 0xFFFFFF
						}, {
							duration: 100,
							easing: tween.easeInOut
						});
					}
				});
			}
		} else if (!self.isCharged) {
			self.flickerTimer = self.flickerTimer || 0;
			self.flickerTimer++;
			if (self.flickerTimer % 45 === 0) {
				var distantTint = 0xCCCCCC;
				tween(inactiveCloudGraphics, {
					tint: distantTint
				}, {
					duration: 200,
					easing: tween.easeInOut,
					onFinish: function onFinish() {
						tween(inactiveCloudGraphics, {
							tint: 0xFFFFFF
						}, {
							duration: 200,
							easing: tween.easeInOut
						});
					}
				});
			}
		}
		var baseAlpha = Math.min(1.0, 0.3 + distanceProgress * 0.7);
		var finalAlpha = self.isCharged ? baseAlpha : baseAlpha * 0.6;
		if (self.isCharged) {
			cloudGraphics.alpha = finalAlpha;
			inactiveCloudGraphics.alpha = 0;
		} else {
			cloudGraphics.alpha = 0;
			inactiveCloudGraphics.alpha = finalAlpha;
		}
		self.baseY = self.baseY || self.y;
		var horizonCloudY = self.baseY;
		var escapeFactor = distanceProgress * distanceProgress;
		var maxEscapeHeight = 1000;
		self.y = horizonCloudY - escapeFactor * maxEscapeHeight;
		var scale = 0.02 + distanceProgress * 1.9;
		self.scaleX = scale;
		self.scaleY = scale;
		var screenCenter = 1024;
		self.baseX = self.baseX || self.x;
		var distanceFromCenter = self.baseX - screenCenter;
		var spreadFactor = distanceProgress * distanceProgress * 1.8;
		var horizontalOffset = distanceFromCenter * spreadFactor;
		self.x = self.baseX + horizontalOffset;
		var shouldDestroy = false;
		if (self.z <= -100) {
			shouldDestroy = true;
		}
		if (self.y < WORLD_MIN_Y) {
			shouldDestroy = true;
		}
		if (self.x < WORLD_MIN_X || self.x > WORLD_MAX_X) {
			shouldDestroy = true;
		}
		if (shouldDestroy) {
			self.active = false;
		}
	};
	self.intersects = function (target) {
		if (!self.isCharged) {
			return false;
		}
		var dx = target.x - self.x;
		var dy = target.y - self.y;
		var distance = Math.sqrt(dx * dx + dy * dy);
		var interactionDistance = self.interactionRange * self.scaleX;
		return distance <= interactionDistance;
	};
	return self;
});

/**** 
* Initialize Game
****/
var game = new LK.Game({
	backgroundColor: 0x00BFFF
});

/**** 
* Game Code
****/
function createEnemyClass(assetId, minScale, maxScale, alwaysBodyFallOnExit) {
	return Container.expand(function () {
		var self = Container.call(this);
		var enemyGraphics = self.attachAsset(assetId, {
			anchorX: 0.5,
			anchorY: 0.5
		});
		self.active = true;
		self.velocityX = 0;
		self.velocityY = 0;
		self.gravity = 0.15;
		self.isJumping = true;
		self.groundY = 2532;
		self.frozen = false;
		self.scaleX = 1.0;
		self.scaleY = 1.0;
		self.update = function () {
			if (!self.active || game.paused) {
				return;
			}
			if (self.falling) {
				self.velocityY += 0.8;
			} else {
				self.velocityY += self.gravity;
			}
			self.x += self.velocityX;
			self.y += self.velocityY;
			if (ninja) {
				var dx = ninja.x - self.x;
				var dy = ninja.y - self.y;
				var distance = Math.sqrt(dx * dx + dy * dy);
				var maxDistance = 1500;
				var normalizedDistance = Math.min(distance / maxDistance, 1);
				var targetScale = maxScale - normalizedDistance * (maxScale - minScale);
				if (Math.abs(self.scaleX - targetScale) > 0.05) {
					tween(self, {
						scaleX: targetScale,
						scaleY: targetScale
					}, {
						duration: 100,
						easing: tween.easeOut
					});
				}
			}
			if (!self.frozen && !self.falling && self.y >= self.groundY) {
				self.y = self.groundY;
				self.velocityY = 0;
				self.isJumping = false;
			}
			if (self.x < -200 || self.x > 2248 || self.falling && self.y > 2800 || !self.falling && self.y > 4000) {
				if (self.frozen) {
					LK.getSound('breakIce').play();
				}
				if (alwaysBodyFallOnExit || !self.frozen) {
					LK.getSound('bodyFall').play();
				}
				self.active = false;
			}
		};
		return self;
	});
}
var Enemy = createEnemyClass('enemy', 1.5, 2.0, true);
var Enemy2 = createEnemyClass('Enemy2', 1.0, 4.0, false);
var Enemy3 = createEnemyClass('Enemy3', 1.0, 4.0, false);
function createObstacleClass(assetId, scaleMultiplier) {
	return Container.expand(function () {
		var self = Container.call(this);
		var obstacleGraphics = self.attachAsset(assetId, {
			anchorX: 0.5,
			anchorY: 1.0
		});
		self.speed = 3;
		self.active = true;
		self.baseX = 1024;
		self.side = 0;
		self.scaleX = 0.1;
		self.scaleY = 0.1;
		tween(self, {
			scaleX: 1,
			scaleY: 1
		}, {
			duration: 600,
			easing: tween.easeOut
		});
		self.update = function () {
			if (!self.active || game.paused) {
				return;
			}
			var p = computePerspective(self.z, self.speed);
			self.z = p.newZ;
			var scale = p.scale;
			var perspectiveY = p.perspectiveY;
			self.y = perspectiveY - 35;
			self.x = self.baseX;
			self.scaleX = scale * scaleMultiplier;
			self.scaleY = scale * scaleMultiplier;
			if (self.z <= -500 || self.y > 3000) {
				self.active = false;
			}
		};
		return self;
	});
}
var Obstacle = createObstacleClass('obstacle', 1.33);
var RockObstacle = createObstacleClass('rockObstacle', 1.33);
function createTreeClass(assetId) {
	return Container.expand(function () {
		var self = Container.call(this);
		var treeGraphics = self.attachAsset(assetId, {
			anchorX: 0.5,
			anchorY: 1.0
		});
		self.speed = 3;
		self.active = true;
		self.baseX = 1024;
		self.side = 1;
		self.scaleX = 0;
		self.scaleY = 0;
		treeGraphics.alpha = 0;
		tween(self, {
			scaleX: 1,
			scaleY: 1
		}, {
			duration: 800,
			easing: tween.easeOut
		});
		tween(treeGraphics, {
			alpha: 1
		}, {
			duration: 800,
			easing: tween.easeOut
		});
		self.update = function () {
			if (!self.active || game.paused || isInCasaNinja) {
				return;
			}
			var p = computePerspective(self.z, self.speed);
			self.z = p.newZ;
			var scale = p.scale;
			var perspectiveY = p.perspectiveY;
			self.y = perspectiveY;
			var plankWidth = 400 * scale * 2;
			var plankBoundary = plankWidth / 2;
			var extraSeparation = 300 * scale;
			self.x = self.baseX + (plankBoundary + extraSeparation) * self.side;
			var treeScale = scale * 1.73;
			self.scaleX = treeScale;
			self.scaleY = treeScale;
			if (self.z <= -500 || self.x < -300 || self.x > 2348 || self.y > 3400) {
				self.active = false;
			}
		};
		return self;
	});
}
var Tree = createTreeClass('tree');
var TreeType2 = createTreeClass('treeType2');
var TreeType3 = createTreeClass('treeType3');
var mushroomObstacle = createObstacleClass('spikeObstacle', 1.0);
var ninja;
var ninjaStars = [];
var enemies = [];
var enemies2 = [];
var enemies3 = [];
var obstacles = [];
var electricalNinjas = [];
var enemySpawnTimer = 0;
var enemy2SpawnTimer = 0;
var enemy3SpawnTimer = 0;
var lastEnemySpawnSide = 0;
var lastEnemySpawnTime = 0;
var minSpawnDelay = 240;
var obstacleSpawnTimer = 0;
var swipeStartX = 0;
var swipeStartY = 0;
var isSwipeActive = false;
var clouds = [];
var cloudSpawnTimer = 0;
var trees = [];
var treeSpawnTimer = 0;
var ninjaSpawnTimer = 0;
var meteorites = [];
var lightnings = [];
var sunFaceTimer = 0;
var sunIsHit = false;
var ninjaParalyzed = false;
var ninjaParalyzeTimer = 0;
var toris = [];
var toriSpawnTimer = 0;
var woodenPlanks = [];
var lastPlankSpawnY = 0;
var plankRegularDistance = 50;
var greenLanesLeft = [];
var greenLanesRight = [];
var airplanes = [];
var airplaneSpawnTimer = 0;
var powerUps = [];
var woodenStars = [];
var hasWoodenStarPower = false;
var woodenStarPowerTimer = 0;
var woodenStarDuration = 1800;
var hasIcePower = false;
var icePowerTimer = 0;
var icePowerDuration = 1800;
var iceStars = [];
var alerts = [];
var sunFrozen = false;
var sunFrozenTimer = 0;
var sunFrozenDuration = 600;
var difficultyLevel = 1;
var gameStartTime = 0;
var enemyArchers = [];
var arrows = [];
var mainScreenActive = true;
var mainScreenTimer = 0;
var mainScreenMinTime = 180;
var mainScreenPopup;
var mainScreenMask;
var swipeStartXPopup = 0;
var swipeStartYPopup = 0;
var isSwipingPopup = false;
// --- Utilidades de colisiones y efectos (DRY) ---
// Utilidades de perspectiva/escala repetidas en varios objetos
function computePerspective(z, speed) {
	z = z || 1000;
	var distanceFactor = Math.max(0.1, 1 - (z || 1000) / 1000);
	var currentSpeed = (speed || 0) * (0.3 + distanceFactor * 2);
	var newZ = z - currentSpeed;
	var scale = Math.max(0.1, 1 - newZ / 1000);
	var perspectiveY = 1503 + (2532 - 1503) * scale;
	return {
		newZ: newZ,
		scale: scale,
		perspectiveY: perspectiveY
	};
}
function destroyProjectile(projectileArray, index, projectile) {
	projectile.active = false;
	projectile.destroy();
	projectileArray.splice(index, 1);
}
function awardPoints(points) {
	LK.setScore(LK.getScore() + points);
	if (typeof updateScore === 'function') {
		updateScore();
	}
}
function causeEnemyFall(enemy, points, soundId, isArcher) {
	enemiesKilled++;
	if (points) {
		awardPoints(points);
	}
	if (soundId) {
		LK.getSound(soundId).play();
	}
	enemy.falling = true;
	var graphics = enemy.children && enemy.children[0];
	if (graphics) {
		tween(graphics, {
			rotation: Math.PI
		}, {
			duration: 300,
			easing: tween.easeOut
		});
	}
	enemy.velocityY = -2;
	enemy.velocityX = isArcher ? 0 : enemy.velocityX * 0.3;
}
function freezeEnemyAndFall(enemy, freezeAssetId, points, options) {
	// options: { anchorY, scaleMultiplier, isArcher }
	enemiesKilled++;
	if (points) {
		awardPoints(points);
	}
	LK.getSound('Congelado').play();
	enemy.falling = true;
	enemy.frozen = true;
	var graphics = enemy.children && enemy.children[0];
	var scaleX = 1,
		scaleY = 1;
	if (graphics) {
		scaleX = graphics.scaleX;
		scaleY = graphics.scaleY;
		graphics.destroy();
	}
	var frozenGraphics = enemy.attachAsset(freezeAssetId, {
		anchorX: 0.5,
		anchorY: options && options.anchorY != null ? options.anchorY : 0.5
	});
	var mult = options && options.scaleMultiplier != null ? options.scaleMultiplier : 1.0;
	var finalScaleMultiplier = mult * 0.75; // Enemigos congelados al 75% del tamaño actual
	frozenGraphics.scaleX = scaleX * finalScaleMultiplier;
	frozenGraphics.scaleY = scaleY * finalScaleMultiplier;
	tween(frozenGraphics, {
		rotation: Math.PI,
		tint: 0x87CEEB
	}, {
		duration: 300,
		easing: tween.easeOut
	});
	enemy.velocityY = -2;
	enemy.velocityX = options && options.isArcher ? 0 : enemy.velocityX * 0.3;
}
function tryHitEnemiesWithFall(projectile, projectileArray, i, targets, points, soundId, isArcher) {
	for (var j = targets.length - 1; j >= 0; j--) {
		var target = targets[j];
		if (target.active && !target.falling && projectile.intersects(target)) {
			causeEnemyFall(target, points, soundId, isArcher);
			destroyProjectile(projectileArray, i, projectile);
			return true;
		}
	}
	return false;
}
function tryFreezeEnemiesWithFall(projectile, projectileArray, i, targets, points, freezeAssetId, options) {
	for (var j = targets.length - 1; j >= 0; j--) {
		var target = targets[j];
		if (target.active && !target.falling && projectile.intersects(target)) {
			freezeEnemyAndFall(target, freezeAssetId, points, options || {});
			destroyProjectile(projectileArray, i, projectile);
			return true;
		}
	}
	return false;
}
function handleMeteoriteHitCommon(projectile, projectileArray, i, meteorite, destroyThreshold) {
	meteorite.hitCount++;
	LK.getSound('meteoro-golpe').play();
	if (meteorite.hitCount < destroyThreshold && typeof meteorite.changeFace === 'function') {
		meteorite.changeFace();
	}
	destroyProjectile(projectileArray, i, projectile);
	if (meteorite.hitCount >= destroyThreshold) {
		meteorite.active = false;
		meteorite.destroy();
		var idx = meteorites.indexOf(meteorite);
		if (idx >= 0) {
			meteorites.splice(idx, 1);
		}
		LK.getSound('meteoro-grito').play();
		awardPoints(50);
	}
}
function tryHitArrows(projectile, projectileArray, i, arrowsArray) {
	for (var a = arrowsArray.length - 1; a >= 0; a--) {
		var arrow = arrowsArray[a];
		if (arrow.active && !arrow.falling && projectile.intersects(arrow)) {
			arrow.startFalling();
			destroyProjectile(projectileArray, i, projectile);
			return true;
		}
	}
	return false;
}
function handleAirplaneHit(projectile, projectileArray, i, airplane, opts) {
	// opts: { score, soundId, dropPowerUp }
	if (opts && opts.score) {
		awardPoints(opts.score);
	}
	if (opts && opts.dropPowerUp && typeof dropPowerUp === 'function') {
		dropPowerUp(airplane);
	}
	if (opts && opts.soundId) {
		LK.getSound(opts.soundId).play();
	}
	if (typeof airplane.startFalling === 'function') {
		airplane.startFalling();
	} else {
		airplane.falling = true;
	}
	destroyProjectile(projectileArray, i, projectile);
}
function getCurrentDifficultyLevel() {
	var timeSurvived = Math.floor((LK.ticks - gameStartTime) / 60);
	if (timeSurvived < 30) {
		return 1;
	} else if (timeSurvived < 60) {
		return 2;
	} else if (timeSurvived < 120) {
		return 3;
	} else if (timeSurvived < 180) {
		return 4;
	} else {
		return 5;
	}
}
function isFeatureUnlocked(feature) {
	var currentPhase = Math.min(casaNinjaVisitCount + 1, 4);
	switch (feature) {
		case 'obstacles':
			return currentPhase >= 2;
		case 'enemies':
			return currentPhase >= 1;
		case 'toris':
			return currentPhase >= 2;
		case 'lightningClouds':
			return currentPhase >= 3;
		case 'airplanes':
			return currentPhase >= 3;
		case 'archers':
			return currentPhase >= 4;
		case 'sun':
			return currentPhase >= 2;
		default:
			return true;
	}
}
function showCurrentPhase() {
	var currentPhase = Math.min(casaNinjaVisitCount + 1, 4);
	var phaseText = 'FASE ' + currentPhase;
	if (!game.phaseDisplay) {
		game.phaseDisplay = new Text2(phaseText, {
			size: 82,
			fill: 0x222222,
			font: "'Arial Black', 'Impact', 'Helvetica Bold', sans-serif"
		});
		game.phaseDisplay.anchor.set(0.5, 0.5);
		game.phaseDisplay.x = 1024;
		game.phaseDisplay.y = 110;
		if (!game.phaseDisplay.style) {
			game.phaseDisplay.style = {};
		}
		game.phaseDisplay.style.dropShadow = true;
		game.phaseDisplay.style.dropShadowColor = "#000000";
		game.phaseDisplay.style.dropShadowDistance = 4;
		game.phaseDisplay.style.dropShadowAngle = Math.PI / 4;
		game.addChild(game.phaseDisplay);
	}
	game.phaseDisplay.setText(phaseText);
}
function showPhaseInfo() {
	if (!isInCasaNinja || !casaNinja) {
		return;
	}
	var currentPhase = Math.min(casaNinjaVisitCount + 1, 4);
	var message = '';
	switch (currentPhase) {
		case 1:
			message = 'PHASE 1: Basic enemies and obstacles\nJump to avoid enemies and obstacles\nUse ninja stars to defeat enemies\nCollect power-ups for special abilities';
			break;
		case 2:
			message = 'PHASE 2: TORIS will appear\nDon\'t jump to pass through without damage\nJump over enemies and obstacles\nUse ninja stars strategically';
			break;
		case 3:
			message = 'PHASE 3: Electric clouds and airplanes\nBeware of lightning strikes from clouds\nAirplanes will drop power-ups\nJump to avoid obstacles and enemies';
			break;
		case 4:
			message = 'PHASE 4: Ninja archers\nKill them before they shoot arrows\nOr jump to avoid their arrows\nUse all your ninja skills to survive';
			break;
	}
	var backgroundWidth = 2048 * 0.75;
	var backgroundHeight = 2732 * 0.75;
	var backgroundX = 1024;
	var backgroundY = 1366 + 200;
	var backgroundImage = LK.getAsset('indicaciones', {
		anchorX: 0.5,
		anchorY: 0.5,
		x: backgroundX,
		y: backgroundY,
		scaleX: backgroundWidth / 100,
		scaleY: backgroundHeight / 100
	});
	var textAreaWidth = backgroundWidth * 0.9;
	var textAreaHeight = backgroundHeight * 0.9;
	var textSize = 76;
	var phaseInfo = new Text2(message, {
		size: textSize,
		fill: 0x1a1a1a,
		font: "'Arial Black', 'Impact', 'Helvetica Bold', sans-serif"
	});
	phaseInfo.anchor.set(0.5, 0.5);
	phaseInfo.x = backgroundX;
	phaseInfo.y = backgroundY;
	if (!phaseInfo.style) {
		phaseInfo.style = {};
	}
	phaseInfo.style.dropShadow = true;
	phaseInfo.style.dropShadowColor = "#000000";
	phaseInfo.style.dropShadowDistance = 4;
	phaseInfo.style.dropShadowAngle = Math.PI / 4;
	phaseInfo.style.width = textAreaWidth;
	game.addChild(backgroundImage);
	game.addChild(phaseInfo);
	LK.setTimeout(function () {
		if (phaseInfo && phaseInfo.parent) {
			phaseInfo.destroy();
		}
		if (backgroundImage && backgroundImage.parent) {
			backgroundImage.destroy();
		}
	}, 10000);
}
function showAlert() {
	if (!ninja) {
		return;
	}
	var alert = new Alert();
	alert.x = ninja.x;
	alert.y = ninja.y - 900;
	alerts.push(alert);
	game.addChild(alert);
	try {
		LK.getSound('alert-sound').play();
	} catch (e) {
		LK.getSound('jump').play();
	}
}
var greenBackgrounds = [];
var backgroundAsset = LK.getAsset('greenBackground', {});
var tileWidth = backgroundAsset.width;
var tileHeight = backgroundAsset.height;
var fieldWidth = 2048;
var horizonY = 1583;
var woodenPlankStartY = horizonY;
var fieldHeight = 2732 - woodenPlankStartY;
var perspectiveRows = 10; // menos filas por rendimiento
var tilesX = 12; // menos columnas por rendimiento
for (var row = 0; row < perspectiveRows; row++) {
	var rowProgress = row / (perspectiveRows - 1);
	var perspectiveScale = 2 + rowProgress * 6;
	var rowY = woodenPlankStartY + fieldHeight * rowProgress;
    var _loop = function _loop() {
            var tileX = col * tileWidth * perspectiveScale - tilesX * tileWidth * perspectiveScale / 2 + fieldWidth / 2;
            var tileScaleX = perspectiveScale * 2.2; // compensar reducción de columnas
            var tileScaleY = perspectiveScale;
            // culling horizontal: no crear tiles totalmente fuera de pantalla
            if (tileX + tileWidth * tileScaleX < WORLD_MIN_X - 100 || tileX > WORLD_MAX_X + 100) {
                return;
            }
            greenTile = game.addChild(LK.getAsset('greenBackground', {
                anchorX: 0,
                anchorY: 0,
                x: tileX,
                y: rowY,
                scaleX: tileScaleX,
                scaleY: tileScaleY
            }));
            greenTile.originalY = rowY;
            greenTile.perspectiveScale = perspectiveScale;
            greenTile.rowIndex = row;
            greenTile.originalX = greenTile.x;
            greenTile.colIndex = col;
            greenTile.z = 1000 * (1 - rowProgress);
            greenTile.speed = 3;
            greenBackgrounds.push(greenTile);
        },
		greenTile;
	for (var col = 0; col < tilesX; col++) {
		_loop();
	}
}
var greenLayer = game.addChildAt(LK.getAsset('grassMask', {
	anchorX: 0,
	anchorY: 0,
	x: 0,
	y: 1600,
	scaleX: 1,
	scaleY: 0.61,
	tint: 0x90EE90,
	alpha: 1
}), 0);
// Monte Fuji: detrás del césped (y delante del cielo)
var monteFuji = game.addChildAt(LK.getAsset('montefuji', {
	anchorX: 0.5,
	anchorY: 1.0,
	x: 1024,
	y: 1700,
	scaleX: 2.1,
	scaleY: 2.1,
	alpha: 1
}), 0);
var sun = game.addChild(LK.getAsset('sun', {
	anchorX: 0.5,
	anchorY: 0.5,
	x: 2500,
	y: 300,
	scaleX: 1.5,
	scaleY: 1.5,
	alpha: 0
}));
// Constantes globales de geometría/escena
var SCREEN_CENTER_X = 1024;
var WORLD_MIN_X = -500;
var WORLD_MAX_X = 2548;
var WORLD_MIN_Y = -100;
var WORLD_MAX_Y = 4000;
var HORIZON_Y = 1503;
var GROUND_Y = 2532;
var SCREEN_HEIGHT = 2732;
var SCREEN_HALFY = SCREEN_HEIGHT / 2; // 1366
for (var prePlankIndex = 0; prePlankIndex < 8; prePlankIndex++) {
	var plank = new WoodenPlank();
	plank.x = 1024;
	plank.y = horizonY;
	plank.z = 50 + prePlankIndex * 50;
	plank.baseX = 1024;
	plank.speed = 3;
	woodenPlanks.push(plank);
	var plankInsertIndex = greenBackgrounds.length + 1;
	if (plankInsertIndex > game.children.length) {
		plankInsertIndex = game.children.length;
	}
	game.addChildAt(plank, plankInsertIndex);
}
showCurrentPhase();
lastPlankSpawnY = 50 + 7 * 50;
for (var preTreeIndex = 0; preTreeIndex < 5; preTreeIndex++) {
	var leftTreeType = Math.random();
	var leftTree;
	if (leftTreeType < 0.33) {
		leftTree = new Tree();
	} else if (leftTreeType < 0.66) {
		leftTree = new TreeType2();
	} else {
		leftTree = new TreeType3();
	}
	leftTree.x = 1024;
	leftTree.y = horizonY;
	leftTree.z = 200 + preTreeIndex * 80;
	leftTree.side = -1;
	trees.push(leftTree);
	var insertIndex = greenBackgrounds.length + 2 + (4 - preTreeIndex);
	if (insertIndex > game.children.length) {
		insertIndex = game.children.length;
	}
	game.addChildAt(leftTree, insertIndex);
	var rightTreeType = Math.random();
	var rightTree;
	if (rightTreeType < 0.33) {
		rightTree = new Tree();
	} else if (rightTreeType < 0.66) {
		rightTree = new TreeType2();
	} else {
		rightTree = new TreeType3();
	}
	rightTree.x = 1024;
	rightTree.y = horizonY;
	rightTree.z = 250 + preTreeIndex * 80;
	rightTree.side = 1;
	trees.push(rightTree);
	var rightInsertIndex = greenBackgrounds.length + 2 + (4 - preTreeIndex);
	if (rightInsertIndex > game.children.length) {
		rightInsertIndex = game.children.length;
	}
	game.addChildAt(rightTree, rightInsertIndex);
}
for (var preCloudIndex = 0; preCloudIndex < 8; preCloudIndex++) {
	var cloudType = Math.random();
	var cloud;
	if (cloudType < 0.45) {
		cloud = new Cloud();
	} else if (cloudType < 0.55) {
		cloud = new electroCloud();
	} else {
		cloud = new CloudType3();
	}
	cloud.x = Math.random() * 1200 + 400;
	cloud.y = horizonY - 50 + Math.random() * 100 - 50;
	cloud.baseY = cloud.y;
	cloud.z = 500 + preCloudIndex * 200;
	clouds.push(cloud);
	var sunIndex = game.children.indexOf(sun);
	var cloudIndex = Math.min(sunIndex + 1, game.children.length);
	game.addChildAt(cloud, cloudIndex);
}
ninja = game.addChild(new Ninja());
ninja.x = 1024;
ninja.y = 2673;
var casaNinja = null;
var isInCasaNinja = false;
var casaNinjaSequenceTimer = 0;
var casaNinjaSequenceStage = 0;
var casaNinjaActivated = false;
var casaNinjaActivatedPoints = [];
var casaNinjaVisitCount = 0;
var backgroundOffsetY = 0;
var backgroundAnimationSpeed = 2;
var grassAnimationTimer = 0;
function animateGrassBackground() {
	if (isInCasaNinja) {
		tween({}, {}, {
			duration: 16,
			easing: tween.linear,
			onFinish: function onFinish() {
				animateGrassBackground();
			}
		});
		return;
	}
	if (ninja) {
		var ninjaYInfluence = (ninja.y - ninja.groundY) * 0.08;
		var ninjaMotionBoost = ninja.isJumping ? 1.5 : 1.0;
		backgroundOffsetY = ninjaYInfluence * ninjaMotionBoost + LK.ticks * 0.2;
	} else {
		backgroundOffsetY += backgroundAnimationSpeed * 4;
	}
	// Animación anterior del césped eliminada: tiles se quedan fijos
	// Conservamos el bucle temporal para no romper dependencias de tiempo
	tween({}, {}, {
		duration: 16,
		easing: tween.linear,
		onFinish: function onFinish() {
			animateGrassBackground();
		}
	});
}
animateGrassBackground();
LK.playMusic('main-theme');
var mainScreenMask = game.addChild(LK.getAsset('grassMask', {
	anchorX: 0,
	anchorY: 0,
	x: 0,
	y: 0,
	scaleX: 1,
	scaleY: 1.665,
	tint: 0x000000,
	alpha: 0.8
}));
tween(mainScreenMask, {
	alpha: 0.8
}, {
	duration: 300,
	easing: tween.easeOut
});
mainScreenPopup = game.addChild(LK.getAsset('Mainscreen', {
	anchorX: 0.5,
	anchorY: 0.5,
	x: 1024,
	y: 1366,
	scaleX: 3.0,
	scaleY: 3.0
}));
game.removeChild(mainScreenPopup);
game.addChild(mainScreenPopup);
tween(mainScreenPopup, {
	scaleX: 2.5,
	scaleY: 2.5
}, {
	duration: 300,
	easing: tween.easeOut
});
var centerUIBackground = game.addChild(LK.getAsset('center-ui-bg', {
	anchorX: 0.5,
	anchorY: 0.5,
	x: 1024,
	y: 300,
	scaleX: 4.0,
	scaleY: 4.0,
	alpha: 1
}));
var weaponIndicator = game.addChild(LK.getAsset('Arma-ui', {
	anchorX: 0.5,
	anchorY: 0.5,
	x: 300,
	y: 300,
	scaleX: 2.8,
	scaleY: 2.8,
	tint: 0x4A4A4A,
	alpha: 1
}));
var maskIndex = game.children.indexOf(mainScreenMask);
var weaponIndex = game.children.indexOf(weaponIndicator);
var centerUIIndex = game.children.indexOf(centerUIBackground);
if (maskIndex !== -1 && weaponIndex !== -1 && weaponIndex > maskIndex) {
	game.removeChild(weaponIndicator);
	game.addChildAt(weaponIndicator, maskIndex);
}
if (maskIndex !== -1 && centerUIIndex !== -1 && centerUIIndex > maskIndex) {
	game.removeChild(centerUIBackground);
	game.addChildAt(centerUIBackground, maskIndex);
}
var weaponIcon = null;
function updateWeaponIndicator() {
	if (weaponIcon) {
		weaponIcon.destroy();
	}
	if (hasIcePower) {
		weaponIcon = game.addChild(LK.getAsset('Ice-horiuken', {
			anchorX: 0.5,
			anchorY: 0.5,
			x: 300,
			y: 300,
			scaleX: 0.8,
			scaleY: 0.8
		}));
		weaponIcon.tint = 0x00BFFF;
	} else if (hasWoodenStarPower) {
		var _startWoodenStarSpinning = function startWoodenStarSpinning() {
			if (!weaponIcon || weaponIcon.destroyed || !hasWoodenStarPower) {
				return;
			}
		};
		weaponIcon = game.addChild(LK.getAsset('shoriuken3', {
			anchorX: 0.5,
			anchorY: 0.5,
			x: 300,
			y: 300,
			scaleX: 1.1,
			scaleY: 1.1
		}));
		weaponIcon.tint = 0xDAA520;
		_startWoodenStarSpinning();
	} else {
		weaponIcon = game.addChild(LK.getAsset('ninjastar', {
			anchorX: 0.5,
			anchorY: 0.5,
			x: 300,
			y: 300,
			scaleX: 1.0,
			scaleY: 1.0
		}));
		weaponIcon.tint = 0xC0C0C0;
	}
	if (weaponIcon && mainScreenMask && game.children.indexOf(mainScreenMask) !== -1) {
		var maskIndex = game.children.indexOf(mainScreenMask);
		var iconIndex = game.children.indexOf(weaponIcon);
		if (iconIndex > maskIndex) {
			game.removeChild(weaponIcon);
			game.addChildAt(weaponIcon, maskIndex);
		}
		var scoreIndex = game.children.indexOf(scoreTxt);
		var enemiesIndex = game.children.indexOf(enemiesTxt);
		if (scoreIndex > maskIndex) {
			game.removeChild(scoreTxt);
			game.addChildAt(scoreTxt, maskIndex);
		}
		if (enemiesIndex > maskIndex) {
			game.removeChild(enemiesTxt);
			game.addChildAt(enemiesTxt, maskIndex);
		}
	}
}
updateWeaponIndicator();
var scoreTxt = new Text2('0', {
	size: 76,
	fill: 0xFFD700,
	font: "'Arial Black', 'Impact', 'Helvetica Bold', sans-serif"
});
scoreTxt.anchor.set(1.0, 0.5);
scoreTxt.x = 1024 - 40;
scoreTxt.y = 345;
if (!scoreTxt.style) {
	scoreTxt.style = {};
}
scoreTxt.style.dropShadow = true;
scoreTxt.style.dropShadowColor = "#000000";
scoreTxt.style.dropShadowDistance = 4;
scoreTxt.style.dropShadowAngle = Math.PI / 4;
game.addChild(scoreTxt);
var enemiesTxt = new Text2('00000', {
	size: 76,
	fill: 0xFFD700,
	font: "'Arial Black', 'Impact', 'Helvetica Bold', sans-serif"
});
enemiesTxt.anchor.set(1.0, 0.5);
enemiesTxt.x = 1024 + 300;
enemiesTxt.y = 345;
if (!enemiesTxt.style) {
	enemiesTxt.style = {};
}
enemiesTxt.style.dropShadow = true;
enemiesTxt.style.dropShadowColor = "#000000";
enemiesTxt.style.dropShadowDistance = 4;
enemiesTxt.style.dropShadowAngle = Math.PI / 4;
game.addChild(enemiesTxt);
var enemiesKilled = 0;
var timeStarted = LK.ticks;
gameStartTime = LK.ticks;
function updateScore() {
	scoreTxt.setText(LK.getScore().toString());
	enemiesTxt.setText(enemiesKilled.toString());
}
// Índice superior de fondo (tiles de césped + máscara + Fuji)
function getBackgroundTopIndex() {
    var topIndex = -1;
    if (typeof game !== 'undefined' && game && game.children) {
        if (typeof monteFuji !== 'undefined' && monteFuji && monteFuji.parent) {
            var idxFuji = game.children.indexOf(monteFuji);
            if (idxFuji > topIndex) topIndex = idxFuji;
        }
        if (typeof greenLayer !== 'undefined' && greenLayer && greenLayer.parent) {
            var idxMask = game.children.indexOf(greenLayer);
            if (idxMask > topIndex) topIndex = idxMask;
        }
        for (var i = 0; i < greenBackgrounds.length; i++) {
            var tile = greenBackgrounds[i];
            if (tile && tile.parent) {
                var idxTile = game.children.indexOf(tile);
                if (idxTile > topIndex) topIndex = idxTile;
            }
        }
    }
    return Math.max(0, topIndex);
}
function sortObjectsByDepth() {
	var depthObjects = [];
    // Add green lanes first (just above background). Use very high z so they are placed first at baseIndex
    for (var i = 0; i < greenLanesLeft.length; i++) {
        if (greenLanesLeft[i].active) {
            depthObjects.push({ obj: greenLanesLeft[i], z: 1000000, type: 'greenLane' });
        }
    }
    for (var i = 0; i < greenLanesRight.length; i++) {
        if (greenLanesRight[i].active) {
            depthObjects.push({ obj: greenLanesRight[i], z: 1000000, type: 'greenLane' });
        }
    }
	// Add clouds next (they should be behind trees but in front of fog)
	for (var i = 0; i < clouds.length; i++) {
		if (clouds[i].active && clouds[i].z !== undefined) {
			depthObjects.push({
				obj: clouds[i],
				z: clouds[i].z + 10000,
				// Add large offset to ensure clouds are behind trees but in front of fog
				type: 'cloud'
			});
		}
	}
	// Add trees
	for (var i = 0; i < trees.length; i++) {
		if (trees[i].active && trees[i].z !== undefined) {
			depthObjects.push({
				obj: trees[i],
				z: trees[i].z,
				type: 'tree'
			});
		}
	}
	// Add obstacles
	for (var i = 0; i < obstacles.length; i++) {
		if (obstacles[i].active && obstacles[i].z !== undefined) {
			depthObjects.push({
				obj: obstacles[i],
				z: obstacles[i].z,
				type: 'obstacle'
			});
		}
	}
	// Add toris
	for (var i = 0; i < toris.length; i++) {
		if (toris[i].active && toris[i].z !== undefined) {
			depthObjects.push({
				obj: toris[i],
				z: toris[i].z,
				type: 'tori'
			});
		}
	}
	// Add wooden planks
	for (var i = 0; i < woodenPlanks.length; i++) {
		if (woodenPlanks[i].active && woodenPlanks[i].z !== undefined) {
			depthObjects.push({
				obj: woodenPlanks[i],
				z: woodenPlanks[i].z,
				type: 'plank'
			});
		}
	}
	// Sort by z value - higher z (farther) should be behind (lower index)
	depthObjects.sort(function (a, b) {
		return b.z - a.z;
	});
    // Reorder objects in game children - farther objects go behind
    // Base justo por encima de todo el fondo (tiles césped + máscara + Fuji)
    var baseIndex = getBackgroundTopIndex() + 1;
	for (var i = 0; i < depthObjects.length; i++) {
		var obj = depthObjects[i].obj;
		var currentIndex = game.children.indexOf(obj);
		var targetIndex = baseIndex + i;
		if (currentIndex !== -1 && currentIndex !== targetIndex && targetIndex < game.children.length) {
			game.removeChild(obj);
			game.addChildAt(obj, Math.min(targetIndex, game.children.length));
		}
	}
}
// Spawn enemy from tree crown
function spawnEnemy() {
	// Check if enough time has passed since last enemy spawn
	if (LK.ticks - lastEnemySpawnTime < minSpawnDelay) {
		return; // Not enough time passed, skip spawning
	}
	// Check for obstacle conflicts - don't spawn if obstacles are nearby
	for (var o = 0; o < obstacles.length; o++) {
		var obstacle = obstacles[o];
		if (obstacle.active && obstacle.z && obstacle.z > 600 && obstacle.z < 1200) {
			return; // There's an obstacle in the spawn zone - don't spawn enemy
		}
	}
	// Find trees that are suitable for enemy spawning
	var suitableTrees = [];
	for (var i = 0; i < trees.length; i++) {
		var tree = trees[i];
		if (tree.active && tree.z < 600 && tree.z > 200) {
			suitableTrees.push(tree);
		}
	}
	if (suitableTrees.length > 0) {
		// Filter out trees from the same side as last spawn
		var availableTrees = [];
		for (var i = 0; i < suitableTrees.length; i++) {
			if (suitableTrees[i].side !== lastEnemySpawnSide) {
				availableTrees.push(suitableTrees[i]);
			}
		}
		// If no trees available from different side, use any available tree
		if (availableTrees.length === 0) {
			availableTrees = suitableTrees;
		}
		// Pick random tree from available trees
		var tree = availableTrees[Math.floor(Math.random() * availableTrees.length)];
		var enemy = new Enemy();
		// Position at tree crown (top of tree)
		enemy.x = tree.x;
		enemy.y = tree.y - tree.scaleY * 500; // Position at tree top based on tree scale
		// Calculate trajectory to land exactly on ninja position
		var jumpStrength = -8; // Much weaker upward jump for slower arc
		var timeToFall = Math.abs(jumpStrength * 2 / 0.15); // Calculate fall time based on gravity
		var horizontalDistance = ninja.x - enemy.x;
		var horizontalSpeed = horizontalDistance / timeToFall; // Speed needed to reach ninja
		enemy.velocityY = jumpStrength;
		enemy.velocityX = horizontalSpeed;
		// Play ninjaJump sound when enemy spawns
		LK.getSound('ninjaJump').play();
		// Mirror enemies coming from left side so sword points toward center
		if (tree.side < 0) {
			// Left side tree - flip the existing graphics
			var enemyGraphics = enemy.children[0];
			enemyGraphics.scaleX = -1; // Flip horizontally
		}
		enemies.push(enemy);
		game.addChild(enemy);
		// Update tracking variables
		lastEnemySpawnSide = tree.side;
		lastEnemySpawnTime = LK.ticks;
	}
}
// Spawn NMI2 enemy from tree crown
function spawnEnemy2() {
	// Check if enough time has passed since last enemy spawn
	if (LK.ticks - lastEnemySpawnTime < minSpawnDelay) {
		return; // Not enough time passed, skip spawning
	}
	// Check for obstacle conflicts - don't spawn if obstacles are nearby
	for (var o = 0; o < obstacles.length; o++) {
		var obstacle = obstacles[o];
		if (obstacle.active && obstacle.z && obstacle.z > 600 && obstacle.z < 1200) {
			return; // There's an obstacle in the spawn zone - don't spawn enemy
		}
	}
	// Find trees that are suitable for enemy spawning
	var suitableTrees = [];
	for (var i = 0; i < trees.length; i++) {
		var tree = trees[i];
		if (tree.active && tree.z < 600 && tree.z > 200) {
			suitableTrees.push(tree);
		}
	}
	if (suitableTrees.length > 0) {
		// Filter out trees from the same side as last spawn
		var availableTrees = [];
		for (var i = 0; i < suitableTrees.length; i++) {
			if (suitableTrees[i].side !== lastEnemySpawnSide) {
				availableTrees.push(suitableTrees[i]);
			}
		}
		// If no trees available from different side, use any available tree
		if (availableTrees.length === 0) {
			availableTrees = suitableTrees;
		}
		// Pick random tree from available trees
		var tree = availableTrees[Math.floor(Math.random() * availableTrees.length)];
		var enemy2 = new Enemy2();
		// Position at tree crown (top of tree)
		enemy2.x = tree.x;
		enemy2.y = tree.y - tree.scaleY * 500; // Position at tree top based on tree scale
		// Calculate trajectory to land exactly on ninja position
		var jumpStrength = -8; // Much weaker upward jump for slower arc
		var timeToFall = Math.abs(jumpStrength * 2 / 0.15); // Calculate fall time based on gravity
		var horizontalDistance = ninja.x - enemy2.x;
		var horizontalSpeed = horizontalDistance / timeToFall; // Speed needed to reach ninja
		enemy2.velocityY = jumpStrength;
		enemy2.velocityX = horizontalSpeed;
		// Play ninjaJump sound when enemy spawns
		LK.getSound('ninjaJump').play();
		// Mirror enemies coming from left side so sword points toward center
		if (tree.side < 0) {
			// Left side tree - flip the existing graphics
			var enemyGraphics = enemy2.children[0];
			enemyGraphics.scaleX = -1; // Flip horizontally
		}
		enemies2.push(enemy2);
		game.addChild(enemy2);
		// Update tracking variables
		lastEnemySpawnSide = tree.side;
		lastEnemySpawnTime = LK.ticks;
	}
}
// Spawn enemy archer on tree crown
function spawnEnemyArcher() {
	// Find trees that are suitable for archer spawning (spawn much earlier when far away)
	var suitableTrees = [];
	for (var i = 0; i < trees.length; i++) {
		var tree = trees[i];
		if (tree.active && tree.z < 1200 && tree.z > 400) {
			// Check if tree doesn't already have an archer
			var hasArcher = false;
			for (var a = 0; a < enemyArchers.length; a++) {
				if (enemyArchers[a].active && enemyArchers[a].tree === tree) {
					hasArcher = true;
					break;
				}
			}
			if (!hasArcher) {
				suitableTrees.push(tree);
			}
		}
	}
	if (suitableTrees.length > 0) {
		// Pick random tree from suitable trees
		var tree = suitableTrees[Math.floor(Math.random() * suitableTrees.length)];
		var archer = new EnemyArcher();
		archer.tree = tree; // Assign tree reference
		archer.x = tree.x;
		archer.y = tree.y - tree.scaleY * 300;
		// Flip archer graphics based on tree side
		if (tree.side < 0) {
			// Left side tree - flip archer
			var archerGraphics = archer.children[0];
			archerGraphics.scaleX = -1;
		}
		enemyArchers.push(archer);
		game.addChild(archer);
		// Play spawn sound for ninja archer
		LK.getSound('Arcer-apears').play();
	}
}
// Spawn Enemy3 from tree crown
function spawnEnemy3() {
	// Check if enough time has passed since last enemy spawn
	if (LK.ticks - lastEnemySpawnTime < minSpawnDelay) {
		return; // Not enough time passed, skip spawning
	}
	// Check for obstacle conflicts - don't spawn if obstacles are nearby
	for (var o = 0; o < obstacles.length; o++) {
		var obstacle = obstacles[o];
		if (obstacle.active && obstacle.z && obstacle.z > 600 && obstacle.z < 1200) {
			return; // There's an obstacle in the spawn zone - don't spawn enemy
		}
	}
	// Find trees that are suitable for enemy spawning
	var suitableTrees = [];
	for (var i = 0; i < trees.length; i++) {
		var tree = trees[i];
		if (tree.active && tree.z < 600 && tree.z > 200) {
			suitableTrees.push(tree);
		}
	}
	if (suitableTrees.length > 0) {
		// Filter out trees from the same side as last spawn
		var availableTrees = [];
		for (var i = 0; i < suitableTrees.length; i++) {
			if (suitableTrees[i].side !== lastEnemySpawnSide) {
				availableTrees.push(suitableTrees[i]);
			}
		}
		// If no trees available from different side, use any available tree
		if (availableTrees.length === 0) {
			availableTrees = suitableTrees;
		}
		// Pick random tree from available trees
		var tree = availableTrees[Math.floor(Math.random() * availableTrees.length)];
		var enemy3 = new Enemy3();
		// Position at tree crown (top of tree)
		enemy3.x = tree.x;
		enemy3.y = tree.y - tree.scaleY * 500; // Position at tree top based on tree scale
		// Calculate trajectory to land exactly on ninja position
		var jumpStrength = -8; // Much weaker upward jump for slower arc
		var timeToFall = Math.abs(jumpStrength * 2 / 0.15); // Calculate fall time based on gravity
		var horizontalDistance = ninja.x - enemy3.x;
		var horizontalSpeed = horizontalDistance / timeToFall; // Speed needed to reach ninja
		enemy3.velocityY = jumpStrength;
		enemy3.velocityX = horizontalSpeed;
		// Play ninjaJump sound when enemy spawns
		LK.getSound('ninjaJump').play();
		// Mirror enemies coming from left side so sword points toward center
		if (tree.side < 0) {
			// Left side tree - flip the existing graphics
			var enemyGraphics = enemy3.children[0];
			enemyGraphics.scaleX = -1; // Flip horizontally
		}
		enemies3.push(enemy3);
		game.addChild(enemy3);
		// Update tracking variables
		lastEnemySpawnSide = tree.side;
		lastEnemySpawnTime = LK.ticks;
	}
}
// Spawn obstacle
function spawnObstacle() {
	// Check if there are any toris that would conflict with obstacle spawning
	var canSpawnObstacle = true;
	var minSeparationDistance = 300; // Minimum distance between obstacles and toris
	for (var t = 0; t < toris.length; t++) {
		var tori = toris[t];
		if (tori.active && tori.z && tori.z > 600 && tori.z < 1400) {
			// There's a tori in the spawn zone - don't spawn obstacle
			canSpawnObstacle = false;
			break;
		}
	}
	// Also check existing obstacles to ensure proper spacing
	for (var o = 0; o < obstacles.length; o++) {
		var existingObstacle = obstacles[o];
		if (existingObstacle.active && existingObstacle.z && Math.abs(existingObstacle.z - 1000) < minSeparationDistance) {
			// There's another obstacle too close - don't spawn
			canSpawnObstacle = false;
			break;
		}
	}
	if (!canSpawnObstacle) {
		return; // Skip obstacle spawning to avoid collision with tori or other obstacles
	}
	var obstacleType = Math.random();
	var obstacle;
	if (obstacleType < 0.25) {
		obstacle = new Obstacle();
	} else if (obstacleType < 0.5) {
		obstacle = new RockObstacle();
	} else if (obstacleType < 0.75) {
		obstacle = new mushroomObstacle();
	} else {
		obstacle = new RockObstacle();
	}
	obstacle.x = 1024; // Start from center of horizon for perspective
	obstacle.y = horizonY; // Start at horizon
	obstacle.z = 1000; // Start far away
	obstacle.baseX = 1024; // Center starting position
	obstacle.side = 0; // Keep in center for jumping
	obstacles.push(obstacle);
	game.addChild(obstacle);
	// Show alert above ninja head for jump-required obstacle
	showAlert();
}
// Fog spawn function removed - no fog elements in game
// Spawn cloud in sky
function spawnCloud() {
	var cloudType = Math.random();
	var cloud;
	// Adjust cloud type probabilities based on difficulty
	if (!isFeatureUnlocked('lightningClouds')) {
		// Early game: only regular clouds
		if (cloudType < 0.7) {
			cloud = new Cloud();
		} else {
			cloud = new CloudType3();
		}
	} else {
		// Check maximum number of electric clouds allowed based on phase
		var maxElectricClouds = Math.min(casaNinjaVisitCount + 1, 3); // Max 3 electric clouds
		var currentElectricClouds = 0;
		for (var i = 0; i < clouds.length; i++) {
			if (clouds[i].constructor === electroCloud && clouds[i].active) {
				currentElectricClouds++;
			}
		}
		// Much more normal clouds - 90% chance for normal clouds
		if (cloudType < 0.9) {
			// 90% chance for normal clouds (many more)
			if (cloudType < 0.45) {
				cloud = new Cloud();
			} else {
				cloud = new CloudType3();
			}
		} else if (currentElectricClouds < maxElectricClouds) {
			// 10% chance for electric cloud (only if under limit)
			cloud = new electroCloud();
		} else {
			// If electric cloud limit reached, spawn normal cloud instead
			if (cloudType < 0.95) {
				cloud = new Cloud();
			} else {
				cloud = new CloudType3();
			}
		}
	}
	cloud.x = Math.random() * 1200 + 400; // Random x position
	cloud.y = horizonY - 100; // Start closer to horizon, only 100px above it
	cloud.baseY = cloud.y; // Store original y for perspective calculation
	cloud.z = 2000; // Start very far away
	clouds.push(cloud);
	// Add clouds in front of sun - find sun's position and add cloud after it
	var sunIndex = game.children.indexOf(sun);
	var cloudIndex = Math.min(sunIndex + 1, game.children.length);
	game.addChildAt(cloud, cloudIndex);
}
// Spawn tori
function spawnTori() {
	// Check if there are any obstacles or casa ninja that would conflict with tori spawning
	var canSpawnTori = true;
	var minSeparationDistance = 300; // Minimum distance between toris and obstacles
	for (var o = 0; o < obstacles.length; o++) {
		var obstacle = obstacles[o];
		if (obstacle.active && obstacle.z && obstacle.z > 600 && obstacle.z < 1400) {
			// There's an obstacle in the spawn zone - don't spawn tori
			canSpawnTori = false;
			break;
		}
	}
	// Check if casa ninja is active and would conflict with tori spawning
	if (casaNinja && casaNinja.active && casaNinja.z && casaNinja.z > 600 && casaNinja.z < 1400) {
		// There's a casa ninja in the spawn zone - don't spawn tori
		canSpawnTori = false;
	}
	// Also check existing toris to ensure proper spacing
	for (var t = 0; t < toris.length; t++) {
		var existingTori = toris[t];
		if (existingTori.active && existingTori.z && Math.abs(existingTori.z - 1000) < minSeparationDistance) {
			// There's another tori too close - don't spawn
			canSpawnTori = false;
			break;
		}
	}
	if (!canSpawnTori) {
		return; // Skip tori spawning to avoid collision with obstacle or other toris
	}
	var tori = new Tori();
	tori.x = 1024; // Start from center of horizon for perspective
	tori.y = horizonY; // Start at horizon
	tori.z = 1000; // Start far away
	tori.baseX = 1024; // Center starting position
	// No side spreading - tori stays in center
	toris.push(tori);
	game.addChild(tori);
}
// Spawn trees on both sides of the path
function spawnTrees() {
	// Remove tree limit to allow unlimited trees
	// Left side tree - starts from center horizon
	var leftTreeType = Math.random();
	var leftTree;
	if (leftTreeType < 0.33) {
		leftTree = new Tree();
	} else if (leftTreeType < 0.66) {
		leftTree = new TreeType2();
	} else {
		leftTree = new TreeType3();
	}
	leftTree.x = 1024; // Start from center of horizon
	leftTree.y = horizonY; // Start at horizon
	leftTree.z = 1000; // Start far away
	leftTree.side = -1; // Will spread to the left
	leftTree.speed = 3; // Match speed with obstacles and other objects
	trees.push(leftTree);
	// New trees (higher z distance) should have lower z-index (appear behind farther trees)
	var insertIndex = greenBackgrounds.length + 2;
	if (insertIndex > game.children.length) {
		insertIndex = game.children.length;
	}
	game.addChildAt(leftTree, insertIndex);
	// No limit check - spawn right tree always
	// Right side tree - starts from center horizon
	var rightTreeType = Math.random();
	var rightTree;
	if (rightTreeType < 0.33) {
		rightTree = new Tree();
	} else if (rightTreeType < 0.66) {
		rightTree = new TreeType2();
	} else {
		rightTree = new TreeType3();
	}
	rightTree.x = 1024; // Start from center of horizon
	rightTree.y = horizonY; // Start at horizon
	rightTree.z = 1000; // Start far away
	rightTree.side = 1; // Will spread to the right
	rightTree.speed = 3; // Match speed with obstacles and other objects
	trees.push(rightTree);
	// New trees (higher z distance) should have lower z-index (appear behind farther trees)
	var rightInsertIndex = greenBackgrounds.length + 2;
	if (rightInsertIndex > game.children.length) {
		rightInsertIndex = game.children.length;
	}
	game.addChildAt(rightTree, rightInsertIndex);
	// Spawn additional trees for density - spawn 2 more pairs
	for (var extraPair = 0; extraPair < 2; extraPair++) {
		// Extra left tree with slight offset
		var extraLeftTreeType = Math.random();
		var extraLeftTree;
		if (extraLeftTreeType < 0.33) {
			extraLeftTree = new Tree();
		} else if (extraLeftTreeType < 0.66) {
			extraLeftTree = new TreeType2();
		} else {
			extraLeftTree = new TreeType3();
		}
		extraLeftTree.x = 1024;
		extraLeftTree.y = horizonY;
		extraLeftTree.z = 1100 + extraPair * 200; // Spawn at different distances
		extraLeftTree.side = -1;
		extraLeftTree.speed = 3;
		trees.push(extraLeftTree);
		var extraLeftInsertIndex = greenBackgrounds.length + 2;
		if (extraLeftInsertIndex > game.children.length) {
			extraLeftInsertIndex = game.children.length;
		}
		game.addChildAt(extraLeftTree, extraLeftInsertIndex);
		// Extra right tree with slight offset
		var extraRightTreeType = Math.random();
		var extraRightTree;
		if (extraRightTreeType < 0.33) {
			extraRightTree = new Tree();
		} else if (extraRightTreeType < 0.66) {
			extraRightTree = new TreeType2();
		} else {
			extraRightTree = new TreeType3();
		}
		extraRightTree.x = 1024;
		extraRightTree.y = horizonY;
		extraRightTree.z = 1150 + extraPair * 200; // Spawn at different distances
		extraRightTree.side = 1;
		extraRightTree.speed = 3;
		trees.push(extraRightTree);
		var extraRightInsertIndex = greenBackgrounds.length + 2;
		if (extraRightInsertIndex > game.children.length) {
			extraRightInsertIndex = game.children.length;
		}
		game.addChildAt(extraRightTree, extraRightInsertIndex);
	}
}
// Spawn airplane
function spawnAirplane() {
	var airplane = new Airplane();
	// Only spawn from left to right
	airplane.x = -200; // Start from left
	airplane.direction = 1; // Move right
	airplane.y = airplane.altitude;
	// Play airplane sound when spawning
	LK.getSound('Avion').play();
	airplanes.push(airplane);
	game.addChild(airplane);
}
// Drop power-up from airplane
function dropPowerUp(airplane) {
	var powerUp = new PowerUp();
	powerUp.x = airplane.x;
	powerUp.y = airplane.y + 50; // Drop slightly below airplane
	// Random power-up type (1-2)
	var powerUpType = Math.floor(Math.random() * 2) + 1;
	powerUp.setPowerUpType(powerUpType);
	powerUps.push(powerUp);
	game.addChild(powerUp);
	// Play fallBox sound when item box drops from airplane
	LK.getSound('fallBox').play();
}
// Spawn wooden planks for walkway effect
function spawnWoodenPlanks() {
	// Create multiple planks in a row to simulate wooden walkway
	for (var plankIndex = -4; plankIndex <= 4; plankIndex++) {
		var plank = new WoodenPlank();
		plank.x = 1024; // Start from center of horizon
		plank.y = 1503; // Start at horizon
		// Maintain regular distance between planks
		plank.z = 1000 + plankIndex * plankRegularDistance; // Regular depth spacing
		plank.baseX = 1024;
		// No horizontal offset needed - planks stay centered
		plank.speed = 3; // Match speed with other objects
		woodenPlanks.push(plank);
		// Insert planks on the ground level, above green background but below other objects
		var plankInsertIndex = greenBackgrounds.length + 1;
		if (plankInsertIndex > game.children.length) {
			plankInsertIndex = game.children.length;
		}
		game.addChildAt(plank, plankInsertIndex);
	}
	// Además, crear segmentos de carriles verdes a ambos lados cubriendo todo el ancho
	// Estimación de cuántas columnas necesitamos hacia cada lado
	var colsPerSide = 14; // más columnas para cubrir con holgura
	for (var laneIndex = -2; laneIndex <= 2; laneIndex++) {
		for (var col = 0; col < colsPerSide; col++) {
            var leftSeg = new GreenLaneSegment();
			leftSeg.baseX = 1024;
			leftSeg.z = 1000 + laneIndex * plankRegularDistance;
			leftSeg.side = -1;
			leftSeg.colIndex = col;
			greenLanesLeft.push(leftSeg);
            game.addChildAt(leftSeg, getBackgroundTopIndex() + 1); // por encima de TODO el fondo
			var rightSeg = new GreenLaneSegment();
			rightSeg.baseX = 1024;
			rightSeg.z = 1000 + laneIndex * plankRegularDistance;
			rightSeg.side = 1;
			rightSeg.colIndex = col;
			greenLanesRight.push(rightSeg);
            game.addChildAt(rightSeg, getBackgroundTopIndex() + 1); // por encima de TODO el fondo
		}
	}
	// Update last spawn Y position for next batch
	lastPlankSpawnY = lastPlankSpawnY + 9 * plankRegularDistance; // mantener regularidad
}
// Enemy spawning is now handled by spawnEnemy function directly from tree crowns
// Throw ninja star
function throwNinjaStar(targetX, targetY) {
	// Check if ice power is active
	if (hasIcePower) {
		// Throw ice star
		var iceStar = new IceStar();
		iceStar.x = ninja.x;
		iceStar.y = ninja.y - 250; // Position above ninja head
		// Calculate direction
		var dx = targetX - iceStar.x;
		var dy = targetY - iceStar.y;
		var distance = Math.sqrt(dx * dx + dy * dy);
		// Normalize and set velocity
		iceStar.velocityX = dx / distance * iceStar.speed;
		iceStar.velocityY = dy / distance * iceStar.speed;
		iceStars.push(iceStar);
		// Add ice star after ninja in display list so it appears in front
		var ninjaIndex = game.children.indexOf(ninja);
		if (ninjaIndex !== -1) {
			game.addChildAt(iceStar, ninjaIndex + 1);
		} else {
			game.addChild(iceStar);
		}
		LK.getSound('ice-throw').play();
	} else if (hasWoodenStarPower) {
		// Throw three wooden stars in a spread pattern
		for (var starIndex = 0; starIndex < 3; starIndex++) {
			var woodenStar = new WoodenStar();
			woodenStar.x = ninja.x;
			woodenStar.y = ninja.y - 250; // Position above ninja head
			// Calculate base direction
			var dx = targetX - woodenStar.x;
			var dy = targetY - woodenStar.y;
			var distance = Math.sqrt(dx * dx + dy * dy);
			// Limit target Y to 50% of screen height (1366px) - wooden stars limited range
			var screenMiddle = SCREEN_HALFY; // 50% de la altura virtual
			var limitedTargetY = Math.max(targetY, screenMiddle);
			var limitedDy = limitedTargetY - woodenStar.y;
			// Add spread angle: -15, 0, +15 degrees
			var spreadAngle = (starIndex - 1) * (Math.PI / 12); // 15 degrees in radians
			var baseAngle = Math.atan2(limitedDy, dx);
			var finalAngle = baseAngle + spreadAngle;
			// Set velocity with spread - but limit Y velocity to not go above 50% of screen
			var velocityX = Math.cos(finalAngle) * woodenStar.speed;
			var velocityY = Math.sin(finalAngle) * woodenStar.speed;
			// If velocity would make star go above 50% of screen, limit it to horizontal only
			var screenMiddle = SCREEN_HALFY; // 50% de la altura virtual
			if (velocityY < 0 && woodenStar.y + velocityY * 50 < screenMiddle) {
				// 50 frames lookahead
				velocityY = Math.max(velocityY, 0); // Don't allow upward movement that would cross 50% screen
			}
			woodenStar.velocityX = velocityX;
			woodenStar.velocityY = velocityY;
			woodenStars.push(woodenStar);
			// Add wooden star after ninja in display list so it appears in front
			var ninjaIndex = game.children.indexOf(ninja);
			if (ninjaIndex !== -1) {
				game.addChildAt(woodenStar, ninjaIndex + 1);
			} else {
				game.addChild(woodenStar);
			}
		}
		LK.getSound('throw').play();
	} else {
		// Normal ninja star throwing
		var star = new NinjaStar();
		star.x = ninja.x;
		star.y = ninja.y - 250; // Position above ninja head instead of below
		// Calculate direction
		var dx = targetX - star.x;
		var dy = targetY - star.y;
		var distance = Math.sqrt(dx * dx + dy * dy);
		// Normalize and set velocity
		star.velocityX = dx / distance * star.speed;
		star.velocityY = dy / distance * star.speed;
		ninjaStars.push(star);
		// Add ninja star behind ninja so it appears from behind his body
		var ninjaIndex = game.children.indexOf(ninja);
		if (ninjaIndex !== -1) {
			game.addChildAt(star, ninjaIndex);
		} else {
			game.addChild(star);
		}
		LK.getSound('throw').play();
	}
}
// Handle input
game.down = function (x, y, obj) {
	// Check if main screen is active and minimum time has passed
	if (mainScreenActive && mainScreenTimer >= mainScreenMinTime) {
		// Start swipe detection
		swipeStartXPopup = x;
		swipeStartYPopup = y;
		isSwipingPopup = true;
		game.lastDownTick = LK.ticks; // Track timing for swipe speed
		return; // Don't dismiss popup yet, wait for swipe completion
	}
	// Skip normal input if main screen is still active
	if (mainScreenActive) {
		return;
	}
	swipeStartX = x;
	swipeStartY = y;
	isSwipeActive = true;
};
game.up = function (x, y, obj) {
	// Handle swipe on main screen popup
	if (mainScreenActive && isSwipingPopup && mainScreenTimer >= mainScreenMinTime) {
		var swipeDistance = Math.sqrt(Math.pow(x - swipeStartXPopup, 2) + Math.pow(y - swipeStartYPopup, 2));
		var swipeSpeed = swipeDistance / Math.max(1, LK.ticks - (game.lastDownTick || LK.ticks));
		// Check if swipe is long and fast enough (minimum 150px distance and sufficient speed)
		if (swipeDistance > 150 && swipeSpeed > 2) {
			// Calculate swipe angle and cut line
			var swipeAngle = Math.atan2(y - swipeStartYPopup, x - swipeStartXPopup);
			// Create cut effect - split popup into two pieces
			var cutY = swipeStartYPopup + (y - swipeStartYPopup) * 0.5; // Cut line at middle of swipe
			// Create top piece (above cut line)
			var topPiece = game.addChild(LK.getAsset('Mainscreen', {
				anchorX: 0.5,
				anchorY: 0.5,
				x: mainScreenPopup.x,
				y: mainScreenPopup.y - 100,
				// Offset up from cut line
				scaleX: mainScreenPopup.scaleX,
				scaleY: mainScreenPopup.scaleY * 0.5 // Half height
			}));
			// Create bottom piece (below cut line)
			var bottomPiece = game.addChild(LK.getAsset('Mainscreen', {
				anchorX: 0.5,
				anchorY: 0.5,
				x: mainScreenPopup.x,
				y: mainScreenPopup.y + 100,
				// Offset down from cut line
				scaleX: mainScreenPopup.scaleX,
				scaleY: mainScreenPopup.scaleY * 0.5 // Half height
			}));
			// Hide original popup
			mainScreenPopup.alpha = 0;
			// Calculate separation velocities based on swipe direction
			var separationSpeed = 8;
			var perpAngle = swipeAngle + Math.PI / 2; // Perpendicular to swipe direction
			// Animate top piece flying away
			tween(topPiece, {
				x: topPiece.x + Math.cos(perpAngle) * 300,
				y: topPiece.y + Math.sin(perpAngle) * 300,
				rotation: Math.random() * Math.PI - Math.PI / 2,
				// Random rotation
				scaleX: 0,
				scaleY: 0,
				alpha: 0
			}, {
				duration: 800,
				easing: tween.easeOut,
				onFinish: function onFinish() {
					topPiece.destroy();
				}
			});
			// Animate bottom piece flying away (opposite direction)
			tween(bottomPiece, {
				x: bottomPiece.x - Math.cos(perpAngle) * 300,
				y: bottomPiece.y - Math.sin(perpAngle) * 300,
				rotation: Math.random() * Math.PI - Math.PI / 2,
				// Random rotation
				scaleX: 0,
				scaleY: 0,
				alpha: 0
			}, {
				duration: 800,
				easing: tween.easeOut,
				onFinish: function onFinish() {
					bottomPiece.destroy();
				}
			});
			// Play slash sound effect
			LK.getSound('throw').play();
			// Animate mask exit
			tween(mainScreenMask, {
				alpha: 0
			}, {
				duration: 500,
				easing: tween.easeIn,
				onFinish: function onFinish() {
					mainScreenMask.destroy();
				}
			});
			// Clean up original popup after animation starts
			LK.setTimeout(function () {
				if (mainScreenPopup) {
					mainScreenPopup.destroy();
				}
			}, 100);
			// Dismiss main screen
			mainScreenActive = false;
			isSwipingPopup = false;
			return;
		} else {
			// Swipe not strong enough - do simple dismiss
			mainScreenActive = false;
			// Animate mask exit
			tween(mainScreenMask, {
				alpha: 0
			}, {
				duration: 300,
				easing: tween.easeIn,
				onFinish: function onFinish() {
					mainScreenMask.destroy();
				}
			});
			// Animate popup exit
			tween(mainScreenPopup, {
				scaleX: 0,
				scaleY: 0,
				alpha: 0
			}, {
				duration: 300,
				easing: tween.easeIn,
				onFinish: function onFinish() {
					mainScreenPopup.destroy();
				}
			});
		}
		isSwipingPopup = false;
		return;
	}
	if (isSwipeActive && !ninjaParalyzed) {
		var swipeDistance = Math.sqrt(Math.pow(x - swipeStartX, 2) + Math.pow(y - swipeStartY, 2));
		if (swipeDistance > 100) {
			// Swipe - throw ninja star
			throwNinjaStar(x, y);
		} else {
			// Tap - jump
			ninja.jump();
		}
		isSwipeActive = false;
	}
};
// Main game loop
game.update = function () {
	// If game is paused (ninja hit), only play audio and wait
	if (game.paused) {
		return;
	}
	// Handle main screen timing
	if (mainScreenActive) {
		mainScreenTimer++;
		// Update ninja but skip other game elements
		ninja.update();
		// Update score display to show that game is preparing
		updateScore();
		// Continue updating background elements during main screen
		// Update trees
		for (var i = trees.length - 1; i >= 0; i--) {
			var tree = trees[i];
			tree.update();
			if (!tree.active) {
				tree.destroy();
				trees.splice(i, 1);
			}
		}
		// Update wooden planks
		for (var i = woodenPlanks.length - 1; i >= 0; i--) {
			var plank = woodenPlanks[i];
			plank.update();
			if (!plank.active) {
				plank.destroy();
				woodenPlanks.splice(i, 1);
			}
		}
		// Fog system removed - no fog updates needed during main screen
		// Spawn trees during main screen to keep background active
		treeSpawnTimer++;
		if (treeSpawnTimer > 90) {
			// Spawn trees much more frequently - 1.5 seconds interval for many more trees
			spawnTrees();
			treeSpawnTimer = 0;
		}
		// Spawn wooden planks during main screen with more spacing for walkway effect
		if (LK.ticks % 25 === 0) {
			// Spawn wooden planks every 25 frames (0.42 seconds) for spaced walkway effect
			spawnWoodenPlanks();
		}
		// Fog spawning removed - cleaner atmosphere without fog
		// Sort objects by depth during main screen for proper layering - but not when in casa ninja
		if (!isInCasaNinja && LK.ticks % 10 === 0) {
			sortObjectsByDepth();
		}
		// Skip all other updates while main screen is active
		return;
	}
	// Update ninja - but not when in casa ninja
	if (!isInCasaNinja) {
		ninja.update();
	}
	// Update wooden star power timer
	if (hasWoodenStarPower && woodenStarPowerTimer > 0) {
		woodenStarPowerTimer--;
		if (woodenStarPowerTimer <= 0) {
			hasWoodenStarPower = false;
			updateWeaponIndicator(); // Update weapon indicator when power ends
		}
	}
	// Update ice power timer
	if (hasIcePower && icePowerTimer > 0) {
		icePowerTimer--;
		if (icePowerTimer <= 0) {
			hasIcePower = false;
			updateWeaponIndicator(); // Update weapon indicator when power ends
		}
	}
	// Update ice stars
	var _loop3 = function _loop3() {
			iceStar = iceStars[i];
			iceStar.update();
			if (!iceStar.active) {
				iceStar.destroy();
				iceStars.splice(i, 1);
				return 0; // continue
			}
			// Ice stars have similar collision detection as wooden stars but with freezing effect
			// Check collision with meteorites
			for (m = meteorites.length - 1; m >= 0; m--) {
				meteorite = meteorites[m];
				if (meteorite.active && iceStar.intersects(meteorite)) {
					// Ice star destruye meteorito al 2do golpe
					handleMeteoriteHitCommon(iceStar, iceStars, i, meteorite, 2);
					break;
				}
			}
			// Check collision with all enemy types
			if (tryFreezeEnemiesWithFall(iceStar, iceStars, i, enemies, 10, 'freeze-enemy')) {
				return 0;
			}
			if (tryFreezeEnemiesWithFall(iceStar, iceStars, i, enemies2, 15, 'freeze-enemy2')) {
				return 0;
			}
			if (tryFreezeEnemiesWithFall(iceStar, iceStars, i, enemies3, 20, 'freeze-enemy3')) {
				return 0;
			}
			for (j = enemyArchers.length - 1; j >= 0; j--) {
				archer = enemyArchers[j];
				if (archer.active && iceStar.intersects(archer)) {
					freezeEnemyAndFall(archer, 'freeze-archer-ninja', 25, {
						anchorY: 1.0,
						scaleMultiplier: 2,
						isArcher: true
					});
					destroyProjectile(iceStars, i, iceStar);
					break;
				}
			}
			for (a = arrows.length - 1; a >= 0; a--) {
				arrow = arrows[a];
				if (arrow.active && !arrow.falling && iceStar.intersects(arrow)) {
					arrow.startFalling();
					destroyProjectile(iceStars, i, iceStar);
					break;
				}
			}
			// Check collision with airplanes
			for (var ap = airplanes.length - 1; ap >= 0; ap--) {
				var airplane = airplanes[ap];
				if (airplane.active && !airplane.falling && iceStar.intersects(airplane)) {
					handleAirplaneHit(iceStar, iceStars, i, airplane, {
						score: 30,
						soundId: 'aeroplane-fall',
						dropPowerUp: true
					});
					break;
				}
			}
			// Check collision with obstacles
			for (var o = obstacles.length - 1; o >= 0; o--) {
				var obstacle = obstacles[o];
				if (obstacle.active && iceStar.intersects(obstacle)) {
					destroyProjectile(iceStars, i, iceStar);
					break;
				}
			}
			// Check collision with CloudType2 (electric clouds) to disable them
			for (var cl = clouds.length - 1; cl >= 0; cl--) {
				var cloud = clouds[cl];
				if (cloud.active && cloud.constructor === electroCloud && iceStar.intersects(cloud)) {
					// Add 10 points for freezing electric cloud
					LK.setScore(LK.getScore() + 10);
					// Play electric cloud hit sound
					LK.getSound('electric-cloud-hit').play();
					// Play brbrbrbrbr sound when freezing cloud
					LK.getSound('brbrbrbrbr').play();
					// Change cloud to freeze cloud asset (disable electric properties)
					var cloudGraphics = cloud.children[0];
					var originalScale = {
						x: cloudGraphics.scaleX,
						y: cloudGraphics.scaleY
					};
					var originalAlpha = cloudGraphics.alpha;
					// Destroy electric cloud graphics
					cloudGraphics.destroy();
					// Replace with freeze cloud graphics
					var newCloudGraphics = cloud.attachAsset('nube-frezze', {
						anchorX: 0.5,
						anchorY: 0.5,
						scaleX: originalScale.x,
						scaleY: originalScale.y
					});
					// Maintain visual properties
					newCloudGraphics.alpha = originalAlpha;
					// Add trembling cold effect to frozen cloud
					var coldTrembleCount = 0;
					var maxColdTrembles = 25; // About 3 seconds of trembling (25 * 120ms)
					var createColdTrembling = function createColdTrembling() {
						if (coldTrembleCount >= maxColdTrembles || !cloud.active || cloud.constructor !== Cloud) {
							// Stop trembling and return to original position
							tween(cloud, {
								x: cloud.baseX || cloud.x,
								y: cloud.baseY || cloud.y
							}, {
								duration: 500,
								easing: tween.easeOut
							});
							return;
						}
						coldTrembleCount++;
						var coldIntensity = 8; // Moderate trembling intensity
						var coldDuration = 120; // Quick cold shivers
						// Random trembling in both X and Y
						var offsetX = (Math.random() - 0.5) * coldIntensity * 2;
						var offsetY = (Math.random() - 0.5) * coldIntensity * 2;
						tween(cloud, {
							x: cloud.x + offsetX,
							y: cloud.y + offsetY
						}, {
							duration: coldDuration,
							easing: tween.easeInOut,
							onFinish: function onFinish() {
								// Continue trembling
								createColdTrembling();
							}
						});
					};
					// Start the cold trembling effect
					createColdTrembling();
					// Stop any flickering effects by removing the constructor reference
					// This prevents the cloud from creating lightning
					cloud.constructor = Cloud;
					// Remove ice star
					iceStar.active = false;
					iceStar.destroy();
					iceStars.splice(i, 1);
					break;
				}
			}
			// Check collision with sun to freeze it - only if sun is visible
			if (sun.alpha > 0 && iceStar.intersects(sun)) {
				// Add strong initial trembling effect
				var createStrongTrembling = function createStrongTrembling() {
					var trembleIntensity = 20; // Strong initial shake
					var trembleDuration = 150; // Quick shakes
					// Create strong X trembling
					tween(sun, {
						x: sun.x + trembleIntensity
					}, {
						duration: trembleDuration,
						easing: tween.easeInOut,
						onFinish: function onFinish() {
							tween(sun, {
								x: sun.x - trembleIntensity * 2
							}, {
								duration: trembleDuration,
								easing: tween.easeInOut,
								onFinish: function onFinish() {
									tween(sun, {
										x: 1700 // Return to center
									}, {
										duration: trembleDuration,
										easing: tween.easeInOut,
										onFinish: function onFinish() {
											// After strong trembling, start gentle continuous trembling
											_createGentleTrembling();
										}
									});
								}
							});
						}
					});
				}; // Add gentle continuous trembling effect
				var _createGentleTrembling = function createGentleTrembling() {
					if (!sunFrozen) {
						return;
					} // Stop if sun is no longer frozen
					var gentleIntensity = 3; // Much smaller shake
					var gentleDuration = 200; // Slower rhythm
					// Random direction for natural movement
					var offsetX = (Math.random() - 0.5) * gentleIntensity * 2;
					var offsetY = (Math.random() - 0.5) * gentleIntensity * 2;
					tween(sun, {
						x: 1700 + offsetX,
						y: 300 + offsetY
					}, {
						duration: gentleDuration,
						easing: tween.easeInOut,
						onFinish: function onFinish() {
							// Continue gentle trembling
							_createGentleTrembling();
						}
					});
				}; // Start the trembling sequence
				// Freeze the sun
				sunFrozen = true;
				sunFrozenTimer = sunFrozenDuration; // 10 seconds frozen
				// Play icesun sound when sun is frozen
				LK.getSound('icesun').play();
				// Change sun to frozen appearance using icesun asset
				var sunIndex = game.children.indexOf(sun);
				sun.destroy();
				sun = game.addChildAt(LK.getAsset('icesun', {
					anchorX: 0.5,
					anchorY: 0.5,
					x: 1700,
					y: 300,
					scaleX: 1.5,
					scaleY: 1.5
				}), Math.max(greenBackgrounds.length + 1, Math.min(sunIndex, game.children.length)));
				createStrongTrembling();
				// Remove ice star
				iceStar.active = false;
				iceStar.destroy();
				iceStars.splice(i, 1);
				return 0; // continue
			}
		},
		iceStar,
		m,
		meteorite,
		j,
		enemy,
		j,
		enemy2,
		j,
		enemy3,
		j,
		j,
		archer,
		a,
		arrow,
		_ret;
	for (var i = iceStars.length - 1; i >= 0; i--) {
		_ret = _loop3();
		if (_ret === 0) {
			continue;
		}
	}
	// Update wooden stars
	for (var i = woodenStars.length - 1; i >= 0; i--) {
		var woodenStar = woodenStars[i];
		woodenStar.update();
		if (!woodenStar.active) {
			woodenStar.destroy();
			woodenStars.splice(i, 1);
			continue;
		}
		// Wooden stars pass through lightning clouds without effect - no collision detection with CloudType2
		// Check collision with meteorites
		for (var m = meteorites.length - 1; m >= 0; m--) {
			var meteorite = meteorites[m];
			if (meteorite.active && woodenStar.intersects(meteorite)) {
				// Wooden star destruye meteorito al 3er golpe
				handleMeteoriteHitCommon(woodenStar, woodenStars, i, meteorite, 3);
				break;
			}
		}
		// Check collision with enemies
		if (tryHitEnemiesWithFall(woodenStar, woodenStars, i, enemies, 10, 'hit', false)) {
			continue;
		}
		// Check collision with enemies2
		if (tryHitEnemiesWithFall(woodenStar, woodenStars, i, enemies2, 15, 'Hit2', false)) {
			continue;
		}
		// Check collision with enemies3
		if (tryHitEnemiesWithFall(woodenStar, woodenStars, i, enemies3, 20, 'Enemy3', false)) {
			continue;
		}
		// Check collision with enemy archers
		for (var j = enemyArchers.length - 1; j >= 0; j--) {
			var archer = enemyArchers[j];
			if (archer.active && woodenStar.intersects(archer)) {
				causeEnemyFall(archer, 25, 'Ninjaarrowgrito', true);
				destroyProjectile(woodenStars, i, woodenStar);
				break;
			}
		}
		// Check collision with arrows (make them fall when hit)
		if (tryHitArrows(woodenStar, woodenStars, i, arrows)) {
			continue;
		}
	}
	// Update ninja stars
	for (var i = ninjaStars.length - 1; i >= 0; i--) {
		var star = ninjaStars[i];
		star.update();
		if (!star.active) {
			star.destroy();
			ninjaStars.splice(i, 1);
			continue;
		}
		// Check collision with sun - only if sun is visible
		if (sun.alpha > 0 && star.intersects(sun)) {
			// Hit sun - change sun image for 2 seconds
			if (!sunIsHit) {
				LK.getSound('sol-grito').play();
				// Add 100 points for hitting the sun
				LK.setScore(LK.getScore() + 100);
				sun.destroy();
				sun = game.addChildAt(LK.getAsset('sunHit', {
					anchorX: 0.5,
					anchorY: 0.5,
					x: 1700,
					y: 300,
					scaleX: 1.5,
					scaleY: 1.5
				}), greenBackgrounds.length + 2); // Insert after background tiles and grass mask
				sunIsHit = true;
				sunFaceTimer = 120; // 2 seconds at 60fps
			}
			// Remove star
			destroyProjectile(ninjaStars, i, star);
			continue;
		}
		// Check collision with CloudType2 to spawn lightning (only when clouds are near the end of the screen)
		var _loop2 = function _loop2() {
				cloud = clouds[c];
				if (cloud.active && star.intersects(cloud) && cloud.constructor === electroCloud && cloud.isCharged) {
					// Shoot lightning when cloud is charged (active state) - more permissive z condition
					if (cloud.z <= 1000) {
						// Changed from 300 to 1000 to allow more lightning shots
						// 3 complete black-white cycles
						var _lightningFlicker = function lightningFlicker() {
							flickerCount++;
							if (flickerCount <= maxFlickers) {
								var isBlack = flickerCount % 2 === 1; // Odd numbers = black, even = white
								tween(game, {
									tint: isBlack ? 0x000000 : 0xFFFFFF
								}, {
									duration: 80,
									easing: tween.linear,
									onFinish: function onFinish() {
										if (flickerCount < maxFlickers) {
											_lightningFlicker(); // Continue flickering
										} else {
											// Reset to normal color after flickering
											tween(game, {
												tint: 0xFFFFFF
											}, {
												duration: 50,
												easing: tween.linear
											});
										}
									}
								});
							}
						};
						// Spawn lightning that stretches from cloud center to ninja center
						lightning = new Lightning();
						// Store reference to the cloud that fired this lightning
						lightning.sourceCloud = cloud;
						lightning.x = cloud.x;
						lightning.y = cloud.y; // Position at cloud center
						// Stretch lightning from cloud center to ninja center
						lightning.stretchTo();
						lightnings.push(lightning);
						// Insert lightning at proper depth - below clouds and ninja
						var ninjaIndex = game.children.indexOf(ninja);
						var cloudIndex = game.children.indexOf(cloud);
						var insertIndex = Math.min(ninjaIndex, cloudIndex);
						if (insertIndex > 0) {
							game.addChildAt(lightning, insertIndex);
						} else {
							game.addChild(lightning);
						}
						// Play lightning sound
						LK.getSound('lightning').play();
						// Create black and white flickering effect when lightning strikes
						flickerCount = 0;
						maxFlickers = 6;
						_lightningFlicker(); // Start the flickering sequence
						// Stop any ongoing jump tweens to freeze ninja in current position
						tween.stop(ninja);
						// Stop rotation tween on ninja graphics if jumping
						if (ninja.children[0]) {
							tween.stop(ninja.children[0]);
						}
						// Change ninja image to electrocutado for visual effect only
						ninjaGraphics = ninja.children[0];
						ninjaGraphics.destroy();
						ninjaRayGraphics = ninja.attachAsset('electrocutado', {
							anchorX: 0.5,
							anchorY: 1.0,
							scaleX: 3.0,
							scaleY: 3.0
						});
						// Create electrocution effect with saturation changes only
						var effectCount = 0;
						var maxEffects = 8; // Number of saturation changes during electrocution
						var _createElectrocutionEffect = function createElectrocutionEffect() {
							if (effectCount < maxEffects) {
								effectCount++;
								// Apply saturation changes only (no flip)
								tween(ninjaRayGraphics, {
									tint: effectCount % 2 === 1 ? 0x0080FF : 0xFFFFFF // Blue tint for saturation effect
								}, {
									duration: 150,
									// Quick effect duration
									easing: tween.linear,
									onFinish: function onFinish() {
										_createElectrocutionEffect(); // Continue effects
									}
								});
							} else {
								// Final state - return to normal color but keep electrocuted appearance
								tween(ninjaRayGraphics, {
									tint: 0xFFFFFF // Return to normal color
								}, {
									duration: 100,
									easing: tween.easeOut
								});
							}
						};
						// Start the electrocution effect
						_createElectrocutionEffect();
						// Paralyze ninja for 2 seconds (lightning paralysis, not damage)
						ninjaParalyzed = true;
						ninjaParalyzeTimer = 120; // 2 seconds at 60fps
						// Remove star only when the cloud is ready to shoot lightning
						destroyProjectile(ninjaStars, i, star);
						return 1; // break
					}
					// Cloud is charged and will shoot lightning when hit by star
				}
			},
			cloud,
			lightning,
			flickerCount,
			maxFlickers,
			ninjaGraphics,
			ninjaRayGraphics;
		for (var c = clouds.length - 1; c >= 0; c--) {
			if (_loop2()) {
				break;
			}
		}
		// If star was destroyed by electric cloud, skip remaining collision checks
		if (!star.active) {
			continue;
		}
		// Check collision with meteorites
		for (var m = meteorites.length - 1; m >= 0; m--) {
			var meteorite = meteorites[m];
			if (meteorite.active && star.intersects(meteorite)) {
				handleMeteoriteHitCommon(star, ninjaStars, i, meteorite, 3);
				break;
			}
		}
		// Check collision with airplanes
		for (var a = airplanes.length - 1; a >= 0; a--) {
			var airplane = airplanes[a];
			if (airplane.active && !airplane.falling && star.intersects(airplane)) {
				// Golpe con estrella normal: soltar power-up pero NO caer
				if (typeof dropPowerUp === 'function') {
					dropPowerUp(airplane);
				}
				try {
					LK.getSound('planeHit').play();
				} catch (e) {}
				destroyProjectile(ninjaStars, i, star);
				break;
			}
		}
		// Check collision with enemies
		if (tryHitEnemiesWithFall(star, ninjaStars, i, enemies, 10, 'hit', false)) {
			continue;
		}
		// Check collision with enemies2 (NMI2)
		if (tryHitEnemiesWithFall(star, ninjaStars, i, enemies2, 15, 'Hit2', false)) {
			continue;
		}
		// Check collision with enemies3 (Enemy3)
		if (tryHitEnemiesWithFall(star, ninjaStars, i, enemies3, 20, 'Enemy3', false)) {
			continue;
		}
		// Check collision with enemy archers
		for (var j = enemyArchers.length - 1; j >= 0; j--) {
			var archer = enemyArchers[j];
			if (archer.active && star.intersects(archer)) {
				causeEnemyFall(archer, 25, 'Ninjaarrowgrito', true);
				destroyProjectile(ninjaStars, i, star);
				break;
			}
		}
		// Check collision with arrows (make them fall when hit)
		if (tryHitArrows(star, ninjaStars, i, arrows)) {
			continue;
		}
	}
	// Update enemies
	if (updateEnemiesArray(enemies)) {
		return;
	}
	// Update enemies2 (NMI2)
	if (updateEnemiesArray(enemies2)) {
		return;
	}
	// Update enemies3 (Enemy3)
	if (updateEnemiesArray(enemies3)) {
		return;
	}
	// Update enemy archers
	updateAndCull(enemyArchers);
	// Update arrows
	if (updateArrowsAndCheckNinjaHit()) {
		return;
	}
	// Utilidades locales del loop
	function processTimer(get, set, threshold, shouldCount, onTrigger, resetValue) {
		if (!shouldCount) {
			return;
		}
		var v = get() + 1;
		set(v);
		if (v > threshold) {
			onTrigger();
			set(resetValue != null ? resetValue : 0);
		}
	}
	function ninjaHitSequence() {
		LK.getSound('ninja-ouch').play();
		tween(game, {
			tint: 0xff0000
		}, {
			duration: 100,
			easing: tween.linear
		});
		ninjaParalyzed = true;
		var impactImage = game.addChild(LK.getAsset('impact', {
			anchorX: 0.5,
			anchorY: 0.5,
			x: ninja.x,
			y: ninja.y - 250,
			scaleX: 2.0,
			scaleY: 2.0
		}));
		LK.effects.flashScreen(0xff0000, 1000);
		game.paused = true;
		LK.setTimeout(function () {
			LK.showGameOver();
		}, 2000);
	}
	// Actualiza y depura colecciones simples
	function updateAndCull(list) {
		for (var i = list.length - 1; i >= 0; i--) {
			var obj = list[i];
			obj.update();
			if (!obj.active) {
				obj.destroy();
				list.splice(i, 1);
			}
		}
	}
	function countActive(list) {
		var count = 0;
		for (var i = 0; i < list.length; i++) {
			if (list[i] && list[i].active) {
				count++;
			}
		}
		return count;
	}
	function updateEnemiesArray(list) {
		for (var i = list.length - 1; i >= 0; i--) {
			var enemyObj = list[i];
			enemyObj.update();
			if (!enemyObj.active) {
				enemyObj.destroy();
				list.splice(i, 1);
				continue;
			}
			if (enemyObj.y > 2200 && !enemyObj.frozen && !enemyObj.falling && !(casaNinja && casaNinja.active) && ninja.intersects(enemyObj)) {
				ninjaHitSequence();
				return true; // early exit from game.update
			}
		}
		return false;
	}
	function updateArrowsAndCheckNinjaHit() {
		for (var i = arrows.length - 1; i >= 0; i--) {
			var arrow = arrows[i];
			arrow.update();
			if (!arrow.active) {
				arrow.destroy();
				arrows.splice(i, 1);
				continue;
			}
			if (ninja.intersects(arrow)) {
				ninjaHitSequence();
				return true;
			}
		}
		return false;
	}
	updateAndCull(lightnings);
	for (var i = meteorites.length - 1; i >= 0; i--) {
		var meteorite = meteorites[i];
		meteorite.update();
		if (!meteorite.active) {
			meteorite.destroy();
			meteorites.splice(i, 1);
			continue;
		}
		if (!isInCasaNinja && ninja.intersects(meteorite)) {
			ninjaHitSequence();
			return;
		}
	}
	for (var i = obstacles.length - 1; i >= 0; i--) {
		var obstacle = obstacles[i];
		obstacle.update();
		if (!obstacle.active) {
			obstacle.destroy();
			obstacles.splice(i, 1);
			continue;
		}
		for (var s = ninjaStars.length - 1; s >= 0; s--) {
			var star = ninjaStars[s];
			if (star.active && obstacle.active && star.intersects(obstacle)) {
				destroyProjectile(ninjaStars, s, star);
				break;
			}
		}
		for (var ws = woodenStars.length - 1; ws >= 0; ws--) {
			var woodenStar = woodenStars[ws];
			if (woodenStar.active && obstacle.active && woodenStar.intersects(obstacle)) {
				destroyProjectile(woodenStars, ws, woodenStar);
				break;
			}
		}
		if (!ninja.isJumping && obstacle.y > 2600 && !(casaNinja && casaNinja.active) && ninja.intersects(obstacle)) {
			LK.getSound('mushroom-hit').play();
			LK.getSound('pipipipipi').play();
			ninjaHitSequence();
			return;
		}
	}
	// Actualizar carriles verdes
	updateAndCull(greenLanesLeft);
	updateAndCull(greenLanesRight);
	if (!isInCasaNinja) {
		for (var i = toris.length - 1; i >= 0; i--) {
			var tori = toris[i];
			tori.update();
			if (!tori.active) {
				tori.destroy();
				toris.splice(i, 1);
				continue;
			}
			if (ninja.isJumping && tori.y > 2200 && !(casaNinja && casaNinja.active) && ninja.intersects(tori)) {
				LK.getSound('hit').play();
				ninjaHitSequence();
				return;
			}
		}
	}
	if (!mainScreenActive && !isInCasaNinja && !(casaNinja && casaNinja.active) && isFeatureUnlocked('enemies')) {
		var currentPhase = Math.min(casaNinjaVisitCount + 1, 4);
		var spawnInterval = currentPhase === 1 ? 300 : 600;
		processTimer(function () {
			return enemySpawnTimer;
		}, function (v) {
			enemySpawnTimer = v;
		}, spawnInterval, true, function () {
			spawnEnemy();
		});
		processTimer(function () {
			return enemy2SpawnTimer;
		}, function (v) {
			enemy2SpawnTimer = v;
		}, 900, isFeatureUnlocked('enemy2'), function () {
			spawnEnemy2();
		});
		processTimer(function () {
			return enemy3SpawnTimer;
		}, function (v) {
			enemy3SpawnTimer = v;
		}, 1200, isFeatureUnlocked('enemy3'), function () {
			spawnEnemy3();
		});
		if (LK.ticks % 900 === 0 && isFeatureUnlocked('archers') && !(casaNinja && casaNinja.active)) {
			spawnEnemyArcher();
		}
	}
	if (!isInCasaNinja && !(casaNinja && casaNinja.active) && isFeatureUnlocked('obstacles')) {
		obstacleSpawnTimer++;
		if (obstacleSpawnTimer > 1200) {
			if (LK.ticks - lastEnemySpawnTime > 180) {
				spawnObstacle();
				obstacleSpawnTimer = 0;
			} else {
				obstacleSpawnTimer = 800;
			}
		}
	}
	if (!isInCasaNinja && !(casaNinja && casaNinja.active) && isFeatureUnlocked('toris')) {
		processTimer(function () {
			return toriSpawnTimer;
		}, function (v) {
			toriSpawnTimer = v;
		}, 480, true, function () {
			spawnTori();
		});
	}
	if (!isInCasaNinja) {
		var activeClouds = 0;
		for (var i = clouds.length - 1; i >= 0; i--) {
			var cloud = clouds[i];
			cloud.update();
			if (!cloud.active) {
				cloud.destroy();
				clouds.splice(i, 1);
			} else {
				activeClouds++;
			}
		}
		if (LK.ticks % 300 === 0) {
			// log omitido en plataforma de destino
		}
	}
	if (!isInCasaNinja) {
		updateAndCull(trees);
	}
	// Mantener regularidad de tablas incluso al salir de la casa
	updateAndCull(woodenPlanks);
	if (!isInCasaNinja) {
		updateAndCull(airplanes);
	}
	for (var i = powerUps.length - 1; i >= 0; i--) {
		var powerUp = powerUps[i];
		powerUp.update();
		if (!powerUp.active) {
			powerUp.destroy();
			powerUps.splice(i, 1);
			continue;
		}
		if (ninja.intersects(powerUp)) {
			LK.setScore(LK.getScore() + 25);
			updateScore();
			LK.getSound('powerUp').play();
			if (powerUp.powerupType === 1) {
				hasWoodenStarPower = true;
				woodenStarPowerTimer = woodenStarDuration;
				updateWeaponIndicator();
			}
			if (powerUp.powerupType === 2) {
				hasIcePower = true;
				icePowerTimer = icePowerDuration;
				updateWeaponIndicator();
			}
			powerUp.active = false;
			powerUp.destroy();
			powerUps.splice(i, 1);
		}
	}
	processTimer(function () {
		return cloudSpawnTimer;
	}, function (v) {
		cloudSpawnTimer = v;
	}, 60, !isInCasaNinja && !(casaNinja && casaNinja.active) && isFeatureUnlocked('lightningClouds'), function () {
		spawnCloud();
	});
	if (!isInCasaNinja && !(casaNinja && casaNinja.active)) {
		processTimer(function () {
			return treeSpawnTimer;
		}, function (v) {
			treeSpawnTimer = v;
		}, 90, true, function () {
			spawnTrees();
		});
	}
	if (!(casaNinja && casaNinja.active) && LK.ticks % 25 === 0) {
		spawnWoodenPlanks();
	}
	if (!isInCasaNinja && !(casaNinja && casaNinja.active)) {
		processTimer(function () {
			return airplaneSpawnTimer;
		}, function (v) {
			airplaneSpawnTimer = v;
		}, 600, isFeatureUnlocked('airplanes'), function () {
			spawnAirplane();
		});
	}
	if (sunFrozen && sunFrozenTimer > 0) {
		sunFrozenTimer--;
		if (sunFrozenTimer <= 0) {
			tween.stop(sun);
			sunFrozen = false;
			var sunIndex = game.children.indexOf(sun);
			sun.destroy();
			sun = game.addChildAt(LK.getAsset('sun', {
				anchorX: 0.5,
				anchorY: 0.5,
				x: 1700,
				y: 300,
				scaleX: 1.5,
				scaleY: 1.5
			}), Math.max(greenBackgrounds.length + 1, Math.min(sunIndex, game.children.length)));
		}
	}
	if (!sunFrozen && sunIsHit && sunFaceTimer > 0) {
		sunFaceTimer--;
		if (sunFaceTimer <= 0) {
			if (!sunFrozen) {
				sun.destroy();
				sun = game.addChildAt(LK.getAsset('sunAttack', {
					anchorX: 0.5,
					anchorY: 0.5,
					x: 1700,
					y: 300,
					scaleX: 3.0,
					scaleY: 3.0
				}), greenBackgrounds.length + 2);
				LK.getSound('sol-risa').play();
				sunIsHit = false;
				var meteorite = new Meteorite();
				meteorite.x = sun.x;
				meteorite.y = sun.y;
				var dx = ninja.x - meteorite.x;
				var dy = ninja.y - meteorite.y;
				var distance = Math.sqrt(dx * dx + dy * dy);
				meteorite.velocityX = dx / distance * meteorite.speed;
				meteorite.velocityY = dy / distance * meteorite.speed;
				meteorites.push(meteorite);
				game.addChild(meteorite);
				sunFaceTimer = 60;
			}
		}
	} else if (!sunFrozen && !sunIsHit && sunFaceTimer > 0) {
		sunFaceTimer--;
		if (sunFaceTimer <= 0) {
			sun.destroy();
			sun = game.addChildAt(LK.getAsset('sun', {
				anchorX: 0.5,
				anchorY: 0.5,
				x: 1700,
				y: 300,
				scaleX: 1.5,
				scaleY: 1.5
			}), greenBackgrounds.length + 2);
		}
	}
	if (ninjaParalyzed && ninjaParalyzeTimer > 0) {
		ninjaParalyzeTimer--;
		if (ninjaParalyzeTimer <= 0) {
			ninjaParalyzed = false;
			tween.stop(ninja);
			if (ninja.children[0]) {
				tween.stop(ninja.children[0]);
			}
			ninja.y = ninja.groundY;
			ninja.isJumping = false;
			ninja.jumpVelocity = 0;
			ninja.jumpCount = 0;
			// Limpia todos los gráficos actuales del ninja
			while (ninja.children.length > 0) {
				ninja.children[0].destroy();
			}
			var normalNinjaGraphics = ninja.attachAsset('ninja', {
				anchorX: 0.5,
				anchorY: 1.0
			});
			ninja.flipDirection = 1;
			ninja.runningTimer = 29;
			normalNinjaGraphics.scaleX = ninja.flipDirection;
			normalNinjaGraphics.rotation = 0;
			ninja.update();
		}
	}
	if (casaNinja && casaNinja.active) {
		if (!isInCasaNinja) {
			casaNinja.update();
		}
	}
	var currentScore = LK.getScore();
	var shouldActivateCasaNinja = false;
	var activationPoint = 0;
	if (currentScore >= 100 && currentScore < 200) {
		activationPoint = 100;
	} else if (currentScore >= 300 && currentScore < 400) {
		activationPoint = 300;
	} else if (currentScore >= 600 && currentScore < 700) {
		activationPoint = 600;
	} else if (currentScore >= 1000 && currentScore < 1100) {
		activationPoint = 1000;
	} else if (currentScore >= 2000 && currentScore % 1000 >= 0 && currentScore % 1000 < 100) {
		activationPoint = Math.floor(currentScore / 1000) * 1000;
	}
	if (activationPoint > 0 && casaNinjaActivatedPoints.indexOf(activationPoint) === -1) {
		shouldActivateCasaNinja = true;
	}
	if (!isInCasaNinja && shouldActivateCasaNinja) {
		casaNinjaActivated = true;
		casaNinjaActivatedPoints.push(activationPoint);
		casaNinja = new CasaNinja();
		casaNinja.z = 1000;
		game.addChild(casaNinja);
	}
	if (!isInCasaNinja && casaNinja && casaNinja.active && casaNinja.z < 100 && casaNinja.z > -100) {
		isInCasaNinja = true;
		casaNinjaVisitCount++;
		casaNinjaSequenceTimer = 0;
		casaNinjaSequenceStage = 0;
		LK.setTimeout(function () {
			showPhaseInfo();
		}, 1000);
		ninjaParalyzed = true;
		tween(ninja, {
			x: casaNinja.x,
			y: casaNinja.y - 50
		}, {
			duration: 1200,
			easing: tween.easeInOut,
			onFinish: function onFinish() {
				tween(ninja, {
					alpha: 0,
					scaleX: 0.5,
					scaleY: 0.5
				}, {
					duration: 300,
					easing: tween.easeIn,
					onFinish: function onFinish() {
						casaNinjaSequenceStage = 1;
						casaNinjaSequenceTimer = 0;
					}
				});
			}
		});
	}
	if (isInCasaNinja && casaNinjaSequenceStage > 0) {
		casaNinjaSequenceTimer++;
		switch (casaNinjaSequenceStage) {
			case 1:
				if (casaNinjaSequenceTimer === 1) {
					LK.getSound('portazo').play();
					casaNinja.changeState(false);
					tween(casaNinja, {
						x: casaNinja.x + 10
					}, {
						duration: 50,
						easing: tween.easeInOut,
						onFinish: function onFinish() {
							tween(casaNinja, {
								x: casaNinja.x - 20
							}, {
								duration: 50,
								easing: tween.easeInOut,
								onFinish: function onFinish() {
									tween(casaNinja, {
										x: casaNinja.x + 10
									}, {
										duration: 50,
										easing: tween.easeInOut
									});
								}
							});
						}
					});
				}
				if (casaNinjaSequenceTimer >= 120) {
					casaNinjaSequenceStage = 2;
					casaNinjaSequenceTimer = 0;
				}
				break;
			case 2:
				var cycleNumber = (casaNinjaVisitCount - 1) % 3 + 1;
				if (cycleNumber === 1) {
					if (casaNinjaSequenceTimer === 1) {
						LK.getSound('meo').play();
					}
					if (casaNinjaSequenceTimer >= 300) {
						casaNinjaSequenceStage = 3;
						casaNinjaSequenceTimer = 0;
					}
				} else if (cycleNumber === 2) {
					if (casaNinjaSequenceTimer === 1) {
						LK.getSound('meo').play();
					}
					if (casaNinjaSequenceTimer === 180) {
						LK.getSound('pedos').play();
					}
					if (casaNinjaSequenceTimer >= 300) {
						casaNinjaSequenceStage = 3;
						casaNinjaSequenceTimer = 0;
					}
				} else if (cycleNumber === 3) {
					if (casaNinjaSequenceTimer === 1) {
						LK.getSound('pedoLargo').play();
					}
					if (casaNinjaSequenceTimer >= 300) {
						casaNinjaSequenceStage = 3;
						casaNinjaSequenceTimer = 0;
					}
				}
				break;
			case 3:
				var cycleNumber = (casaNinjaVisitCount - 1) % 3 + 1;
				if (cycleNumber <= 2) {
					if (casaNinjaSequenceTimer === 1) {
						LK.getSound('alivio').play();
					}
					if (casaNinjaSequenceTimer >= 120) {
						casaNinjaSequenceStage = 4;
						casaNinjaSequenceTimer = 0;
					}
				} else {
					if (casaNinjaSequenceTimer === 1) {
						LK.getSound('bloop').play();
					}
					if (casaNinjaSequenceTimer >= 120) {
						casaNinjaSequenceStage = 4;
						casaNinjaSequenceTimer = 0;
					}
				}
				break;
			case 4:
				var cycleNumber = (casaNinjaVisitCount - 1) % 3 + 1;
				if (cycleNumber <= 2) {
					if (casaNinjaSequenceTimer === 1) {
						LK.getSound('wc').play();
					}
					if (casaNinjaSequenceTimer >= 120) {
						casaNinjaSequenceStage = 5;
						casaNinjaSequenceTimer = 0;
					}
				} else {
					if (casaNinjaSequenceTimer === 1) {
						LK.getSound('alivio').play();
					}
					if (casaNinjaSequenceTimer >= 120) {
						casaNinjaSequenceStage = 5;
						casaNinjaSequenceTimer = 0;
					}
				}
				break;
			case 5:
				if (casaNinjaSequenceTimer === 1) {
					LK.getSound('puerta-abre').play();
				}
				if (casaNinjaSequenceTimer >= 120) {
					casaNinjaSequenceStage = 6;
					casaNinjaSequenceTimer = 0;
				}
				break;
			case 6:
				if (casaNinjaSequenceTimer === 1) {
					LK.getSound('portazo').play();
					tween(casaNinja, {
						x: casaNinja.x + 10
					}, {
						duration: 50,
						easing: tween.easeInOut,
						onFinish: function onFinish() {
							tween(casaNinja, {
								x: casaNinja.x - 20
							}, {
								duration: 50,
								easing: tween.easeInOut,
								onFinish: function onFinish() {
									tween(casaNinja, {
										x: casaNinja.x + 10
									}, {
										duration: 50,
										easing: tween.easeInOut
									});
								}
							});
						}
					});
					tween(ninja, {
						x: 1024,
						y: 2673,
						alpha: 1,
						scaleX: 1,
						scaleY: 1
					}, {
						duration: 800,
						easing: tween.easeInOut,
						onFinish: function onFinish() {
							tween(ninja, {
								y: 2673 - 20
							}, {
								duration: 200,
								easing: tween.easeOut,
								onFinish: function onFinish() {
									tween(ninja, {
										y: 2673
									}, {
										duration: 200,
										easing: tween.easeIn
									});
								}
							});
						}
					});
				}
				if (casaNinjaSequenceTimer >= 60) {
					ninjaParalyzed = false;
					isInCasaNinja = false;
					casaNinjaSequenceStage = 0;
					casaNinjaSequenceTimer = 0;
					casaNinjaActivated = false;
					if (casaNinja) {
						casaNinja.active = false;
						casaNinja.destroy();
						casaNinja = null;
					}
				}
				break;
		}
	}
	if (!isInCasaNinja && LK.ticks % 60 === 0) {
		LK.setScore(LK.getScore() + 1);
		updateScore();
	}
	if (isInCasaNinja) {
		updateScore();
	}
	showCurrentPhase();
	for (var i = alerts.length - 1; i >= 0; i--) {
		var alert = alerts[i];
		alert.update();
		if (!alert.active) {
			alert.destroy();
			alerts.splice(i, 1);
		}
	}
	if (!isInCasaNinja && LK.ticks % 10 === 0) {
		sortObjectsByDepth();
	}
	if (game.phaseDisplay) {
		game.phaseDisplay.alpha = 1;
	}
	if (isFeatureUnlocked('sun')) {
		if (sun.alpha < 1) {
			sun.alpha = 1;
			tween(sun, {
				x: 1700
			}, {
				duration: 1000,
				easing: tween.easeOut
			});
		}
	} else {
		if (sun.alpha > 0) {
			tween(sun, {
				x: 2500
			}, {
				duration: 500,
				easing: tween.easeIn,
				onFinish: function onFinish() {
					sun.alpha = 0;
				}
			});
		}
	}
};